(* Modified by Milos Radovanovic, 2000, 2001 *)

IMPLEMENTATION MODULE C2S;

FROM  C2G  IMPORT 
  EOFSYM, identifierSym, integerSym, realSym, stringSym, MODULESym, 
  semicolonSym, pointSym, lbrackSym, rbrackSym, DEFINITIONSym, ENDSym, 
  IMPLEMENTATIONSym, IMPORTSym, commaSym, FROMSym, EXPORTSym, QUALIFIEDSym, 
  CONSTSym, TYPESym, VARSym, PROCEDURESym, lparenSym, rparenSym, colonSym, 
  ARRAYSym, OFSym, equalSym, FORWARDSym, pointpointSym, SETSym, PACKEDSETSym, 
  POINTERSym, TOSym, RECORDSym, CASESym, barSym, ELSESym, BEGINSym, 
  FINALLYSym, EXCEPTSym, colonequalSym, RETURNSym, RETRYSym, WITHSym, DOSym, 
  IFSym, THENSym, ELSIFSym, WHILESym, REPEATSym, UNTILSym, LOOPSym, EXITSym, 
  FORSym, BYSym, uparrowSym, atSym, plusSym, minusSym, tildeSym, NOTSym, 
  hashSym, lessgreaterSym, lessSym, greaterSym, lessequalSym, greaterequalSym, 
  INSym, ORSym, starSym, slashSym, REMSym, DIVSym, MODSym, andSym, ANDSym, 
  lbraceSym, rbraceSym, NILSym, NOSYM;

(* Scanner generated by Coco/R - assuming FileIO library will be available. *)

IMPORT FileIO;
FROM Storage IMPORT ALLOCATE, DEALLOCATE;

CONST
  noSYMB  = NOSYM; (*error token code*)
  (* not only for errors but also for not finished states of scanner analysis *)
  BlkSize = 16384;
TYPE
  BufBlock   = ARRAY [0 .. BlkSize-1] OF CHAR;
  Buffer     = ARRAY [0 .. 31] OF POINTER TO BufBlock;
  StartTable = ARRAY [0 .. 255] OF INTEGER;
  GetCH      = PROCEDURE (INT32): CHAR;
  CommentPtr = POINTER TO CommentRec;
  CommentRec = RECORD
                 begCom, endCom: INT32;
                 next: CommentPtr;
               END;

VAR
  eof, EOFILE, EOL, CR, LF: CHAR;
  Long0, Long1: INT32;

  lastCh,
  ch:        CHAR;       (*current input character*)
  curLine:   INTEGER;    (*current input line (may be higher than line)*)
  lineStart: INT32;      (*start position of current line*)
  apx:       INT32;      (*length of appendix (CONTEXT phrase)*)
  oldEols:   INTEGER;    (*number of EOLs in a comment*)
  bp, bp0:   INT32;      (*current position in buf
                           (bp0: position of current token)*)
  LBlkSize:  INT32;      (*BlkSize*)
  inputLen:  INT32;      (*source file size*)
  buf:       Buffer;     (*source buffer for low-level access*)
  start:     StartTable; (*start state for every character*)
  CurrentCh: GetCH;
  firstComment, lastComment: CommentPtr;

PROCEDURE ORDL (n: INT32): CARDINAL;
 BEGIN
   RETURN FileIO.ORDL(n)
 END ORDL;

PROCEDURE Err (nr, line, col: INTEGER; pos: INT32);
  BEGIN
    INC(errors)
  END Err;

PROCEDURE NextCh;
(* Return global variable ch *)
  BEGIN
    lastCh := ch; INC(bp); ch := CurrentCh(bp);
    IF (ch = EOL) OR (ch = FileIO.LF) AND (lastCh # EOL) THEN
      INC(curLine); lineStart := bp
    END
  END NextCh;

PROCEDURE HaveComment (): BOOLEAN;
  VAR
    level, startLine: INTEGER;
    oldLineStart: INT32;
  BEGIN
    level := 1; startLine := curLine; oldLineStart := lineStart;
    (* IF (ch = "(") THEN
         NextCh;
         IF (ch = "*") THEN
           NextCh;
           LOOP
             IF (ch = "*") THEN
               NextCh;
               IF (ch = ")") THEN
                 DEC(level); NextCh;
                 IF level = 0 THEN RETURN TRUE END
               END;
             ELSIF (ch = "(") THEN
               NextCh;
               IF (ch = "*") THEN INC(level); NextCh END;
             ELSIF ch = EOF THEN RETURN FALSE
             ELSE NextCh END;
           END; (* LOOP *)
         ELSE
           IF (ch = CR) OR (ch = LF) THEN
             DEC(curLine); lineStart := oldLineStart
           END;
           DEC(bp); ch := lastCh;
         END;
       END;
       RETURN FALSE; *)
    (* Following code of procedure HaveComment was pasted in directly
       because of the need to change EOF to EOFILE. Now, if COMMENTS
       directive were changed in .ATG, nothing would happen,
       since '-->comment' is commented out *)
    IF (ch = "(") THEN
      NextCh;
      IF (ch = "*") THEN
        NextCh;
        LOOP
          IF (ch = "*") THEN
            NextCh;
            IF (ch = ")") THEN
              DEC(level); NextCh;
              IF level = 0 THEN RETURN TRUE END
            END;
          ELSIF (ch = "(") THEN
            NextCh;
            IF (ch = "*") THEN INC(level); NextCh END;
          ELSIF ch = EOFILE THEN RETURN FALSE
          ELSE NextCh END;
        END; (* LOOP *)
      ELSE
        IF (ch = CR) OR (ch = LF) THEN
          DEC(curLine); lineStart := oldLineStart
        END;
        DEC(bp); ch := lastCh;
      END;
    END;
    RETURN FALSE;
  END HaveComment;

PROCEDURE Comment (): BOOLEAN;
  VAR
    SeenComment: BOOLEAN;
    beginC, endC: INT32;
    nextComment: CommentPtr;
  BEGIN
    beginC := bp;
    SeenComment := HaveComment();
    endC := bp; DEC(endC);
    IF endC > beginC THEN
      seenComment := TRUE;
      NEW(nextComment);
      nextComment^.begCom := beginC;
      nextComment^.endCom := endC;
      nextComment^.next := NIL;
      IF firstComment = NIL
        THEN firstComment := nextComment
        ELSE lastComment^.next := nextComment
      END;
    lastComment := nextComment;
    END;
    RETURN SeenComment;
  END Comment;

PROCEDURE GetComment (VAR comment: ARRAY OF CHAR; pos: CARDINAL; VAR length: CARDINAL);
  VAR
    thisComment: CommentPtr;
  BEGIN
    length := 0;
    WHILE firstComment # NIL DO
      thisComment := firstComment;
      WHILE (pos + length <= HIGH(comment)) AND (thisComment^.begCom <= thisComment^.endCom) DO
        comment[pos + length] := CharAt(thisComment^.begCom);
        INC(length); INC(thisComment^.begCom);
      END;
      firstComment := firstComment^.next;
      DISPOSE(thisComment)
    END;
    seenComment := FALSE;
  END GetComment;

PROCEDURE Equal (s: ARRAY OF CHAR): BOOLEAN;
  VAR
    i: CARDINAL;
    q: INT32;
  BEGIN
    IF nextLen # FileIO.SLENGTH(s) THEN RETURN FALSE END;
    i := 1; q := bp0; INC(q);
    WHILE i < nextLen DO
      IF CurrentCh(q) # s[i] THEN RETURN FALSE END;
      INC(i); INC(q)
    END;
    RETURN TRUE
  END Equal;

VAR
  sym: CARDINAL;

PROCEDURE CheckLiteral;
  BEGIN
    CASE CurrentCh(bp0) OF
      "A": IF Equal("AND") THEN sym := ANDSym; 
           ELSIF Equal("ARRAY") THEN sym := ARRAYSym; 
           END
    | "B": IF Equal("BEGIN") THEN sym := BEGINSym; 
           ELSIF Equal("BY") THEN sym := BYSym; 
           END
    | "C": IF Equal("CASE") THEN sym := CASESym; 
           ELSIF Equal("CONST") THEN sym := CONSTSym; 
           END
    | "D": IF Equal("DEFINITION") THEN sym := DEFINITIONSym; 
           ELSIF Equal("DIV") THEN sym := DIVSym; 
           ELSIF Equal("DO") THEN sym := DOSym; 
           END
    | "E": IF Equal("ELSE") THEN sym := ELSESym; 
           ELSIF Equal("ELSIF") THEN sym := ELSIFSym; 
           ELSIF Equal("END") THEN sym := ENDSym; 
           ELSIF Equal("EXCEPT") THEN sym := EXCEPTSym; 
           ELSIF Equal("EXIT") THEN sym := EXITSym; 
           ELSIF Equal("EXPORT") THEN sym := EXPORTSym; 
           END
    | "F": IF Equal("FINALLY") THEN sym := FINALLYSym; 
           ELSIF Equal("FOR") THEN sym := FORSym; 
           ELSIF Equal("FORWARD") THEN sym := FORWARDSym; 
           ELSIF Equal("FROM") THEN sym := FROMSym; 
           END
    | "I": IF Equal("IF") THEN sym := IFSym; 
           ELSIF Equal("IMPLEMENTATION") THEN sym := IMPLEMENTATIONSym; 
           ELSIF Equal("IMPORT") THEN sym := IMPORTSym; 
           ELSIF Equal("IN") THEN sym := INSym; 
           END
    | "L": IF Equal("LOOP") THEN sym := LOOPSym; 
           END
    | "M": IF Equal("MOD") THEN sym := MODSym; 
           ELSIF Equal("MODULE") THEN sym := MODULESym; 
           END
    | "N": IF Equal("NIL") THEN sym := NILSym; 
           ELSIF Equal("NOT") THEN sym := NOTSym; 
           END
    | "O": IF Equal("OF") THEN sym := OFSym; 
           ELSIF Equal("OR") THEN sym := ORSym; 
           END
    | "P": IF Equal("PACKEDSET") THEN sym := PACKEDSETSym; 
           ELSIF Equal("POINTER") THEN sym := POINTERSym; 
           ELSIF Equal("PROCEDURE") THEN sym := PROCEDURESym; 
           END
    | "Q": IF Equal("QUALIFIED") THEN sym := QUALIFIEDSym; 
           END
    | "R": IF Equal("RECORD") THEN sym := RECORDSym; 
           ELSIF Equal("REM") THEN sym := REMSym; 
           ELSIF Equal("REPEAT") THEN sym := REPEATSym; 
           ELSIF Equal("RETRY") THEN sym := RETRYSym; 
           ELSIF Equal("RETURN") THEN sym := RETURNSym; 
           END
    | "S": IF Equal("SET") THEN sym := SETSym; 
           END
    | "T": IF Equal("THEN") THEN sym := THENSym; 
           ELSIF Equal("TO") THEN sym := TOSym; 
           ELSIF Equal("TYPE") THEN sym := TYPESym; 
           END
    | "U": IF Equal("UNTIL") THEN sym := UNTILSym; 
           END
    | "V": IF Equal("VAR") THEN sym := VARSym; 
           END
    | "W": IF Equal("WHILE") THEN sym := WHILESym; 
           ELSIF Equal("WITH") THEN sym := WITHSym; 
           END
    ELSE
    END
  END CheckLiteral;

PROCEDURE Get2;
  VAR
    state: CARDINAL;

  BEGIN (*Get2*)
    WHILE (ch = ' ') OR
          ((ch >= CHR(9)) & (ch <= CHR(13))) DO NextCh END;
    IF ((ch = "(")) & Comment() THEN Get(sym); RETURN END;
    pos := nextPos;   nextPos := bp;
    col := nextCol;   nextCol := FileIO.INTL(bp - lineStart);
    line := nextLine; nextLine := curLine;
    len := nextLen;   nextLen := 0;
    apx := FileIO.Long0; state := start[ORD(ch)]; bp0 := bp;
    LOOP
      NextCh; INC(nextLen);
      CASE state OF
         1: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "Z") OR
               (ch = "_") OR
               (ch >= "a") & (ch <= "z")) THEN 
            ELSE sym := identifierSym; CheckLiteral; RETURN
            END;
      |  2: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "F")) THEN 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := noSYMB; RETURN
            END;
      |  3: bp := bp - apx - Long1; DEC(nextLen, ORDL(apx)); NextCh; sym := integerSym; RETURN
      |  4: sym := integerSym; RETURN
      |  5: IF ((ch >= "0") & (ch <= "9")) THEN 
            ELSIF (ch = "E") THEN state := 6; 
            ELSE sym := realSym; RETURN
            END;
      |  6: IF ((ch >= "0") & (ch <= "9")) THEN state := 8; 
            ELSIF ((ch = "+") OR
                  (ch = "-")) THEN state := 7; 
            ELSE sym := noSYMB; RETURN
            END;
      |  7: IF ((ch >= "0") & (ch <= "9")) THEN state := 8; 
            ELSE sym := noSYMB; RETURN
            END;
      |  8: IF ((ch >= "0") & (ch <= "9")) THEN 
            ELSE sym := realSym; RETURN
            END;
      |  9: IF ((ch <= CHR(12)) OR
               (ch >= CHR(14)) & (ch <= "&") OR
               (ch >= "(")) THEN 
            ELSIF (ch = "'") THEN state := 11; 
            ELSE sym := noSYMB; RETURN
            END;
      | 10: IF ((ch <= CHR(12)) OR
               (ch >= CHR(14)) & (ch <= "!") OR
               (ch >= "#")) THEN 
            ELSIF (ch = '"') THEN state := 11; 
            ELSE sym := noSYMB; RETURN
            END;
      | 11: sym := stringSym; RETURN
      | 12: IF ((ch >= "0") & (ch <= "9")) THEN 
            ELSIF ((ch >= "A") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = ".") THEN state := 14; INC(apx) 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := integerSym; RETURN
            END;
      | 13: IF ((ch >= "8") & (ch <= "9")) THEN state := 12; 
            ELSIF ((ch >= "0") & (ch <= "7")) THEN 
            ELSIF ((ch = "A") OR
                  (ch >= "D") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = ".") THEN state := 14; INC(apx) 
            ELSIF (ch = "B") THEN state := 15; 
            ELSIF (ch = "C") THEN state := 16; 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := integerSym; RETURN
            END;
      | 14: IF ((ch >= "0") & (ch <= "9")) THEN state := 5; apx := Long0 
            ELSIF (ch = ".") THEN state := 3; INC(apx) 
            ELSIF (ch = "E") THEN state := 6; apx := Long0 
            ELSE sym := realSym; RETURN
            END;
      | 15: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := integerSym; RETURN
            END;
      | 16: IF ((ch >= "0") & (ch <= "9") OR
               (ch >= "A") & (ch <= "F")) THEN state := 2; 
            ELSIF (ch = "H") THEN state := 4; 
            ELSE sym := integerSym; RETURN
            END;
      | 17: sym := semicolonSym; RETURN
      | 18: IF (ch = ".") THEN state := 26; 
            ELSE sym := pointSym; RETURN
            END;
      | 19: sym := lbrackSym; RETURN
      | 20: sym := rbrackSym; RETURN
      | 21: sym := commaSym; RETURN
      | 22: sym := lparenSym; RETURN
      | 23: sym := rparenSym; RETURN
      | 24: IF (ch = "=") THEN state := 28; 
            ELSE sym := colonSym; RETURN
            END;
      | 25: sym := equalSym; RETURN
      | 26: sym := pointpointSym; RETURN
      | 27: sym := barSym; RETURN
      | 28: sym := colonequalSym; RETURN
      | 29: sym := uparrowSym; RETURN
      | 30: sym := atSym; RETURN
      | 31: sym := plusSym; RETURN
      | 32: sym := minusSym; RETURN
      | 33: sym := tildeSym; RETURN
      | 34: sym := hashSym; RETURN
      | 35: IF (ch = ">") THEN state := 36; 
            ELSIF (ch = "=") THEN state := 38; 
            ELSE sym := lessSym; RETURN
            END;
      | 36: sym := lessgreaterSym; RETURN
      | 37: IF (ch = "=") THEN state := 39; 
            ELSE sym := greaterSym; RETURN
            END;
      | 38: sym := lessequalSym; RETURN
      | 39: sym := greaterequalSym; RETURN
      | 40: sym := starSym; RETURN
      | 41: sym := slashSym; RETURN
      | 42: sym := andSym; RETURN
      | 43: sym := lbraceSym; RETURN
      | 44: sym := rbraceSym; RETURN
      | 45: sym := EOFSYM; ch := 0C; DEC(bp); RETURN
      ELSE sym := noSYMB; RETURN (*NextCh already done*)
      END
    END
  END Get2;

PROCEDURE Get (VAR symb: CARDINAL);
  BEGIN
    Get2;
    symb := sym;
  END Get;

PROCEDURE GetString (pos: INT32; len: CARDINAL; VAR s: ARRAY OF CHAR);
  VAR
    i: CARDINAL;
    p: INT32;
  BEGIN
    IF len > HIGH(s) THEN len := HIGH(s) END;
    p := pos; i := 0;
    WHILE i < len DO
      s[i] := CharAt(p); INC(i); INC(p)
    END;
    s[len] := 0C;
  END GetString;

PROCEDURE GetName (pos: INT32; len: CARDINAL; VAR s: ARRAY OF CHAR);
  VAR
    i: CARDINAL;
    p: INT32;
  BEGIN
    IF len > HIGH(s) THEN len := HIGH(s) END;
    p := pos; i := 0;
    WHILE i < len DO
      s[i] := CurrentCh(p); INC(i); INC(p)
    END;
    s[len] := 0C;
  END GetName;

PROCEDURE CharAt (pos: INT32): CHAR;
  VAR
    ch: CHAR;
  BEGIN
    IF pos >= inputLen THEN RETURN FileIO.EOFILE END;
    ch := buf[FileIO.ORDL(pos DIV LBlkSize)]^[FileIO.ORDL(pos MOD LBlkSize)];
    IF ch # eof THEN RETURN ch ELSE RETURN FileIO.EOFILE END
  END CharAt;

PROCEDURE CapChAt (pos: INT32): CHAR;
  VAR
    ch: CHAR;
  BEGIN
    IF pos >= inputLen THEN RETURN FileIO.EOFILE END;
    ch := CAP(buf[FileIO.ORDL(pos DIV LBlkSize)]^[FileIO.ORDL(pos MOD LBlkSize)]);
    IF ch # eof THEN RETURN ch ELSE RETURN FileIO.EOFILE END
  END CapChAt;

PROCEDURE Reset;
  VAR
    len: INT32;
    i, bytesRead: CARDINAL;
  BEGIN (*assert: src has been opened*)
    len := FileIO.Length(src); i := 0; inputLen := len;
    WHILE len > LBlkSize DO
      NEW(buf[i]);
      bytesRead := BlkSize; FileIO.ReadBytes(src, buf[i]^, bytesRead);
      len := len - FileIO.INT(bytesRead); INC(i)
    END;
    NEW(buf[i]);
    bytesRead := FileIO.ORDL(len); FileIO.ReadBytes(src, buf[i]^, bytesRead);
    buf[i]^[bytesRead] := EOFILE;
    curLine := 1; lineStart := -FileIO.Long2; bp := -FileIO.Long1;
    oldEols := 0; apx := FileIO.Long0; errors := 0;
    NextCh;
  END Reset;

BEGIN
  CurrentCh := CharAt;
  start[  0] := 45; start[  1] := 46; start[  2] := 46; start[  3] := 46; 
  start[  4] := 46; start[  5] := 46; start[  6] := 46; start[  7] := 46; 
  start[  8] := 46; start[  9] := 46; start[ 10] := 46; start[ 11] := 46; 
  start[ 12] := 46; start[ 13] := 46; start[ 14] := 46; start[ 15] := 46; 
  start[ 16] := 46; start[ 17] := 46; start[ 18] := 46; start[ 19] := 46; 
  start[ 20] := 46; start[ 21] := 46; start[ 22] := 46; start[ 23] := 46; 
  start[ 24] := 46; start[ 25] := 46; start[ 26] := 46; start[ 27] := 46; 
  start[ 28] := 46; start[ 29] := 46; start[ 30] := 46; start[ 31] := 46; 
  start[ 32] := 46; start[ 33] := 46; start[ 34] := 10; start[ 35] := 34; 
  start[ 36] := 46; start[ 37] := 46; start[ 38] := 42; start[ 39] :=  9; 
  start[ 40] := 22; start[ 41] := 23; start[ 42] := 40; start[ 43] := 31; 
  start[ 44] := 21; start[ 45] := 32; start[ 46] := 18; start[ 47] := 41; 
  start[ 48] := 13; start[ 49] := 13; start[ 50] := 13; start[ 51] := 13; 
  start[ 52] := 13; start[ 53] := 13; start[ 54] := 13; start[ 55] := 13; 
  start[ 56] := 12; start[ 57] := 12; start[ 58] := 24; start[ 59] := 17; 
  start[ 60] := 35; start[ 61] := 25; start[ 62] := 37; start[ 63] := 46; 
  start[ 64] := 30; start[ 65] :=  1; start[ 66] :=  1; start[ 67] :=  1; 
  start[ 68] :=  1; start[ 69] :=  1; start[ 70] :=  1; start[ 71] :=  1; 
  start[ 72] :=  1; start[ 73] :=  1; start[ 74] :=  1; start[ 75] :=  1; 
  start[ 76] :=  1; start[ 77] :=  1; start[ 78] :=  1; start[ 79] :=  1; 
  start[ 80] :=  1; start[ 81] :=  1; start[ 82] :=  1; start[ 83] :=  1; 
  start[ 84] :=  1; start[ 85] :=  1; start[ 86] :=  1; start[ 87] :=  1; 
  start[ 88] :=  1; start[ 89] :=  1; start[ 90] :=  1; start[ 91] := 19; 
  start[ 92] := 46; start[ 93] := 20; start[ 94] := 29; start[ 95] := 46; 
  start[ 96] := 46; start[ 97] :=  1; start[ 98] :=  1; start[ 99] :=  1; 
  start[100] :=  1; start[101] :=  1; start[102] :=  1; start[103] :=  1; 
  start[104] :=  1; start[105] :=  1; start[106] :=  1; start[107] :=  1; 
  start[108] :=  1; start[109] :=  1; start[110] :=  1; start[111] :=  1; 
  start[112] :=  1; start[113] :=  1; start[114] :=  1; start[115] :=  1; 
  start[116] :=  1; start[117] :=  1; start[118] :=  1; start[119] :=  1; 
  start[120] :=  1; start[121] :=  1; start[122] :=  1; start[123] := 43; 
  start[124] := 27; start[125] := 44; start[126] := 33; start[127] := 46; 
  start[128] := 46; start[129] := 46; start[130] := 46; start[131] := 46; 
  start[132] := 46; start[133] := 46; start[134] := 46; start[135] := 46; 
  start[136] := 46; start[137] := 46; start[138] := 46; start[139] := 46; 
  start[140] := 46; start[141] := 46; start[142] := 46; start[143] := 46; 
  start[144] := 46; start[145] := 46; start[146] := 46; start[147] := 46; 
  start[148] := 46; start[149] := 46; start[150] := 46; start[151] := 46; 
  start[152] := 46; start[153] := 46; start[154] := 46; start[155] := 46; 
  start[156] := 46; start[157] := 46; start[158] := 46; start[159] := 46; 
  start[160] := 46; start[161] := 46; start[162] := 46; start[163] := 46; 
  start[164] := 46; start[165] := 46; start[166] := 46; start[167] := 46; 
  start[168] := 46; start[169] := 46; start[170] := 46; start[171] := 46; 
  start[172] := 46; start[173] := 46; start[174] := 46; start[175] := 46; 
  start[176] := 46; start[177] := 46; start[178] := 46; start[179] := 46; 
  start[180] := 46; start[181] := 46; start[182] := 46; start[183] := 46; 
  start[184] := 46; start[185] := 46; start[186] := 46; start[187] := 46; 
  start[188] := 46; start[189] := 46; start[190] := 46; start[191] := 46; 
  start[192] := 46; start[193] := 46; start[194] := 46; start[195] := 46; 
  start[196] := 46; start[197] := 46; start[198] := 46; start[199] := 46; 
  start[200] := 46; start[201] := 46; start[202] := 46; start[203] := 46; 
  start[204] := 46; start[205] := 46; start[206] := 46; start[207] := 46; 
  start[208] := 46; start[209] := 46; start[210] := 46; start[211] := 46; 
  start[212] := 46; start[213] := 46; start[214] := 46; start[215] := 46; 
  start[216] := 46; start[217] := 46; start[218] := 46; start[219] := 46; 
  start[220] := 46; start[221] := 46; start[222] := 46; start[223] := 46; 
  start[224] := 46; start[225] := 46; start[226] := 46; start[227] := 46; 
  start[228] := 46; start[229] := 46; start[230] := 46; start[231] := 46; 
  start[232] := 46; start[233] := 46; start[234] := 46; start[235] := 46; 
  start[236] := 46; start[237] := 46; start[238] := 46; start[239] := 46; 
  start[240] := 46; start[241] := 46; start[242] := 46; start[243] := 46; 
  start[244] := 46; start[245] := 46; start[246] := 46; start[247] := 46; 
  start[248] := 46; start[249] := 46; start[250] := 46; start[251] := 46; 
  start[252] := 46; start[253] := 46; start[254] := 46; start[255] := 46; 
  eof     := 32C (* MS-DOS Keyboard eof char *);
  EOFILE  := FileIO.EOFILE;
  EOL     := FileIO.CR;
  CR      := FileIO.CR;
  LF      := FileIO.LF;
  Long0   := FileIO.Long0;
  Long1   := FileIO.Long1;
  Error := Err; LBlkSize := FileIO.INT(BlkSize); lastCh := EOFILE;
  firstComment := NIL; seenComment := FALSE;
END C2S.
