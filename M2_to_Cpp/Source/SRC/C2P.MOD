IMPLEMENTATION MODULE C2P;

FROM  C2G  IMPORT 
  EOFSYM, identifierSym, integerSym, realSym, stringSym, MODULESym, 
  semicolonSym, pointSym, lbrackSym, rbrackSym, DEFINITIONSym, ENDSym, 
  IMPLEMENTATIONSym, IMPORTSym, commaSym, FROMSym, EXPORTSym, QUALIFIEDSym, 
  CONSTSym, TYPESym, VARSym, PROCEDURESym, lparenSym, rparenSym, colonSym, 
  ARRAYSym, OFSym, equalSym, FORWARDSym, pointpointSym, SETSym, PACKEDSETSym, 
  POINTERSym, TOSym, RECORDSym, CASESym, barSym, ELSESym, BEGINSym, 
  FINALLYSym, EXCEPTSym, colonequalSym, RETURNSym, RETRYSym, WITHSym, DOSym, 
  IFSym, THENSym, ELSIFSym, WHILESym, REPEATSym, UNTILSym, LOOPSym, EXITSym, 
  FORSym, BYSym, uparrowSym, atSym, plusSym, minusSym, tildeSym, NOTSym, 
  hashSym, lessgreaterSym, lessSym, greaterSym, lessequalSym, greaterequalSym, 
  INSym, ORSym, starSym, slashSym, REMSym, DIVSym, MODSym, andSym, ANDSym, 
  lbraceSym, rbraceSym, NILSym, NOSYM;

(* Parser generated by Coco/R - assuming FileIO library will be available. *)

IMPORT FileIO, C2S;

FROM Defs IMPORT IdStr, BigStr, HugeStr;

  FROM Printer IMPORT
    Append, AppendLabel, NewLine, BlankLine, IndentNextLine, ExdentNextLine,
    Indent, Exdent, BackTrack, MarkPrependPos, Prepend, GetPos, Insert, Flush,
    GetBuffer, DelBuffer, OpenResults;

  IMPORT String, Fmt; (* BMB *)
  IMPORT Switches, Import, Ids, Procs, IdQueue, Variants, VFields, Type;

  FROM Write IMPORT AppendCardToStr, WriteIfDefs, WriteIncludes,
    WriteImportUsings, WriteExportUsings, WriteTemplateParams, AppendParams,
    WriteParamReferences, WriteModuleBodyStruct, WriteModuleBodyVar,
    WriteMain;

  VAR
    ModName: IdStr;
    tmpId, tmpId2: IdStr;
    procName: IdStr;
    tmpBig, retStr: BigStr;
    sel: HugeStr;
    isImplMod: BOOLEAN;

  PROCEDURE AppendToken;
    VAR
      token: ARRAY [0 .. 255] OF CHAR;
  BEGIN
    LexString(token); Append(token);
  END AppendToken;

  PROCEDURE ConvertAndAppendString;
    VAR
      token: ARRAY [0 .. 255] OF CHAR;
      high, i: CARDINAL;
      ch: CHAR;
  BEGIN
    LexString(token);
    high := String.Length(token) - 1;
    IF high # 2 THEN
      IF Switches.s THEN Append("_ARRAYOF<CHAR>(") END;
      Append('"');
    ELSE
      Append("'");
    END;
    FOR i := 1 TO high-1 DO
      ch := token[i];
      IF (ch = '\') OR (ch = '?') OR (ch = "'") OR (ch = '"') THEN
        Append('\');
      END;
      Append(ch);
    END;
    IF high # 2 THEN
      Append('"');
      IF Switches.s THEN Append(")") END;
    ELSE
      Append("'");
    END;
  END ConvertAndAppendString;

  PROCEDURE ConvertAndAppendWhole;
    VAR
      token: ARRAY [0 .. 255] OF CHAR;
      high: CARDINAL;
  BEGIN
    LexString(token);
    high := String.Length(token) - 1;
    IF token[high] = 'C' THEN
      token[high] := "'";
      Append("'\");
    ELSIF token[high] = 'B' THEN
      token[high] := 0C;
      Append("0");
    ELSIF token[high] = 'H' THEN
      token[high] := 0C;
      Append("0X");
    END;
    Append(token);
  END ConvertAndAppendWhole;



CONST 
  maxT = 80;
  minErrDist  =  2;  (* minimal distance (good tokens) between two errors *)
  setsize     = 16;  (* sets are stored in 16 bits *)

TYPE
  SymbolSet = ARRAY [0 .. maxT DIV setsize] OF BITSET;

VAR
  symSet:  ARRAY [0 ..  16] OF SymbolSet; (*symSet[0] = allSyncSyms*)
  errDist: CARDINAL;   (* number of symbols recognized since last error *)
  sym:     CARDINAL;   (* current input symbol *)

PROCEDURE SemError (errNo: INTEGER);
  BEGIN
    IF errDist >= minErrDist THEN
      C2S.Error(errNo, C2S.line, C2S.col, C2S.pos);
    END;
    errDist := 0;
  END SemError;

PROCEDURE SynError (errNo: INTEGER);
  BEGIN
    IF errDist >= minErrDist THEN
      C2S.Error(errNo, C2S.nextLine, C2S.nextCol, C2S.nextPos);
    END;
    errDist := 0;
  END SynError;

PROCEDURE Get;
  VAR
    s: ARRAY [0 .. 31] OF CHAR;
  BEGIN
    REPEAT
      C2S.Get(sym);
      IF sym <= maxT THEN
        INC(errDist);
      ELSE
        
      END;
    UNTIL sym <= maxT
  END Get;

PROCEDURE In (VAR s: SymbolSet; x: CARDINAL): BOOLEAN;
  BEGIN
    RETURN x MOD setsize IN s[x DIV setsize];
  END In;

PROCEDURE Expect (n: CARDINAL);
  BEGIN
    IF sym = n THEN Get ELSE SynError(n) END
  END Expect;

PROCEDURE ExpectWeak (n, follow: CARDINAL);
  BEGIN
    IF sym = n
      THEN Get
      ELSE SynError(n); WHILE ~ In(symSet[follow], sym) DO Get END
    END
  END ExpectWeak;

PROCEDURE WeakSeparator (n, syFol, repFol: CARDINAL): BOOLEAN;
  VAR
    s: SymbolSet;
    i: CARDINAL;
  BEGIN
    IF sym = n
      THEN Get; RETURN TRUE
      ELSIF In(symSet[repFol], sym) THEN RETURN FALSE
      ELSE
        i := 0;
        WHILE i <= maxT DIV setsize DO
          s[i] := symSet[0, i] + symSet[syFol, i] + symSet[repFol, i]; INC(i)
        END;
        SynError(n); WHILE ~ In(s, sym) DO Get END;
        RETURN In(symSet[syFol], sym)
    END
  END WeakSeparator;

PROCEDURE LexName (VAR Lex: ARRAY OF CHAR);
  BEGIN
    C2S.GetName(C2S.pos, C2S.len, Lex)
  END LexName;

PROCEDURE LexString (VAR Lex: ARRAY OF CHAR);
  BEGIN
    C2S.GetString(C2S.pos, C2S.len, Lex)
  END LexString;

PROCEDURE LookAheadName (VAR Lex: ARRAY OF CHAR);
  BEGIN
    C2S.GetName(C2S.nextPos, C2S.nextLen, Lex)
  END LookAheadName;

PROCEDURE LookAheadString (VAR Lex: ARRAY OF CHAR);
  BEGIN
    C2S.GetString(C2S.nextPos, C2S.nextLen, Lex)
  END LookAheadString;

PROCEDURE Successful (): BOOLEAN;
  BEGIN
    RETURN C2S.errors = 0
  END Successful;

PROCEDURE ActualParam; FORWARD;
PROCEDURE ActualParamList; FORWARD;
PROCEDURE PointerLiteral; FORWARD;
PROCEDURE StringLiteral; FORWARD;
PROCEDURE RealLiteral; FORWARD;
PROCEDURE WholeNumberLiteral; FORWARD;
PROCEDURE StructComponent; FORWARD;
PROCEDURE RepStructComponent; FORWARD;
PROCEDURE ConstLiteral; FORWARD;
PROCEDURE ConstructedValue; FORWARD;
PROCEDURE FactorOp; FORWARD;
PROCEDURE Factor; FORWARD;
PROCEDURE TermOp; FORWARD;
PROCEDURE Term; FORWARD;
PROCEDURE RelationalOp (VAR isIN: BOOLEAN); FORWARD;
PROCEDURE SimpleExpr; FORWARD;
PROCEDURE IndexExpr; FORWARD;
PROCEDURE StepSize; FORWARD;
PROCEDURE FinalValue; FORWARD;
PROCEDURE InitialValue; FORWARD;
PROCEDURE CaseLabel; FORWARD;
PROCEDURE CaseLabelList; FORWARD;
PROCEDURE OrdExpr; FORWARD;
PROCEDURE CaseElsePart; FORWARD;
PROCEDURE CaseAlternative; FORWARD;
PROCEDURE CaseSelector; FORWARD;
PROCEDURE BooleanExpr; FORWARD;
PROCEDURE IfElsePart; FORWARD;
PROCEDURE GuardedStats; FORWARD;
PROCEDURE ForStat; FORWARD;
PROCEDURE ExitStat; FORWARD;
PROCEDURE LoopStat; FORWARD;
PROCEDURE RepeatStat; FORWARD;
PROCEDURE WhileStat; FORWARD;
PROCEDURE CaseStat; FORWARD;
PROCEDURE IfStat; FORWARD;
PROCEDURE WithStat; FORWARD;
PROCEDURE RetryStat; FORWARD;
PROCEDURE ReturnStat; FORWARD;
PROCEDURE ActualParams; FORWARD;
PROCEDURE Expr; FORWARD;
PROCEDURE Designator; FORWARD;
PROCEDURE EmptyStat; FORWARD;
PROCEDURE Stat; FORWARD;
PROCEDURE StatSeq; FORWARD;
PROCEDURE FinalizationBody; FORWARD;
PROCEDURE InitializationBody; FORWARD;
PROCEDURE ModBody; FORWARD;
PROCEDURE BlockBody; FORWARD;
PROCEDURE ProcBody; FORWARD;
PROCEDURE VariantLabel; FORWARD;
PROCEDURE VariantLabelList; FORWARD;
PROCEDURE VariantElsePart (casePath: BigStr; caseId: IdStr); FORWARD;
PROCEDURE Variant (casePath: BigStr; caseId: IdStr; VAR caseCount: CARDINAL); FORWARD;
PROCEDURE VariantFields (casePath: BigStr; VAR noNameCount: CARDINAL;
                          inCase: BOOLEAN; VAR vList: Variants.List); FORWARD;
PROCEDURE FixedFields (inCase: BOOLEAN; VAR vList: Variants.List); FORWARD;
PROCEDURE FormalType; FORWARD;
PROCEDURE FormalParamType; FORWARD;
PROCEDURE FormalParamTypeList; FORWARD;
PROCEDURE EnumerationType; FORWARD;
PROCEDURE Subrange; FORWARD;
PROCEDURE RecordType (id: IdStr); FORWARD;
PROCEDURE ArrayType; FORWARD;
PROCEDURE ProcType (id: IdStr); FORWARD;
PROCEDURE PointerType (wrTypedef: BOOLEAN); FORWARD;
PROCEDURE PackedsetType; FORWARD;
PROCEDURE SetType; FORWARD;
PROCEDURE OrdTypeDenoter (VAR singleId: IdStr); FORWARD;
PROCEDURE FuncProcBlock (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE ProperProcBlock (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE FuncProc2 (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE ProperProc2 (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE FormalParams2 (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE ValueOfAddressType; FORWARD;
PROCEDURE MachineAddress; FORWARD;
PROCEDURE LocalModDecl (VAR prevEList: Ids.List); FORWARD;
PROCEDURE ProcDecl; FORWARD;
PROCEDURE TypeDecl; FORWARD;
PROCEDURE Decl (VAR eList: Ids.List); FORWARD;
PROCEDURE TypeDenoter (VAR notProcType, isRecType: BOOLEAN; VAR singleId: IdStr;
                            id: IdStr; wrTypedef: BOOLEAN); FORWARD;
PROCEDURE VarParamSpec (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE ValueParamSpec (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE FormalParam (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE FormalParamList (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE FormalParams (VAR procDesc: Procs.ProcDesc); FORWARD;
PROCEDURE ProcHeading; FORWARD;
PROCEDURE VarDecl; FORWARD;
PROCEDURE TypeDef; FORWARD;
PROCEDURE ConstDecl; FORWARD;
PROCEDURE QualId (VAR str: BigStr); FORWARD;
PROCEDURE QualExport; FORWARD;
PROCEDURE UnqualExport (VAR eList: Ids.List); FORWARD;
PROCEDURE ExportList (VAR eList: Ids.List); FORWARD;
PROCEDURE UnqualImport; FORWARD;
PROCEDURE SimpleImport; FORWARD;
PROCEDURE Def; FORWARD;
PROCEDURE ConstExpr; FORWARD;
PROCEDURE ProtExpr; FORWARD;
PROCEDURE ModBlock (modName: IdStr; eList: Ids.List); FORWARD;
PROCEDURE ImportList; FORWARD;
PROCEDURE Prot; FORWARD;
PROCEDURE Id; FORWARD;
PROCEDURE ImplMod; FORWARD;
PROCEDURE DefMod; FORWARD;
PROCEDURE ProgMod; FORWARD;
PROCEDURE C2; FORWARD;

PROCEDURE ActualParam;
  BEGIN
    Expr;
  END ActualParam;

PROCEDURE ActualParamList;
  BEGIN
    ActualParam;
    WHILE (sym = commaSym) DO
      Get;
      Append(", ");
      ActualParam;
    END;
  END ActualParamList;

PROCEDURE PointerLiteral;
  BEGIN
    IF (sym = NILSym) THEN
      Get;
      Append("ADDRESS(0)");
    ELSIF (sym = lbrackSym) THEN
      Get;
      Append("ADDRESS(");
      WholeNumberLiteral;
      IF (sym = colonSym) THEN
        Get;
        Append(" << 4 + ");
        WholeNumberLiteral;
      END;
      Expect(rbrackSym);
      Append(")");
    ELSE SynError(81);
    END;
  END PointerLiteral;

PROCEDURE StringLiteral;
  BEGIN
    Expect(stringSym);
    ConvertAndAppendString;
  END StringLiteral;

PROCEDURE RealLiteral;
  BEGIN
    Expect(realSym);
    AppendToken;
  END RealLiteral;

PROCEDURE WholeNumberLiteral;
  BEGIN
    Expect(integerSym);
    ConvertAndAppendWhole;
  END WholeNumberLiteral;

PROCEDURE StructComponent;
  BEGIN
    Expr;
  END StructComponent;

PROCEDURE RepStructComponent;
  BEGIN
    Append(".incl(");
    StructComponent;
    IF (sym = pointpointSym) OR
       (sym = BYSym) THEN
      IF (sym = BYSym) THEN
        Get;
        Append(", ");
        ConstExpr;
      ELSE
        Get;
        Append(", ");
        OrdExpr;
      END;
    END;
    Append(")");
  END RepStructComponent;

PROCEDURE ConstLiteral;
  BEGIN
    IF (sym = integerSym) THEN
      WholeNumberLiteral;
    ELSIF (sym = realSym) THEN
      RealLiteral;
    ELSIF (sym = stringSym) THEN
      StringLiteral;
    ELSIF (sym = lbrackSym) OR
          (sym = NILSym) THEN
      PointerLiteral;
    ELSE SynError(82);
    END;
  END ConstLiteral;

PROCEDURE ConstructedValue;
  BEGIN
    Expect(lbraceSym);
    IF In(symSet[1], sym) THEN
      RepStructComponent;
      WHILE (sym = commaSym) DO
        Get;
        RepStructComponent;
      END;
    END;
    Expect(rbraceSym);
  END ConstructedValue;

PROCEDURE FactorOp;
  BEGIN
    CASE sym OF
      starSym :
        Get;
        Append(" * ");
    | slashSym :
        Get;
        Append(" / ");
    | REMSym :
        Get;
        Append(" % ");
    | DIVSym :
        Get;
        Append(" / ");
    | MODSym :
        Get;
        Append(" % ");
    | andSym :
        Get;
        Append(" && ");
    | ANDSym :
        Get;
        Append(" && ");
    ELSE SynError(83);
    END;
  END FactorOp;

PROCEDURE Factor;
  BEGIN
    WHILE ~ ( In(symSet[2], sym)) DO SynError(84); Get END;
    IF (sym = lparenSym) THEN
      Get;
      Append("(");
      Expr;
      Expect(rparenSym);
      Append(")");
    ELSIF (sym = tildeSym) OR
          (sym = NOTSym) THEN
      IF (sym = tildeSym) THEN
        Get;
      ELSE
        Get;
      END;
      Append("!");
      Factor;
    ELSIF (sym = identifierSym) THEN
      Designator;
      IF (sym = lparenSym) OR
         (sym = lbraceSym) THEN
        IF (sym = lparenSym) THEN
          Append("(");
          ActualParams;
          Append(")");
        ELSE
          Append("()");
          ConstructedValue;
        END;
      END;
    ELSIF (sym = lbraceSym) THEN
      Append("BITSET()");
      ConstructedValue;
    ELSIF (sym = integerSym) OR
          (sym = realSym) OR
          (sym = stringSym) OR
          (sym = lbrackSym) OR
          (sym = NILSym) THEN
      ConstLiteral;
    ELSE SynError(85);
    END;
  END Factor;

PROCEDURE TermOp;
  BEGIN
    IF (sym = plusSym) THEN
      Get;
      Append(" + ");
    ELSIF (sym = minusSym) THEN
      Get;
      Append(" - ");
    ELSIF (sym = ORSym) THEN
      Get;
      Append(" || ");
    ELSE SynError(86);
    END;
  END TermOp;

PROCEDURE Term;
  BEGIN
    Factor;
    WHILE In(symSet[3], sym) DO
      FactorOp;
      Factor;
    END;
  END Term;

PROCEDURE RelationalOp (VAR isIN: BOOLEAN);
  BEGIN
    CASE sym OF
      equalSym :
        Get;
        isIN := FALSE; Append(" == ");
    | hashSym :
        Get;
        isIN := FALSE; Append(" != ");
    | lessgreaterSym :
        Get;
        isIN := FALSE; Append(" != ");
    | lessSym :
        Get;
        isIN := FALSE; Append(" < ");
    | greaterSym :
        Get;
        isIN := FALSE; Append(" > ");
    | lessequalSym :
        Get;
        isIN := FALSE; Append(" <= ");
    | greaterequalSym :
        Get;
        isIN := FALSE; Append(" >= ");
    | INSym :
        Get;
        isIN := TRUE;
        Prepend("IN("); Append(", ");
    ELSE SynError(87);
    END;
  END RelationalOp;

PROCEDURE SimpleExpr;
  BEGIN
    WHILE ~ ( In(symSet[4], sym)) DO SynError(88); Get END;
    IF (sym = plusSym) OR
       (sym = minusSym) THEN
      IF (sym = plusSym) THEN
        Get;
        Append(" + ");
      ELSE
        Get;
        Append(" - ");
      END;
    END;
    Term;
    WHILE (sym = plusSym) OR
          (sym = minusSym) OR
          (sym = ORSym) DO
      TermOp;
      Term;
    END;
  END SimpleExpr;

PROCEDURE IndexExpr;
  BEGIN
    OrdExpr;
  END IndexExpr;

PROCEDURE StepSize;
  BEGIN
    ConstExpr;
  END StepSize;

PROCEDURE FinalValue;
  BEGIN
    OrdExpr;
  END FinalValue;

PROCEDURE InitialValue;
  BEGIN
    OrdExpr;
  END InitialValue;

PROCEDURE CaseLabel;
  VAR notInterval: BOOLEAN;
  BEGIN
    notInterval := TRUE;
    Append("(");
    ConstExpr;
    IF (sym = pointpointSym) THEN
      Get;
      notInterval := FALSE;
      Prepend("(");
      Append(" >= ");
      Append(sel);
      Append(") && (");
      Append(sel);
      Append(" <= ");
      ConstExpr;
      Append(")");
    END;
    IF notInterval THEN
      Append(" == ");
      Append(sel);
    END;
    Append(")");
  END CaseLabel;

PROCEDURE CaseLabelList;
  BEGIN
    CaseLabel;
    WHILE (sym = commaSym) DO
      Get;
      Append(" || ");
      CaseLabel;
    END;
  END CaseLabelList;

PROCEDURE OrdExpr;
  BEGIN
    Expr;
  END OrdExpr;

PROCEDURE CaseElsePart;
  BEGIN
    Expect(ELSESym);
    Append(" else {");
    IndentNextLine;
    StatSeq;
    ExdentNextLine;
    Append("}");
  END CaseElsePart;

PROCEDURE CaseAlternative;
  BEGIN
    Append("if (");
    CaseLabelList;
    Append(") {");
    IndentNextLine;
    Expect(colonSym);
    StatSeq;
    ExdentNextLine;
    Append("}");
  END CaseAlternative;

PROCEDURE CaseSelector;
  BEGIN
    OrdExpr;
  END CaseSelector;

PROCEDURE BooleanExpr;
  BEGIN
    Expr;
  END BooleanExpr;

PROCEDURE IfElsePart;
  BEGIN
    Expect(ELSESym);
    Append(" else {");
    IndentNextLine;
    StatSeq;
    ExdentNextLine;
    Append("}");
  END IfElsePart;

PROCEDURE GuardedStats;
  BEGIN
    Expect(IFSym);
    Append("if (");
    BooleanExpr;
    Append(") {");
    IndentNextLine;
    Expect(THENSym);
    StatSeq;
    ExdentNextLine;
    Append("}");
    WHILE (sym = ELSIFSym) DO
      Get;
      Append(" else if (");
      BooleanExpr;
      Append(") {");
      IndentNextLine;
      Expect(THENSym);
      StatSeq;
      ExdentNextLine;
      Append("}");
    END;
  END GuardedStats;

PROCEDURE ForStat;
  VAR hasStep: BOOLEAN;
  BEGIN
    hasStep := FALSE;
    Expect(FORSym);
    Append("FOR(");
    Id;
    LexString(tmpId); Append(tmpId);
    Append(", ");
    Expect(colonequalSym);
    InitialValue;
    Append(", ");
    Expect(TOSym);
    FinalValue;
    Append(", ");
    IF (sym = BYSym) THEN
      Get;
      hasStep := TRUE;
      StepSize;
    END;
    IF NOT hasStep THEN Append("1") END;
    Expect(DOSym);
    Append(") {");
    IndentNextLine;
    StatSeq;
    Expect(ENDSym);
    ExdentNextLine;
    Append("}");
  END ForStat;

PROCEDURE ExitStat;
  BEGIN
    Expect(EXITSym);
    Append("break");
  END ExitStat;

PROCEDURE LoopStat;
  BEGIN
    Expect(LOOPSym);
    Append("for (;;) {");
    IndentNextLine;
    StatSeq;
    Expect(ENDSym);
    ExdentNextLine;
    Append("}");
  END LoopStat;

PROCEDURE RepeatStat;
  BEGIN
    Expect(REPEATSym);
    Append("do {");
    IndentNextLine;
    StatSeq;
    Expect(UNTILSym);
    ExdentNextLine;
    Append("} while (!(");
    BooleanExpr;
    Append("))");
  END RepeatStat;

PROCEDURE WhileStat;
  BEGIN
    Expect(WHILESym);
    Append("while (");
    BooleanExpr;
    Append(") {");
    IndentNextLine;
    Expect(DOSym);
    StatSeq;
    Expect(ENDSym);
    ExdentNextLine;
    Append("}");
  END WhileStat;

PROCEDURE CaseStat;
  BEGIN
    Expect(CASESym);
    CaseSelector;
    GetBuffer(sel);
    DelBuffer;
    Expect(OFSym);
    IF In(symSet[1], sym) THEN
      CaseAlternative;
    END;
    WHILE (sym = barSym) DO
      Get;
      IF In(symSet[1], sym) THEN
        Append(" else ");
        CaseAlternative;
      END;
    END;
    IF (sym = ELSESym) THEN
      CaseElsePart;
    END;
    Expect(ENDSym);
  END CaseStat;

PROCEDURE IfStat;
  BEGIN
    GuardedStats;
    IF (sym = ELSESym) THEN
      IfElsePart;
    END;
    Expect(ENDSym);
  END IfStat;

PROCEDURE WithStat;
  BEGIN
    Expect(WITHSym);
    Append("// WITH(");
    Designator;
    Append(") {");
    NewLine;
    Expect(DOSym);
    StatSeq;
    Expect(ENDSym);
    Append("// }; /* WITH */");
    NewLine;
  END WithStat;

PROCEDURE RetryStat;
  BEGIN
    Expect(RETRYSym);
    Append("// RETRY");
  END RetryStat;

PROCEDURE ReturnStat;
  BEGIN
    Expect(RETURNSym);
    Append("return");
    IF In(symSet[1], sym) THEN
      Append(" ");
      Expr;
    END;
  END ReturnStat;

PROCEDURE ActualParams;
  BEGIN
    Expect(lparenSym);
    IF In(symSet[1], sym) THEN
      ActualParamList;
    END;
    Expect(rparenSym);
  END ActualParams;

PROCEDURE Expr;
  VAR isIN: BOOLEAN;
  BEGIN
    MarkPrependPos;
    SimpleExpr;
    IF In(symSet[5], sym) THEN
      RelationalOp(isIN);
      SimpleExpr;
      IF isIN THEN Append(")") END;
      WHILE ~ ( In(symSet[6], sym)) DO SynError(89); Get END;
    END;
  END Expr;

PROCEDURE Designator;
  VAR doAppend: BOOLEAN;
      insertPos: CARDINAL;
  BEGIN
    doAppend := TRUE;
    GetPos(insertPos);
    Id;
    LexString(tmpId);
    WHILE (sym = pointSym) OR
          (sym = lbrackSym) OR
          (sym = uparrowSym) OR
          (sym = atSym) DO
      IF (sym = lbrackSym) THEN
        Get;
        IF doAppend THEN Append(tmpId) END;
        Append("[");
        IndexExpr;
        WHILE (sym = commaSym) DO
          Get;
          Append("][");
          IndexExpr;
        END;
        Expect(rbrackSym);
        Append("]");
        doAppend := FALSE;
      ELSIF (sym = pointSym) THEN
        Get;
        IF NOT String.Equal(tmpId, "SYSTEM") THEN
          IF doAppend THEN Append(tmpId) END;
          IF doAppend AND Import.HasModule(tmpId) THEN
              Append("::");
          ELSE
            Append(".");
          END;
        END;
        Id;
        doAppend := TRUE;
        LexString(tmpId);
      ELSE
        IF (sym = uparrowSym) THEN
          Get;
        ELSIF (sym = atSym) THEN
          Get;
        ELSE SynError(90);
        END;
        Insert("(*", insertPos);
        IF doAppend THEN Append(tmpId) END;
        Append(")");
        doAppend := FALSE;
      END;
    END;
    IF doAppend THEN Append(tmpId) END;
  END Designator;

PROCEDURE EmptyStat;
  BEGIN
  END EmptyStat;

PROCEDURE Stat;
  VAR wrSemicolon: BOOLEAN;
  BEGIN
    WHILE ~ ( In(symSet[7], sym)) DO SynError(91); Get END;
    wrSemicolon := TRUE;
    CASE sym OF
      semicolonSym, ENDSym, barSym, ELSESym, FINALLYSym, EXCEPTSym, ELSIFSym, UNTILSym :
        EmptyStat;
        wrSemicolon := FALSE;
    | identifierSym :
        Designator;
        IF (sym = colonequalSym) THEN
          Get;
          Append(" = ");
          Expr;
        ELSIF In(symSet[8], sym) THEN
          Append("(");
          IF (sym = lparenSym) THEN
            ActualParams;
          END;
          Append(")");
        ELSE SynError(92);
        END;
    | RETURNSym :
        ReturnStat;
    | RETRYSym :
        RetryStat;
    | WITHSym :
        WithStat;
        wrSemicolon := FALSE;
    | IFSym :
        IfStat;
        wrSemicolon := FALSE;
    | CASESym :
        CaseStat;
        wrSemicolon := FALSE;
    | WHILESym :
        WhileStat;
        wrSemicolon := FALSE;
    | REPEATSym :
        RepeatStat;
    | LOOPSym :
        LoopStat;
        wrSemicolon := FALSE;
    | EXITSym :
        ExitStat;
    | FORSym :
        ForStat;
        wrSemicolon := FALSE;
    ELSE SynError(93);
    END;
    IF wrSemicolon THEN Append(";") END;
    NewLine;
  END Stat;

PROCEDURE StatSeq;
  BEGIN
    Stat;
    WHILE WeakSeparator(semicolonSym, 9, 10) DO
      Stat;
    END;
  END StatSeq;

PROCEDURE FinalizationBody;
  BEGIN
    Expect(FINALLYSym);
    Append("void _ModuleBody::FINALLY() {");
    IndentNextLine;
    BlockBody;
    ExdentNextLine;
    Append("}");
    NewLine; BlankLine;
  END FinalizationBody;

PROCEDURE InitializationBody;
  BEGIN
    Expect(BEGINSym);
    Append("void _ModuleBody::BEGIN() {");
    IndentNextLine;
    BlockBody;
    ExdentNextLine;
    Append("}");
    NewLine; BlankLine;
  END InitializationBody;

PROCEDURE ModBody;
  VAR hasFINALLY: BOOLEAN;
  BEGIN
    hasFINALLY := FALSE;
    InitializationBody;
    IF (sym = FINALLYSym) THEN
      FinalizationBody;
      hasFINALLY := TRUE;
    END;
    IF NOT hasFINALLY THEN
      Append("void _ModuleBody::FINALLY() {}");
      NewLine; BlankLine
    END;
  END ModBody;

PROCEDURE BlockBody;
  BEGIN
    StatSeq;
    IF (sym = EXCEPTSym) THEN
      Get;
      Append("/* EXCEPT"); NewLine;
      StatSeq;
      Append("*/"); NewLine;
    END;
  END BlockBody;

PROCEDURE ProcBody;
  BEGIN
    Expect(BEGINSym);
    BlockBody;
  END ProcBody;

PROCEDURE VariantLabel;
  BEGIN
    ConstExpr;
    IF (sym = pointpointSym) THEN
      Get;
      Append("..");
      ConstExpr;
    END;
  END VariantLabel;

PROCEDURE VariantLabelList;
  BEGIN
    VariantLabel;
    WHILE (sym = commaSym) DO
      Get;
      Append(", ");
      VariantLabel;
    END;
  END VariantLabelList;

PROCEDURE VariantElsePart (casePath: BigStr; caseId: IdStr);
  VAR noNameCount: CARDINAL;
      vList: Variants.List;
  BEGIN
    noNameCount := 0;
    Expect(ELSESym);
    String.Append(caseId, "_ELSE");
    IF String.Length(casePath) # 0 THEN
      String.Append(casePath, ".");
    END;
    String.Append(casePath, caseId);
    Variants.Init(vList, casePath);
    Append("// ELSE"); NewLine;
    Append("struct {");
    IndentNextLine;
    IF (sym = identifierSym) OR
       (sym = CASESym) THEN
      IF (sym = identifierSym) THEN
        FixedFields(TRUE, vList);
        Append(";"); NewLine;
      ELSE
        VariantFields(casePath, noNameCount, TRUE, vList);
      END;
    END;
    WHILE (sym = semicolonSym) DO
      Get;
      IF (sym = identifierSym) OR
         (sym = CASESym) THEN
        IF (sym = identifierSym) THEN
          FixedFields(TRUE, vList);
          Append(";"); NewLine;
        ELSE
          VariantFields(casePath, noNameCount, TRUE, vList);
        END;
      END;
    END;
    ExdentNextLine;
    Append("} ");
    Append(caseId);
    Append(";");
    Append(" // "); Append(casePath);
    NewLine;
    IF NOT Variants.IsEmpty(vList) THEN
      VFields.Insert(vList);
    END;
  END VariantElsePart;

PROCEDURE Variant (casePath: BigStr; caseId: IdStr; VAR caseCount: CARDINAL);
  VAR noNameCount: CARDINAL;
      vList: Variants.List;
  BEGIN
    noNameCount := 0;
    INC(caseCount);
    AppendCardToStr(caseId, caseCount);
    IF String.Length(casePath) # 0 THEN
      String.Append(casePath, ".");
    END;
    String.Append(casePath, caseId);
    Variants.Init(vList, casePath);
    Append("// ");
    VariantLabelList;
    Expect(colonSym);
    Append(":"); NewLine;
    Append("struct {");
    IndentNextLine;
    IF (sym = identifierSym) OR
       (sym = CASESym) THEN
      IF (sym = identifierSym) THEN
        FixedFields(TRUE, vList);
        Append(";"); NewLine;
      ELSE
        VariantFields(casePath, noNameCount, TRUE, vList);
      END;
    END;
    WHILE (sym = semicolonSym) DO
      Get;
      IF (sym = identifierSym) OR
         (sym = CASESym) THEN
        IF (sym = identifierSym) THEN
          FixedFields(TRUE, vList);
          Append(";"); NewLine;
        ELSE
          VariantFields(casePath, noNameCount, TRUE, vList);
        END;
      END;
    END;
    ExdentNextLine;
    Append("} ");
    Append(caseId);
    Append(";");
    Append(" // "); Append(casePath);
    NewLine;
    IF NOT Variants.IsEmpty(vList) THEN
      VFields.Insert(vList);
    END;
  END Variant;

PROCEDURE VariantFields (casePath: BigStr; VAR noNameCount: CARDINAL;
                          inCase: BOOLEAN; VAR vList: Variants.List);
  VAR caseId: IdStr;
      caseCount: CARDINAL;
  BEGIN
    caseCount := 0;
    String.Copy(caseId, "");
    Expect(CASESym);
    IF (sym = identifierSym) THEN
      Id;
      LexString(caseId);
    END;
    Expect(colonSym);
    QualId(tmpBig);
    IF String.Length(caseId) = 0 THEN
      INC(noNameCount);
      String.Append(caseId, "noName");
      AppendCardToStr(caseId, noNameCount);
      Append("// CASE : ");
      Append(tmpBig);
      Append(" OF");
    ELSE
      Append(tmpBig);
      Append(" ");
      Append(caseId);
      Append("; // CASE OF");
      IF inCase THEN
        Variants.InsertType(vList, tmpBig);
        Variants.InsertName(vList, caseId);
      END;
    END;
    String.Insert(caseId, "_", 0);
    NewLine;
    Expect(OFSym);
    Append("union {");
    IndentNextLine;
    IF In(symSet[1], sym) THEN
      Variant(casePath, caseId, caseCount);
    END;
    WHILE (sym = barSym) DO
      Get;
      IF In(symSet[1], sym) THEN
        Variant(casePath, caseId, caseCount);
      END;
    END;
    IF (sym = ELSESym) THEN
      VariantElsePart(casePath, caseId);
    END;
    ExdentNextLine;
    Append("};"); NewLine;
    Expect(ENDSym);
  END VariantFields;

PROCEDURE FixedFields (inCase: BOOLEAN; VAR vList: Variants.List);
  VAR notProcType, isRecType: BOOLEAN;
      fieldId, fieldIdOld, singleId: IdStr;
      fq: IdQueue.T;
      typeStr: HugeStr;
  BEGIN
    IdQueue.Init(fq);
    Id;
    LexString(fieldId);
    IdQueue.AddRear(fq, fieldId);
    WHILE (sym = commaSym) DO
      Get;
      Id;
      LexString(fieldId);
      IdQueue.AddRear(fq, fieldId);
    END;
    Expect(colonSym);
    IdQueue.First(fq, fieldId);
    IdQueue.PopFirst(fq);
    TypeDenoter(notProcType, isRecType, singleId, fieldId, FALSE);
    IF notProcType THEN
      IF inCase THEN
        IF isRecType THEN
          String.Copy(typeStr, "_");
          String.Append(typeStr, fieldId);
        ELSE
          GetBuffer(typeStr);
        END;
        Variants.InsertType(vList, typeStr);
        Variants.InsertName(vList, fieldId);
      END;
      Append(" ");
      Append(fieldId);
      WHILE NOT IdQueue.IsEmpty(fq) DO
        IdQueue.First(fq, fieldId);
        Append(", ");
        Append(fieldId);
        IF inCase THEN
          Variants.InsertName(vList, fieldId);
        END;
        IdQueue.PopFirst(fq);
      END;
    ELSE
      GetBuffer(typeStr);
      IF inCase THEN
        Variants.InsertType(vList, typeStr);
        Variants.InsertName(vList, fieldId);
      END;
      WHILE NOT IdQueue.IsEmpty(fq) DO
        Append(";");
        NewLine;
        String.Copy(fieldIdOld, fieldId);
        IdQueue.First(fq, fieldId);
        Append(typeStr);
        BackTrack(fieldIdOld, fieldId);
        GetBuffer(typeStr);
        IF inCase THEN
          Variants.InsertType(vList, typeStr);
          Variants.InsertName(vList, fieldId);
        END;
        IdQueue.PopFirst(fq);
      END;
    END;
    IdQueue.Kill(fq);
  END FixedFields;

PROCEDURE FormalType;
  VAR arrayLvl, i: CARDINAL;
  BEGIN
    arrayLvl := 0;
    WHILE (sym = ARRAYSym) DO
      Get;
      Expect(OFSym);
      INC(arrayLvl);
    END;
    FOR i := 1 TO arrayLvl DO
      Append("_ARRAYOF< ");
    END;
    QualId(tmpBig);
    Append(tmpBig);
    FOR i := 1 TO arrayLvl DO
      Append(" >");
    END;
  END FormalType;

PROCEDURE FormalParamType;
  VAR isVar: BOOLEAN;
  BEGIN
    isVar := FALSE;
    IF (sym = VARSym) THEN
      Get;
      isVar := TRUE;
    END;
    FormalType;
    IF isVar THEN Append("&") END;
  END FormalParamType;

PROCEDURE FormalParamTypeList;
  BEGIN
    Expect(lparenSym);
    Append("(");
    IF (sym = identifierSym) OR
       (sym = VARSym) OR
       (sym = ARRAYSym) THEN
      FormalParamType;
      WHILE (sym = commaSym) DO
        Get;
        Append(", ");
        FormalParamType;
      END;
    END;
    Expect(rparenSym);
    Append(")");
    IF (sym = colonSym) THEN
      Get;
      QualId(retStr);
      BackTrack("void", retStr);
    END;
  END FormalParamTypeList;

PROCEDURE EnumerationType;
  BEGIN
    Expect(lparenSym);
    Append("enum { ");
    Id;
    LexString(tmpId); Append(tmpId);
    WHILE (sym = commaSym) DO
      Get;
      Append(", ");
      Id;
      LexString(tmpId); Append(tmpId);
    END;
    Expect(rparenSym);
    Append(" }");
  END EnumerationType;

PROCEDURE Subrange;
  BEGIN
    Expect(lbrackSym);
    Append("_SubrangeType< ");
    Append(tmpBig);
    Append(", ");
    ConstExpr;
    Expect(pointpointSym);
    Append(", ");
    ConstExpr;
    Expect(rbrackSym);
    Append(" >");
  END Subrange;

PROCEDURE RecordType (id: IdStr);
  VAR noNameCount, pos: CARDINAL;
      typeStr: HugeStr;
      fieldId: IdStr;
      vList: Variants.List;
      casePath: BigStr;
      notFirst: BOOLEAN;
  BEGIN
    noNameCount := 0;
    VFields.Init;
    Variants.Init(vList, "");
    Expect(RECORDSym);
    Append("struct ");
    IF String.Length(id) # 0 THEN
      Append("_"); Append(id); Append(" ");
    END;
    Append("{"); IndentNextLine;
    IF (sym = identifierSym) OR
       (sym = CASESym) THEN
      IF (sym = identifierSym) THEN
        FixedFields(FALSE, vList);
        Append(";"); NewLine;
      ELSE
        VariantFields("", noNameCount, FALSE, vList);
      END;
    END;
    WHILE (sym = semicolonSym) DO
      Get;
      IF (sym = identifierSym) OR
         (sym = CASESym) THEN
        IF (sym = identifierSym) THEN
          FixedFields(FALSE, vList);
          Append(";"); NewLine;
        ELSE
          VariantFields("", noNameCount, FALSE, vList);
        END;
      END;
    END;
    Expect(ENDSym);
    IF NOT VFields.IsEmpty() THEN
      VFields.GetNext(vList);
      WHILE NOT Variants.IsEmpty(vList) DO
        Variants.GetNextType(vList, typeStr);
        WHILE String.Length(typeStr) # 0 DO
          NewLine;
          Append(typeStr);
          Variants.GetNextName(vList, fieldId);
          IF String.SubString(typeStr, "(*", pos) THEN
            BackTrack("*", "*&");
            Variants.GetNextName(vList, fieldId);
          ELSE
            Append(" &");
            Append(fieldId);
            Variants.GetNextName(vList, fieldId);
            WHILE String.Length(fieldId) # 0 DO
              Append(", &");
              Append(fieldId);
              Variants.GetNextName(vList, fieldId);
            END;
          END;
          Append(";");
          Variants.GetNextType(vList, typeStr);
        END;
        VFields.GetNext(vList);
      END;
      NewLine;
      Append("_");
      Append(id);
      Append("():"); IndentNextLine;
      notFirst := FALSE;
      VFields.GetNext(vList);
      WHILE NOT Variants.IsEmpty(vList) DO
        Variants.GetCasePath(vList, casePath);
        Variants.GetNextType(vList, typeStr);
        WHILE String.Length(typeStr) # 0 DO
          Variants.GetNextName(vList, fieldId);
          IF notFirst THEN
            Append(", "); NewLine;
          ELSE
            notFirst := TRUE;
          END;
          Append(fieldId);
          Append("(");
          Append(casePath); Append("."); Append(fieldId);
          Append(")");
          Variants.GetNextName(vList, fieldId);
          WHILE String.Length(fieldId) # 0 DO
            Append(", "); NewLine;
            Append(fieldId);
            Append("(");
            Append(casePath); Append("."); Append(fieldId);
            Append(")");
            Variants.GetNextName(vList, fieldId);
          END;
          Variants.GetNextType(vList, typeStr);
        END;
        VFields.GetNext(vList);
      END;
      NewLine;
      Append("{}");
      ExdentNextLine;
    END;
    ExdentNextLine;
    Append("}");
    VFields.Kill;
  END RecordType;

PROCEDURE ArrayType;
  VAR indexCount, i: CARDINAL;
      notProcType, isRecType: BOOLEAN;
  BEGIN
    indexCount := 1;
    Expect(ARRAYSym);
    Append("ARRAY< ");
    OrdTypeDenoter(tmpId);
    WHILE (sym = commaSym) DO
      Get;
      Append(", ARRAY< ");
      OrdTypeDenoter(tmpId);
      INC(indexCount);
    END;
    Expect(OFSym);
    Append(", ");
    TypeDenoter(notProcType, isRecType, tmpId, "", FALSE);
    FOR i := 1 TO indexCount DO
      Append(" >");
    END;
  END ArrayType;

PROCEDURE ProcType (id: IdStr);
  BEGIN
    Expect(PROCEDURESym);
    Append("void (*");
    Append(id);
    Append(")");
    IF (sym = lparenSym) THEN
      FormalParamTypeList;
    END;
  END ProcType;

PROCEDURE PointerType (wrTypedef: BOOLEAN);
  VAR notProcType, isRecType: BOOLEAN;
      singleId: IdStr;
  BEGIN
    Expect(POINTERSym);
    Expect(TOSym);
    IF wrTypedef THEN Append("typedef ") END;
    Append("POINTER< ");
    TypeDenoter(notProcType, isRecType, singleId, "", FALSE);
    Append(" >");
    IF wrTypedef AND
       (String.Length(singleId) # 0) AND
       NOT Type.IsDefined(singleId)
    THEN
      DelBuffer;
      Append("struct _");
      Append(singleId);
      Append(";"); NewLine;
      Append("typedef POINTER< _");
      Append(singleId);
      Append(" >");
    END;
  END PointerType;

PROCEDURE PackedsetType;
  BEGIN
    Expect(PACKEDSETSym);
    Expect(OFSym);
    Append("PACKEDSET< ");
    OrdTypeDenoter(tmpId);
    Append(" >");
  END PackedsetType;

PROCEDURE SetType;
  BEGIN
    Expect(SETSym);
    Expect(OFSym);
    Append("SET< ");
    OrdTypeDenoter(tmpId);
    Append(" >");
  END SetType;

PROCEDURE OrdTypeDenoter (VAR singleId: IdStr);
  VAR notSubrange: BOOLEAN;
      pos: CARDINAL;
  BEGIN
    IF (sym = identifierSym) THEN
      notSubrange := TRUE;
      QualId(tmpBig);
      IF (sym = lbrackSym) THEN
        Subrange;
        notSubrange := FALSE;
      END;
      IF notSubrange THEN
        IF NOT String.SubString(tmpBig, ".", pos) THEN
          String.Copy(singleId, tmpBig);
        END;
        Append(tmpBig);
      END;
    ELSIF (sym = lbrackSym) THEN
      String.Copy(tmpBig, "INTEGER");
      Subrange;
    ELSIF (sym = lparenSym) THEN
      EnumerationType;
    ELSE SynError(94);
    END;
  END OrdTypeDenoter;

PROCEDURE FuncProcBlock (VAR procDesc: Procs.ProcDesc);
  VAR emptyEList: Ids.List;
  BEGIN
    Ids.Init(emptyEList);
    Append(" {");
    IndentNextLine;
    WriteParamReferences(procDesc);
    BlankLine;
    WHILE (sym = MODULESym) OR
          (sym = CONSTSym) OR
          (sym = TYPESym) OR
          (sym = VARSym) OR
          (sym = PROCEDURESym) DO
      Decl(emptyEList);
    END;
    ProcBody;
    Expect(ENDSym);
    ExdentNextLine;
    Append("}");
  END FuncProcBlock;

PROCEDURE ProperProcBlock (VAR procDesc: Procs.ProcDesc);
  VAR emptyEList: Ids.List;
  BEGIN
    Ids.Init(emptyEList);
    Append(" {");
    IndentNextLine;
    WriteParamReferences(procDesc);
    BlankLine;
    WHILE (sym = MODULESym) OR
          (sym = CONSTSym) OR
          (sym = TYPESym) OR
          (sym = VARSym) OR
          (sym = PROCEDURESym) DO
      Decl(emptyEList);
    END;
    IF (sym = BEGINSym) THEN
      ProcBody;
    END;
    Expect(ENDSym);
    ExdentNextLine;
    Append("}");
  END ProperProcBlock;

PROCEDURE FuncProc2 (VAR procDesc: Procs.ProcDesc);
  BEGIN
    Expect(colonSym);
    QualId(retStr);
    Expect(semicolonSym);
    IF Procs.level = 1 THEN
      WriteTemplateParams(procDesc);
      Append(retStr); Append(" ");
      Append(procName);
      Append("(");
      AppendParams(procDesc);
      Append(")")
    ELSE
      Append("static struct _");
      Append(procName);
      Append(" {");
      IndentNextLine;
      Append(retStr);
      Append(" operator()(");
      AppendParams(procDesc);
      Append(")")
    END;
    IF In(symSet[11], sym) THEN
      FuncProcBlock(procDesc);
      IF Procs.level # 1 THEN
        ExdentNextLine;
        Append("} ");
        Append(procName);
        Append(";");
      END;
      Id;
    ELSIF (sym = FORWARDSym) THEN
      Get;
      Append(";");
    ELSE SynError(95);
    END;
  END FuncProc2;

PROCEDURE ProperProc2 (VAR procDesc: Procs.ProcDesc);
  BEGIN
    Expect(semicolonSym);
    IF Procs.level = 1 THEN
      WriteTemplateParams(procDesc);
      Append(retStr); Append(" ");
      Append(procName);
      Append("(");
      AppendParams(procDesc);
      Append(")")
    ELSE
      Append("static struct _");
      Append(procName);
      Append(" {");
      IndentNextLine;
      Append(retStr);
      Append(" operator()(");
      AppendParams(procDesc);
      Append(")")
    END;
    IF In(symSet[12], sym) THEN
      ProperProcBlock(procDesc);
      IF Procs.level # 1 THEN
         ExdentNextLine;
         Append("} ");
         Append(procName);
         Append(";");
      END;
      Id;
    ELSIF (sym = FORWARDSym) THEN
      Get;
      Append(";");
    ELSE SynError(96);
    END;
  END ProperProc2;

PROCEDURE FormalParams2 (VAR procDesc: Procs.ProcDesc);
  BEGIN
    IF (sym = lparenSym) THEN
      Get;
      IF (sym = identifierSym) OR
         (sym = VARSym) THEN
        FormalParamList(procDesc);
      END;
      Expect(rparenSym);
      IF (sym = semicolonSym) THEN
        ProperProc2(procDesc);
      ELSIF (sym = colonSym) THEN
        FuncProc2(procDesc);
      ELSE SynError(97);
      END;
    ELSIF (sym = semicolonSym) THEN
      ProperProc2(procDesc);
    ELSE SynError(98);
    END;
  END FormalParams2;

PROCEDURE ValueOfAddressType;
  BEGIN
    ConstExpr;
    IF (sym = colonSym) THEN
      Get;
      ConstExpr;
    END;
  END ValueOfAddressType;

PROCEDURE MachineAddress;
  BEGIN
    Expect(lbrackSym);
    ValueOfAddressType;
    Expect(rbrackSym);
  END MachineAddress;

PROCEDURE LocalModDecl (VAR prevEList: Ids.List);
  VAR LocModName: IdStr;
      eList: Ids.List;
  BEGIN
    Ids.Init(eList);
    Expect(MODULESym);
    Append("namespace ");
    Id;
    LexString(LocModName);
    Append(LocModName);
    Append(" {");
    BlankLine;
    IndentNextLine;
    IF (sym = lbrackSym) THEN
      Prot;
    END;
    Expect(semicolonSym);
    Import.Init;
    WHILE (sym = IMPORTSym) OR
          (sym = FROMSym) DO
      ImportList;
    END;
    WriteImportUsings;
    IF (sym = EXPORTSym) THEN
      ExportList(eList);
    END;
    ModBlock(LocModName, eList);
    Ids.Replace(prevEList, LocModName, eList);
    ExdentNextLine;
    Id;
    Append("}"); NewLine;
    WriteExportUsings(LocModName, eList);
    Ids.Kill(eList);
    Import.Kill;
  END LocalModDecl;

PROCEDURE ProcDecl;
  VAR procDesc: Procs.ProcDesc;
  BEGIN
    Procs.Init(procDesc);
    Type.InitProc;
    INC(Procs.level);
    Expect(PROCEDURESym);
    String.Copy(retStr, "void");
    Id;
    LexString(procName);
    FormalParams2(procDesc);
    DEC(Procs.level);
    Procs.Kill(procDesc);
    Type.KillProc;
  END ProcDecl;

PROCEDURE TypeDecl;
  VAR notProcType, isRecType: BOOLEAN;
      typeId, singleId: IdStr;
  BEGIN
    Id;
    LexString(typeId);
    Expect(equalSym);
    TypeDenoter(notProcType, isRecType, singleId, typeId, TRUE);
    IF notProcType THEN
      Append(" ");
      Append(typeId);
    END;
    Type.Define(typeId);
  END TypeDecl;

PROCEDURE Decl (VAR eList: Ids.List);
  BEGIN
    IF (sym = CONSTSym) THEN
      Get;
      WHILE (sym = identifierSym) DO
        ConstDecl;
        Expect(semicolonSym);
        WHILE ~ ( In(symSet[13], sym)) DO SynError(99); Get END;
        Append(";"); NewLine;
      END;
      BlankLine;
    ELSIF (sym = TYPESym) THEN
      Get;
      WHILE (sym = identifierSym) DO
        TypeDecl;
        Expect(semicolonSym);
        WHILE ~ ( In(symSet[13], sym)) DO SynError(100); Get END;
        Append(";"); NewLine;
      END;
      BlankLine;
    ELSIF (sym = VARSym) THEN
      Get;
      WHILE (sym = identifierSym) DO
        VarDecl;
        Expect(semicolonSym);
        WHILE ~ ( In(symSet[13], sym)) DO SynError(101); Get END;
        Append(";"); NewLine;
      END;
      BlankLine;
    ELSIF (sym = PROCEDURESym) THEN
      ProcDecl;
      Expect(semicolonSym);
      WHILE ~ ( In(symSet[14], sym)) DO SynError(102); Get END;
      BlankLine; NewLine;
    ELSIF (sym = MODULESym) THEN
      LocalModDecl(eList);
      Expect(semicolonSym);
      WHILE ~ ( In(symSet[14], sym)) DO SynError(103); Get END;
      BlankLine; NewLine;
    ELSE SynError(104);
    END;
  END Decl;

PROCEDURE TypeDenoter (VAR notProcType, isRecType: BOOLEAN; VAR singleId: IdStr;
                            id: IdStr; wrTypedef: BOOLEAN);
  BEGIN
    String.Copy(singleId, "");
    CASE sym OF
      identifierSym, lbrackSym, lparenSym :
        IF wrTypedef THEN Append("typedef ") END;
        OrdTypeDenoter(singleId);
        notProcType := TRUE; isRecType := FALSE;
    | SETSym :
        IF wrTypedef THEN Append("typedef ") END;
        SetType;
        notProcType := TRUE; isRecType := FALSE;
    | PACKEDSETSym :
        IF wrTypedef THEN Append("typedef ") END;
        PackedsetType;
        notProcType := TRUE; isRecType := FALSE;
    | POINTERSym :
        PointerType(wrTypedef);
        notProcType := TRUE; isRecType := FALSE;
    | PROCEDURESym :
        IF wrTypedef THEN Append("typedef ") END;
        ProcType(id);
        notProcType := FALSE; isRecType := FALSE;
    | ARRAYSym :
        IF wrTypedef THEN Append("typedef ") END;
        ArrayType;
        notProcType := TRUE; isRecType := FALSE;
    | RECORDSym :
        IF wrTypedef THEN Append("typedef ") END;
        RecordType(id);
        notProcType := TRUE; isRecType := TRUE;
    ELSE SynError(105);
    END;
  END TypeDenoter;

PROCEDURE VarParamSpec (VAR procDesc: Procs.ProcDesc);
  VAR arrayLvl: CARDINAL;
  BEGIN
    arrayLvl := 0; tmpBig := "";
    Expect(VARSym);
    Id;
    LexString(tmpId);
    WHILE (sym = commaSym) DO
      Get;
      Procs.AddParam(procDesc, tmpId, tmpBig, 0, TRUE);
      Id;
      LexString(tmpId);
    END;
    Expect(colonSym);
    WHILE (sym = ARRAYSym) DO
      Get;
      Expect(OFSym);
      INC(arrayLvl);
    END;
    QualId(tmpBig);
    Procs.AddParam(procDesc, tmpId, tmpBig, arrayLvl, TRUE);
  END VarParamSpec;

PROCEDURE ValueParamSpec (VAR procDesc: Procs.ProcDesc);
  VAR arrayLvl: CARDINAL;
  BEGIN
    arrayLvl := 0; tmpBig := "";
    Id;
    LexString(tmpId);
    WHILE (sym = commaSym) DO
      Get;
      Procs.AddParam(procDesc, tmpId, tmpBig, 0, FALSE);
      Id;
      LexString(tmpId);
    END;
    Expect(colonSym);
    WHILE (sym = ARRAYSym) DO
      Get;
      Expect(OFSym);
      INC(arrayLvl);
    END;
    QualId(tmpBig);
    Procs.AddParam(procDesc, tmpId, tmpBig, arrayLvl, FALSE);
  END ValueParamSpec;

PROCEDURE FormalParam (VAR procDesc: Procs.ProcDesc);
  BEGIN
    IF (sym = identifierSym) THEN
      ValueParamSpec(procDesc);
    ELSIF (sym = VARSym) THEN
      VarParamSpec(procDesc);
    ELSE SynError(106);
    END;
  END FormalParam;

PROCEDURE FormalParamList (VAR procDesc: Procs.ProcDesc);
  BEGIN
    FormalParam(procDesc);
    WHILE (sym = semicolonSym) DO
      Get;
      FormalParam(procDesc);
    END;
  END FormalParamList;

PROCEDURE FormalParams (VAR procDesc: Procs.ProcDesc);
  BEGIN
    Expect(lparenSym);
    IF (sym = identifierSym) OR
       (sym = VARSym) THEN
      FormalParamList(procDesc);
    END;
    Expect(rparenSym);
    IF (sym = colonSym) THEN
      Get;
      QualId(retStr);
    END;
  END FormalParams;

PROCEDURE ProcHeading;
  VAR procDesc: Procs.ProcDesc;
  BEGIN
    Procs.Init(procDesc);
    INC(Procs.level);
    Expect(PROCEDURESym);
    String.Copy(retStr, "void");
    Id;
    LexString(procName);;
    IF (sym = lparenSym) THEN
      FormalParams(procDesc);
    END;
    WriteTemplateParams(procDesc);
    Append(retStr); Append(" ");
    Append(procName);
    Append("(");
    AppendParams(procDesc);
    Append(")");
    DEC(Procs.level);
    Procs.Kill(procDesc);
  END ProcHeading;

PROCEDURE VarDecl;
  VAR notProcType, isRecType: BOOLEAN;
      varId, varIdOld, singleId: IdStr;
      vq: IdQueue.T;
      procStr: HugeStr;
  BEGIN
    IdQueue.Init(vq);
    Id;
    LexString(varId);
    IdQueue.AddRear(vq, varId);
    IF (sym = lbrackSym) THEN
      MachineAddress;
    END;
    WHILE (sym = commaSym) DO
      Get;
      Id;
      LexString(varId);
      IdQueue.AddRear(vq, varId);
      IF (sym = lbrackSym) THEN
        MachineAddress;
      END;
    END;
    Expect(colonSym);
    IdQueue.First(vq, varId);
    IdQueue.PopFirst(vq);
    TypeDenoter(notProcType, isRecType, singleId, varId, FALSE);
    IF notProcType THEN
      Append(" ");
      Append(varId);
      WHILE NOT IdQueue.IsEmpty(vq) DO
        IdQueue.First(vq, varId);
        Append(", ");
        Append(varId);
        IdQueue.PopFirst(vq);
      END;
    ELSE
      GetBuffer(procStr);
      WHILE NOT IdQueue.IsEmpty(vq) DO
        Append(";");
        NewLine;
        Append(procStr);
        String.Copy(varIdOld, varId);
        IdQueue.First(vq, varId);
        BackTrack(varIdOld, varId);
        IdQueue.PopFirst(vq);
      END;
    END;
    IdQueue.Kill(vq);
  END VarDecl;

PROCEDURE TypeDef;
  VAR notProcType,
      isRecType,
      isOpaque: BOOLEAN;
      typeId, singleId: IdStr;
  BEGIN
    isOpaque := TRUE;
    Id;
    LexString(typeId);
    IF (sym = equalSym) THEN
      Get;
      isOpaque := FALSE;
      TypeDenoter(notProcType, isRecType, singleId, typeId, TRUE);
    END;
    IF notProcType THEN
      Append(" ");
      Append(typeId);
    END;
    IF isOpaque THEN
      Append("// typedef ");
      Append(typeId);
    END;
    Type.Define(typeId);
  END TypeDef;

PROCEDURE ConstDecl;
  BEGIN
    Id;
    LexString(tmpId);
    Append("const INTEGER ");
    Append(tmpId);;
    Expect(equalSym);
    Append(" = ");
    ConstExpr;
  END ConstDecl;

PROCEDURE QualId (VAR str: BigStr);
  VAR tmpId: IdStr;
  BEGIN
    String.Copy(str, "");
    Id;
    LexString(tmpId);
    WHILE (sym = pointSym) DO
      Get;
      IF NOT String.Equal(tmpId, "SYSTEM") THEN
        String.Append(str, tmpId);
        String.Append(str, "::");
      END;
      Id;
      LexString(tmpId);
    END;
    String.Append(str, tmpId);
  END QualId;

PROCEDURE QualExport;
  BEGIN
    Expect(QUALIFIEDSym);
    Id;
    WHILE (sym = commaSym) DO
      Get;
      Id;
    END;
    Expect(semicolonSym);
  END QualExport;

PROCEDURE UnqualExport (VAR eList: Ids.List);
  BEGIN
    Id;
    LexString(tmpId);
    Ids.Insert(eList, tmpId);
    WHILE (sym = commaSym) DO
      Get;
      Id;
      LexString(tmpId);
      Ids.Insert(eList, tmpId);
    END;
    Expect(semicolonSym);
  END UnqualExport;

PROCEDURE ExportList (VAR eList: Ids.List);
  BEGIN
    Expect(EXPORTSym);
    IF (sym = identifierSym) THEN
      UnqualExport(eList);
    ELSIF (sym = QUALIFIEDSym) THEN
      QualExport;
    ELSE SynError(107);
    END;
  END ExportList;

PROCEDURE UnqualImport;
  VAR notSYSTEM: BOOLEAN;
  BEGIN
    Expect(FROMSym);
    Id;
    LexString(tmpId);
    notSYSTEM := NOT String.Equal(tmpId, "SYSTEM");
    IF notSYSTEM THEN
      Import.AddModule(tmpId);
    END;
    Expect(IMPORTSym);
    Id;
    IF notSYSTEM THEN
      LexString(tmpId);
      Import.AddImported(tmpId);
      Type.Define(tmpId);
    END;
    WHILE (sym = commaSym) DO
      Get;
      Id;
      IF notSYSTEM THEN
        LexString(tmpId);
        Import.AddImported(tmpId);
        Type.Define(tmpId);
      END;
    END;
    Expect(semicolonSym);
  END UnqualImport;

PROCEDURE SimpleImport;
  BEGIN
    Expect(IMPORTSym);
    Id;
    LexString(tmpId);
    IF NOT String.Equal(tmpId, "SYSTEM") THEN
      Import.AddModule(tmpId);
    END;
    WHILE (sym = commaSym) DO
      Get;
      Id;
      LexString(tmpId);
      IF NOT String.Equal(tmpId, "SYSTEM") THEN
        Import.AddModule(tmpId);
      END;
    END;
    Expect(semicolonSym);
  END SimpleImport;

PROCEDURE Def;
  BEGIN
    IF (sym = CONSTSym) THEN
      Get;
      WHILE (sym = identifierSym) DO
        ConstDecl;
        Expect(semicolonSym);
        WHILE ~ ( In(symSet[15], sym)) DO SynError(108); Get END;
        Append(";"); NewLine;
      END;
      BlankLine;
    ELSIF (sym = TYPESym) THEN
      Get;
      WHILE (sym = identifierSym) DO
        TypeDef;
        Expect(semicolonSym);
        WHILE ~ ( In(symSet[15], sym)) DO SynError(109); Get END;
        Append(";"); NewLine;
      END;
      BlankLine;
    ELSIF (sym = VARSym) THEN
      Get;
      WHILE (sym = identifierSym) DO
        VarDecl;
        Expect(semicolonSym);
        WHILE ~ ( In(symSet[15], sym)) DO SynError(110); Get END;
        Append(";"); NewLine;
      END;
      BlankLine;
    ELSIF (sym = PROCEDURESym) THEN
      ProcHeading;
      Expect(semicolonSym);
      WHILE ~ ( In(symSet[16], sym)) DO SynError(111); Get END;
      Append(";"); BlankLine; NewLine;
    ELSE SynError(112);
    END;
  END Def;

PROCEDURE ConstExpr;
  BEGIN
    Expr;
  END ConstExpr;

PROCEDURE ProtExpr;
  BEGIN
    ConstExpr;
  END ProtExpr;

PROCEDURE ModBlock (modName: IdStr; eList: Ids.List);
  BEGIN
    WHILE (sym = MODULESym) OR
          (sym = CONSTSym) OR
          (sym = TYPESym) OR
          (sym = VARSym) OR
          (sym = PROCEDURESym) DO
      Decl(eList);
    END;
    IF (sym = BEGINSym) THEN
      WriteModuleBodyStruct;
      ModBody;
      IF isImplMod THEN WriteModuleBodyVar END;
    END;
    Expect(ENDSym);
  END ModBlock;

PROCEDURE ImportList;
  BEGIN
    IF (sym = IMPORTSym) THEN
      SimpleImport;
    ELSIF (sym = FROMSym) THEN
      UnqualImport;
    ELSE SynError(113);
    END;
  END ImportList;

PROCEDURE Prot;
  BEGIN
    Expect(lbrackSym);
    Append("// Module priority: ");;
    ProtExpr;
    Expect(rbrackSym);
    NewLine; BlankLine;
  END Prot;

PROCEDURE Id;
  BEGIN
    Expect(identifierSym);
  END Id;

PROCEDURE ImplMod;
  VAR emptyEList: Ids.List;
  BEGIN
    Ids.Init(emptyEList);
    Expect(IMPLEMENTATIONSym);
    Expect(MODULESym);
    Id;
    LexString(ModName);
    OpenResults(ModName, "cpp");
    WriteIfDefs(ModName, "cpp");
    Append("#include <_m2sys.h>");
    NewLine; BlankLine;
    Append("#include <");
    Append(ModName);
    Append(".m2h>");
    NewLine; BlankLine;
    IF (sym = lbrackSym) THEN
      Prot;
    END;
    Expect(semicolonSym);
    Import.Init;
    Type.InitMod;
    WHILE (sym = IMPORTSym) OR
          (sym = FROMSym) DO
      ImportList;
    END;
    WriteIncludes;
    Append("namespace ");
    Append(ModName);
    Append(" {");
    BlankLine;
    IndentNextLine;
    WriteImportUsings;
    ModBlock(ModName, emptyEList);
    ExdentNextLine;
    Id;
    Expect(pointSym);
    Append("}"); NewLine; BlankLine;
    Append("#endif"); NewLine;
    Import.Kill;
    Type.KillMod;
  END ImplMod;

PROCEDURE DefMod;
  BEGIN
    Expect(DEFINITIONSym);
    Expect(MODULESym);
    Id;
    LexString(ModName);
    OpenResults(ModName, "m2h");
    WriteIfDefs(ModName, "m2h");
    Append("#include <_m2sys.h>");
    NewLine; BlankLine;
    Expect(semicolonSym);
    Import.Init;
    Type.InitMod;
    WHILE (sym = IMPORTSym) OR
          (sym = FROMSym) DO
      ImportList;
    END;
    WriteIncludes;
    Append("namespace ");
    Append(ModName);
    Append(" {");
    BlankLine;
    IndentNextLine;
    WriteImportUsings;
    WHILE (sym = CONSTSym) OR
          (sym = TYPESym) OR
          (sym = VARSym) OR
          (sym = PROCEDURESym) DO
      Def;
    END;
    Expect(ENDSym);
    Id;
    Expect(pointSym);
    ExdentNextLine;
    Append("}"); NewLine; BlankLine;
    Append("#endif"); NewLine;
    Import.Kill;
    Type.KillMod;
  END DefMod;

PROCEDURE ProgMod;
  VAR emptyEList: Ids.List;
  BEGIN
    Ids.Init(emptyEList);
    Expect(MODULESym);
    Id;
    LexString(ModName);
    OpenResults(ModName, "cpp");
    Append("#include <_m2sys.h>");
    NewLine; BlankLine;
    Append("#include <Env.m2h>"); NewLine;
    Append("#include <Env.cpp>"); NewLine;
    BlankLine;
    IF (sym = lbrackSym) THEN
      Prot;
    END;
    Expect(semicolonSym);
    Import.Init;
    Type.InitMod;
    WHILE (sym = IMPORTSym) OR
          (sym = FROMSym) DO
      ImportList;
    END;
    WriteIncludes;
    Append("namespace ");
    Append(ModName);
    Append(" {");
    IndentNextLine;
    BlankLine;
    WriteImportUsings;
    ModBlock(ModName, emptyEList);
    ExdentNextLine;
    Id;
    Expect(pointSym);
    Append("}");
    NewLine;
    WriteMain(ModName);
    Import.Kill;
    Type.KillMod;
  END ProgMod;

PROCEDURE C2;
  BEGIN
    isImplMod := FALSE;
    IF (sym = MODULESym) THEN
      ProgMod;
    ELSIF (sym = DEFINITIONSym) THEN
      DefMod;
    ELSIF (sym = IMPLEMENTATIONSym) THEN
      isImplMod := TRUE;
      ImplMod;
    ELSE SynError(114);
    END;
    Type.Kill;
  END C2;



PROCEDURE Parse;
  BEGIN
    C2S.Reset; Get;
    C2;

  END Parse;

BEGIN
  errDist := minErrDist;
  symSet[ 0, 0] := BITSET{EOFSYM, identifierSym, integerSym, realSym, stringSym, 
                    MODULESym, semicolonSym, lbrackSym, rbrackSym, ENDSym, 
                    commaSym};
  symSet[ 0, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16, 
                    lparenSym-16, rparenSym-16, colonSym-16, OFSym-16, 
                    pointpointSym-16};
  symSet[ 0, 2] := BITSET{TOSym-32, CASESym-32, barSym-32, ELSESym-32, BEGINSym-32, 
                    FINALLYSym-32, EXCEPTSym-32, RETURNSym-32, RETRYSym-32, 
                    WITHSym-32, DOSym-32, IFSym-32, THENSym-32};
  symSet[ 0, 3] := BITSET{ELSIFSym-48, WHILESym-48, REPEATSym-48, UNTILSym-48, 
                    LOOPSym-48, EXITSym-48, FORSym-48, BYSym-48, plusSym-48, 
                    minusSym-48, tildeSym-48, NOTSym-48};
  symSet[ 0, 4] := BITSET{lbraceSym-64, rbraceSym-64, NILSym-64};
  symSet[ 0, 5] := BITSET{};
  symSet[ 1, 0] := BITSET{identifierSym, integerSym, realSym, stringSym, lbrackSym};
  symSet[ 1, 1] := BITSET{lparenSym-16};
  symSet[ 1, 2] := BITSET{};
  symSet[ 1, 3] := BITSET{plusSym-48, minusSym-48, tildeSym-48, NOTSym-48};
  symSet[ 1, 4] := BITSET{lbraceSym-64, NILSym-64};
  symSet[ 1, 5] := BITSET{};
  symSet[ 2, 0] := BITSET{EOFSYM, identifierSym, integerSym, realSym, stringSym, 
                    lbrackSym};
  symSet[ 2, 1] := BITSET{lparenSym-16};
  symSet[ 2, 2] := BITSET{};
  symSet[ 2, 3] := BITSET{tildeSym-48, NOTSym-48};
  symSet[ 2, 4] := BITSET{lbraceSym-64, NILSym-64};
  symSet[ 2, 5] := BITSET{};
  symSet[ 3, 0] := BITSET{};
  symSet[ 3, 1] := BITSET{};
  symSet[ 3, 2] := BITSET{};
  symSet[ 3, 3] := BITSET{};
  symSet[ 3, 4] := BITSET{starSym-64, slashSym-64, REMSym-64, DIVSym-64, MODSym-64, 
                    andSym-64, ANDSym-64};
  symSet[ 3, 5] := BITSET{};
  symSet[ 4, 0] := BITSET{EOFSYM, identifierSym, integerSym, realSym, stringSym, 
                    lbrackSym};
  symSet[ 4, 1] := BITSET{lparenSym-16};
  symSet[ 4, 2] := BITSET{};
  symSet[ 4, 3] := BITSET{plusSym-48, minusSym-48, tildeSym-48, NOTSym-48};
  symSet[ 4, 4] := BITSET{lbraceSym-64, NILSym-64};
  symSet[ 4, 5] := BITSET{};
  symSet[ 5, 0] := BITSET{};
  symSet[ 5, 1] := BITSET{equalSym-16};
  symSet[ 5, 2] := BITSET{};
  symSet[ 5, 3] := BITSET{hashSym-48, lessgreaterSym-48};
  symSet[ 5, 4] := BITSET{lessSym-64, greaterSym-64, lessequalSym-64, 
                    greaterequalSym-64, INSym-64};
  symSet[ 5, 5] := BITSET{};
  symSet[ 6, 0] := BITSET{EOFSYM, semicolonSym, rbrackSym, ENDSym, commaSym};
  symSet[ 6, 1] := BITSET{rparenSym-16, colonSym-16, OFSym-16, pointpointSym-16};
  symSet[ 6, 2] := BITSET{TOSym-32, barSym-32, ELSESym-32, FINALLYSym-32, 
                    EXCEPTSym-32, DOSym-32, THENSym-32};
  symSet[ 6, 3] := BITSET{ELSIFSym-48, UNTILSym-48, BYSym-48};
  symSet[ 6, 4] := BITSET{rbraceSym-64};
  symSet[ 6, 5] := BITSET{};
  symSet[ 7, 0] := BITSET{EOFSYM, identifierSym, semicolonSym, ENDSym};
  symSet[ 7, 1] := BITSET{};
  symSet[ 7, 2] := BITSET{CASESym-32, barSym-32, ELSESym-32, FINALLYSym-32, 
                    EXCEPTSym-32, RETURNSym-32, RETRYSym-32, WITHSym-32, 
                    IFSym-32};
  symSet[ 7, 3] := BITSET{ELSIFSym-48, WHILESym-48, REPEATSym-48, UNTILSym-48, 
                    LOOPSym-48, EXITSym-48, FORSym-48};
  symSet[ 7, 4] := BITSET{};
  symSet[ 7, 5] := BITSET{};
  symSet[ 8, 0] := BITSET{semicolonSym, ENDSym};
  symSet[ 8, 1] := BITSET{lparenSym-16};
  symSet[ 8, 2] := BITSET{barSym-32, ELSESym-32, FINALLYSym-32, EXCEPTSym-32};
  symSet[ 8, 3] := BITSET{ELSIFSym-48, UNTILSym-48};
  symSet[ 8, 4] := BITSET{};
  symSet[ 8, 5] := BITSET{};
  symSet[ 9, 0] := BITSET{identifierSym, semicolonSym, ENDSym};
  symSet[ 9, 1] := BITSET{};
  symSet[ 9, 2] := BITSET{CASESym-32, barSym-32, ELSESym-32, FINALLYSym-32, 
                    EXCEPTSym-32, RETURNSym-32, RETRYSym-32, WITHSym-32, 
                    IFSym-32};
  symSet[ 9, 3] := BITSET{ELSIFSym-48, WHILESym-48, REPEATSym-48, UNTILSym-48, 
                    LOOPSym-48, EXITSym-48, FORSym-48};
  symSet[ 9, 4] := BITSET{};
  symSet[ 9, 5] := BITSET{};
  symSet[10, 0] := BITSET{ENDSym};
  symSet[10, 1] := BITSET{};
  symSet[10, 2] := BITSET{barSym-32, ELSESym-32, FINALLYSym-32, EXCEPTSym-32};
  symSet[10, 3] := BITSET{ELSIFSym-48, UNTILSym-48};
  symSet[10, 4] := BITSET{};
  symSet[10, 5] := BITSET{};
  symSet[11, 0] := BITSET{MODULESym};
  symSet[11, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16};
  symSet[11, 2] := BITSET{BEGINSym-32};
  symSet[11, 3] := BITSET{};
  symSet[11, 4] := BITSET{};
  symSet[11, 5] := BITSET{};
  symSet[12, 0] := BITSET{MODULESym, ENDSym};
  symSet[12, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16};
  symSet[12, 2] := BITSET{BEGINSym-32};
  symSet[12, 3] := BITSET{};
  symSet[12, 4] := BITSET{};
  symSet[12, 5] := BITSET{};
  symSet[13, 0] := BITSET{EOFSYM, identifierSym, MODULESym, ENDSym};
  symSet[13, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16};
  symSet[13, 2] := BITSET{BEGINSym-32};
  symSet[13, 3] := BITSET{};
  symSet[13, 4] := BITSET{};
  symSet[13, 5] := BITSET{};
  symSet[14, 0] := BITSET{EOFSYM, MODULESym, ENDSym};
  symSet[14, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16};
  symSet[14, 2] := BITSET{BEGINSym-32};
  symSet[14, 3] := BITSET{};
  symSet[14, 4] := BITSET{};
  symSet[14, 5] := BITSET{};
  symSet[15, 0] := BITSET{EOFSYM, identifierSym, ENDSym};
  symSet[15, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16};
  symSet[15, 2] := BITSET{};
  symSet[15, 3] := BITSET{};
  symSet[15, 4] := BITSET{};
  symSet[15, 5] := BITSET{};
  symSet[16, 0] := BITSET{EOFSYM, ENDSym};
  symSet[16, 1] := BITSET{CONSTSym-16, TYPESym-16, VARSym-16, PROCEDURESym-16};
  symSet[16, 2] := BITSET{};
  symSet[16, 3] := BITSET{};
  symSet[16, 4] := BITSET{};
  symSet[16, 5] := BITSET{};
END C2P.

