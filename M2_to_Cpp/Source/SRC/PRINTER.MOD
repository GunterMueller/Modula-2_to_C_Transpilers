IMPLEMENTATION MODULE Printer;
(* Pretty printing auxiliary functions for use with Modula-2 pretty printing
   program generated by COCO from an attributed grammar
   P.D. Terry, Rhodes University, 1995 *)
(* Modified by Milos Radovanovic, 2000, 2001 *)

  IMPORT FileIO, ConstStr(*, C2S*);
  IMPORT Addr, String;

  CONST
    BufMax = 12000;
  VAR
    AllBlanks : BOOLEAN;
    Last, Indentation, PrependPos : CARDINAL;
    Buffer : ARRAY [0 .. BufMax] OF CHAR;

  PROCEDURE OpenResults(modName, ext: ARRAY OF CHAR);
    BEGIN
      IF ext[0] # '.' THEN String.Insert(ext, '.', 0) END;
      FileIO.ChangeExtension(modName, ext, resultsName);
      FileIO.Open(results, resultsName, TRUE);
      IF ~ FileIO.Okay THEN
        FileIO.WriteString(FileIO.StdOut, "Could not open destination file `");
        FileIO.WriteString(FileIO.StdOut, resultsName);
        FileIO.WriteString(FileIO.StdOut, "'");
        FileIO.WriteLn(FileIO.StdOut);
        FileIO.QuitExecution;
      END;
    END OpenResults;

  PROCEDURE CloseResults;
    BEGIN
      FileIO.Close(results);
    END CloseResults;

  PROCEDURE NewLine;
    BEGIN
      IF NOT AllBlanks THEN (* first strip trailing spaces *)
        WHILE (Last > 0) & (Buffer[Last-1] = ' ') DO DEC(Last) END;
        FileIO.WriteBytes(results, Buffer, Last);
        FileIO.WriteLn(results);
      END;
      Last := 0;
      WHILE Last < Indentation DO Buffer[Last] := ' '; INC(Last) END;
      Buffer[Last] := 0C; AllBlanks := TRUE;
    END NewLine;

  PROCEDURE Flush;
    BEGIN
      (*IF NOT AllBlanks THEN*) (* first strip trailing spaces *)
        FileIO.WriteBytes(results, Buffer, Last);
      (*END;*)
      Last := 0;
      Buffer[Last] := 0C; AllBlanks := TRUE;
    END Flush;

  PROCEDURE MarkPrependPos;
  BEGIN
    PrependPos := Last;
  END MarkPrependPos;

  PROCEDURE Prepend (Str : ARRAY OF CHAR);
    VAR
      l : CARDINAL;
    BEGIN
      String.Insert(Buffer, Str, PrependPos);
      l := 0;
      WHILE AllBlanks AND (l <= HIGH(Str)) AND (Str[l] # 0C) DO
        IF Str[l] # ' ' THEN AllBlanks := FALSE END;
        INC(l);
      END;
      Last := String.Length(Buffer)
    END Prepend;

  PROCEDURE Append (Str : ARRAY OF CHAR);
    VAR
      l : CARDINAL;
    BEGIN
      l := 0;
      WHILE (l <= HIGH(Str)) AND (Str[l] # 0C) DO
        Buffer[Last] := Str[l];
        IF Str[l] # ' ' THEN AllBlanks := FALSE END;
        INC(l); INC(Last)
      END;
      Buffer[Last] := 0C;
      (*
      IF C2S.seenComment THEN
        NewLine; AllBlanks := FALSE;
        C2S.GetComment(Buffer, Last, l); INC(Last, l);
        Buffer[Last] := ' '; INC(Last); Buffer[Last] := CHR(0);
      END
      *)
    END Append;

  PROCEDURE AppendLabel (n : CARDINAL);
    VAR
      i, l, d : CARDINAL;
      t, s : ARRAY [0 .. 15] OF CHAR;
    BEGIN
      l := 0;
      REPEAT
        d := n MOD 10; n := n DIV 10;
        INC(l); t[l] := CHR(ORD("0") + d);
      UNTIL n = 0;
      i := 0; WHILE l > 0 DO s[i] := t[l]; INC(i); DEC(l) END;
      s[i] := 0C; Append(s);
    END AppendLabel;

  PROCEDURE Insert(Str : ARRAY OF CHAR; Pos : CARDINAL);
    VAR
      l : CARDINAL;
    BEGIN
      String.Insert(Buffer, Str, Pos);
      l := 0;
      WHILE AllBlanks AND (l <= HIGH(Str)) AND (Str[l] # 0C) DO
        IF Str[l] # ' ' THEN AllBlanks := FALSE END;
        INC(l);
      END;
      Last := String.Length(Buffer)
    END Insert;

  PROCEDURE IndentNextLine;
    BEGIN
      INC(Indentation, 2); NewLine
    END IndentNextLine;

  PROCEDURE ExdentNextLine;
    BEGIN
      IF Indentation > 1 THEN DEC(Indentation, 2) END; NewLine
    END ExdentNextLine;

  PROCEDURE Indent;
    BEGIN
      INC(Indentation, 2)
    END Indent;

  PROCEDURE Exdent;
    BEGIN
      IF Indentation > 1 THEN DEC(Indentation, 2) END
    END Exdent;

  PROCEDURE BlankLine;
    BEGIN
      NewLine; FileIO.WriteLn(results);
    END BlankLine;

  PROCEDURE BackTrack (Old, New : ARRAY OF CHAR);
    VAR
      l, p : CARDINAL;
      isSubStr : BOOLEAN;
    BEGIN
      l := String.Length(Old);
      IF l > 0 THEN
        isSubStr := String.SubString(Buffer, Old, p);
        IF isSubStr THEN
          String.Delete(Buffer, p, p+l-1);
          String.Insert(Buffer, New, p);
          Last := String.Length(Buffer)
        END;
      END;
    END BackTrack;

  PROCEDURE GetPos(VAR Pos: CARDINAL);
    BEGIN
      Pos := Last;
    END GetPos;

  PROCEDURE GetBuffer (VAR Str : ARRAY OF CHAR);
    VAR
      l: CARDINAL;
    BEGIN
      l := 0;
      WHILE (l <= HIGH(Buffer)) AND (Buffer[l] = ' ') DO
        INC(l);
      END;
      String.Slice(Str, Buffer, l, String.Length(Buffer));
    END GetBuffer;

  PROCEDURE DelBuffer;
    BEGIN
      Last := 0;
      WHILE (Buffer[Last] = ' ') AND (Last <= HIGH(Buffer)) DO
        INC(Last);
      END;
      IF Last <= HIGH(Buffer) THEN
        Buffer[Last] := 0C;
      END;
      AllBlanks := TRUE;
    END DelBuffer;

  BEGIN
    Indentation := 0; AllBlanks := TRUE; Last := 0; PrependPos := 0;
    String.Copy(resultsName, "");
  END Printer.
