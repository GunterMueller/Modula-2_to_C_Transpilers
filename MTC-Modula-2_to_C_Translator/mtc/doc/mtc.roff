.de iE
.iT \\$1 \\$2 \\$3 \\$4 1u \\$5
.ev 1
.iT \\$1 \\$2 \\$3 \\$4 1u \\$5
.ev
.ev 2
.iT \\$1 \\$2 \\$3 \\$4 10u/12u \\$5
.nr nV \\n(.vu
.ev
..
.de iT
.c2 ?
.lg 0
.hy \\$6
.hc \%
.ft \\$2
.ps \\$3*\\$5
.nr tt \\$4
.vs \\n(ttu*\\$5
.nr tt \\$1
.ll \\n(ttu
.lt \\n(ttu
..
.de iP
.nr tt \\$1
.po \\n(ttu
.nr tt \\$2
.pl \\n(ttu
.nr kA \\$3
.nr kB \\$4
.nr kC \\$5
.nr tt \\$6
.nr fA \\n(.pu-\\n(ttu-1v
.nr tt \\$7
.nr fB \\n(.pu-\\n(ttu-1v
.nr tt \\$8
.nr fC \\n(.pu-\\n(ttu-1v
.nr s1 1
.wh 0 kT
.nr fP \\n(fCu
.wh \\n(fPu fT
.nr bO 0
.nr bN 0
.wh 9999u nT
.nr nO 0
.nr nN 0
.nr nZ 0
.em sE
..
.de iD
.nh
.ev 1
.nh
.ev
.ev 2
.nh
.ev
..
.de kT
.ev 1
.nr sN +1
.nf
.sp |\\n(kAu
.ie \\n(s1 \{\
.tl '\\*(k7'\\*(k8'\\*(k9'
.\}
.el \{\
.ie \\n(sN%2   .tl '\\*(k1'\\*(k2'\\*(k3'
.el .tl '\\*(k4'\\*(k5'\\*(k6'
.\}
.sp |\\n(kBu
.kX
.sp |\\n(kCu
.if \\n(bO \{\
.nr bO 0
.bK
.di bK
.di
.\}
.if \\n(nO \{\
.nr nO 0
.ev 2
.da nF
\l'5c'
.br
.nK
.br
.di
.ev
.nr fP -\\n(dnu
.if !(\\n(fPu-\\n(nlu) .nr fP \\n(nlu+1v
.ch fT \\n(fPu
.nr nN 1
.di nK
.di
.\}
.nr nZ 0
.ev
.ns
..
.de fT
.ev 1
.nf
.if \\n(bN \{\
.nr bN 0
.bF
.di bF
.di
.\}
.if \\n(nN \{\
.nr nN 0
.nr nO 0
.ch nT \\n(fCu
.nF
.if \\n(nO \{\
.  di
.  if !\\n(dn .nr nO 0
.  \}
.di nF
.di
.ch nT 9999u
.\}
.sp |\\n(fBu
.fX
.sp |\\n(fAu
.ie \\n(s1=1 \{\
.tl '\\*(f7'\\*(f8'\\*(f9'
.nr s1 0
.\}
.el \{\
.ie \\n(sN%2   .tl '\\*(f1'\\*(f2'\\*(f3'
.el .tl '\\*(f4'\\*(f5'\\*(f6'
.\}
.nr fP \\n(fCu
.ch fT \\n(fPu
.bp
.ev
..
.de nT
.nr nO 1
.di nK
..
.de sE
.if \\n(nO+\\n(bO \&
..
.de zA
.br
.di zX
..
.de zE
.br
.di
.if \\n(nlu>\\n(kCu \{\
.ne \\n(dnu
.\}
.ev 1
.zX
.ev
..
.de nA
.ie \\n(nN \{\
.ne \\n(nVu+1v
.\}
.el \{\
.ne \\n(nVu*2u+1v
.\}
.nr nZ +1
..
.de nB
.ev 2
.da nF
.if !\\n(nN \{\
\l'5c'
.br
.\}
.in +2n
.ti -2n
..
.de nE
.br
.in -2n
.di
.ev
.nr fP -\\n(dnu
.if !\\n(nN .nr fP -\\n(nVu
.if !(\\n(fPu-\\n(nlu) .nr fP \\n(nlu+1v
.ch fT \\n(fPu
.nr nN 1
..
.de bA
.ev 1
.fi
.di bZ
..
.de bB
.br
.di
.nf
.nr bH \\n(dnu
.nr tt \\$1v
.ie (\\n(nlu+\\n(bHu+(2u*\\n(ttu))<\\n(fPu \{\
.sp \\n(ttu
.rs
.bZ
.sp \\n(ttu
.\}
.el \{\
.da bK
.if \\n(fCu-\\n(bHu-\\n(kCu \{\
\!.ne \\n(bHu
.\}
\!.rs
.bZ
.sp \\n(ttu
\!.ne 3v
.di
.nr bO 1
.\}
.ev
..
.de bE
.br
.di
.nf
.nr bH \\n(dnu
.nr tt \\$1v
.ie (\\n(nlu+\\n(bHu+\\n(ttu)<\\n(fPu \{\
.da bF
.sp \\n(ttu
\!.rs
.bZ
.di
.nr fP -\\n(bHu
.ch fT \\n(fPu
.nr bN 1
.\}
.el \{\
.da bK
.if \\n(fCu-\\n(bHu-\\n(kCu \{\
\!.ne \\n(bHu
.\}
\!.rs
.bZ
.sp \\n(ttu
\!.ne 3v
.di
.nr bO 1
.\}
.ev
..
.de hS
.nr h1 \\$1
.nr h2 \\$2
.nr h3 \\$3
.nr h4 \\$4
.nr h5 \\$5
.if \\n(.$ .nr h\\n(.$ -1
..
.de hT
.af h1 \\$1
.af h2 \\$2
.af h3 \\$3
.af h4 \\$4
.af h5 \\$5
..
.de hA
.sp \\$2
.ne \\$3+3v
.nr h\\$1 +1
.if \\$1<5 .nr h5 0
.if \\$1<4 .nr h4 0
.if \\$1<3 .nr h3 0
.if \\$1<2 .nr h2 0
..
.de hB
.nr hI \\$1
.if \\n(hI .nr hI +2n
.in +\\n(hIu
.if \\n(hI .sp -1v
..
.de hC
.in -\\n(hIu
.sp \\$1
.ns
.ti +\\$2
.ev 1
.fi
.da hX
.sp \\$3
.ll -9n
.in +\\$4
\!.ne 2v+\\$5
..
.de hD
.in +\\$1
.sp -1v
..
.de hE
.br
.nr hJ \\n(.nu+\\n(.iu+2n
.nr hK \\n(.lu+3n
.in -\\$1
.in -\\$2
.ll +9n
.sp -1v
.ta \\n(hJu \\n(hKu \\n(.luR
.tc
.lc .
\t\a\t\\n(sN
.sp \\$3
.di
.nf
.ev
..
.de hH
.br
.ev 1
.hX
.ev
..
.de lA
.ev 1
.fi
.da lX
..
.de lE
.br
.di
.nf
.ev
..
.de lL
.br
.ev 1
.lX
.ev
..
.de eD
.ne 2v
.br
.nr e\\$1 \\n(.nu
.in +\\n(e\\$1u
.sp -1v
..
.de eE
.in -\\n(e\\$1u
..
.de PS
.nr pE (\\n(.lu-\\$2u)/2u
.in +\\n(pEu
.ne \\$1u
..
.de PE
.in -\\n(pEu
..
.ds dO "$
.
.ds : \h'-(\\w'\\(um'u+\\w'a'u)/2u'\\(um\h'(\\w'a'u-\\w'\\(um'u)/2u'
.ds ; \h'-(\\w'\\(um'u+\\w'U'u)/2u'\v'-0.2m'\
\\(um\v'+0.2m'\h'(\\w'U'u-\\w'\\(um'u)/2u'
.
.
.ds #h ((1u-(\\\\n(.fu%2u))*0.13m)
.ds ' \k_\h'-(\\n(.wu*8/10-\*(#h)'\v'-0.1m'\(aa\v'+0.1m'\h'|\\n_u'
.ds ` \k_\h'-(\\n(.wu*7/10-\*(#h)'\v'-0.1m'\(ga\v'+0.1m'\h'|\\n_u'
.ds ^ \k_\h'-(\\n(.wu-\*(#h-0.05m)'\v'-0.5m'\s-2^\s0\v'+0.5m'\h'|\\n_u'
.ds ~ \k_\h'-(\\n(.wu-\*(#h-0.05m)'\v'-0.5m'\s-2~\s0\v'+0.5m'\h'|\\n_u'
.ds , \k_\h'-(\\n(.wu*8/10)',\h'|\\n_u'
.ds v \k_\h'-(\\n(.wu*9/10-\*(#h)'\v'-0.6m'\
\s-4v\s0\v'+0.6m'\h'|\\n_u'
.ds o \k_\h'-(\\n(.wu+\w'\(de'u-\*(#h)/2u'\v'-0.4n'\
\z\(de\v'0.4n'\h'|\\n_u'
.rm #h
.iE 16.5cn 1 12 14pp 30
.iP 2.5cn 29.7cv 3vv 4vv 8vv 3vv 4vv 4vv
.ce 9999
\&\fB
.nr gP \n(.s
.ps \n(.s*5u/2u
\&Entwurf und Implementierung
.ps \n(gP
\&\fP
.ce 0
.br
.ce 9999
\&\fB
.nr gP \n(.s
.ps \n(.s*5u/2u
\&eines \(U:bersetzers
.ps \n(gP
\&\fP
.ce 0
.br
.ce 9999
\&\fB
.nr gP \n(.s
.ps \n(.s*5u/2u
\&von Modula-2 nach C
.ps \n(gP
\&\fP
.ce 0
.sp 9
.ce 9999
\&\fB\s+2Diplomarbeit\s-2\fP
.ce 0
.sp 0.4v
.ce 9999
\&\s+2von\s-2
.ce 0
.sp 0.4v
.ce 9999
\&\fB\s+2Matthias Martin\s-2\fP
.ce 0
.sp 9
.ce 9999
\&\fB\s+2Universit\(a:t Karlsruhe\s-2\fP
.ce 0
.sp 0.4v
.ce 9999
\&\fB\s+2Fakult\(a:t f\(u:r Informatik\s-2\fP
.ce 0
.sp 0.4v
.ce 9999
\&\s+2Februar 1990\s-2
.ce 0
.sp 9
.ce 9999
\&\s+2Betreuer:\s-2
.ce 0
.sp 0.4v
.ce 9999
\&\s+2Prof. Dr. S. J\(a:hnichen\s-2
.ce 0
.sp 0.4v
.ce 9999
\&\s+2Dr. J. Grosch\s-2
.ce 0
\s+2
.ce 9999
\&\fB\(U:bersicht\fP
.ce 0
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Diese Diplomarbeit beschreibt den Entwurf und die Implementierung des
\(U:bersetzers \%Mtc, der in \%Modula-2 geschriebene Programme in
lesbaren C-Code umsetzt. Die Definition einer vollst\(a:ndigen Abbildung von
\%Modula-2 nach C, die auch anhand von zahlreichen Beispielen illustriert
wird, bildet den Hauptteil dieser Arbeit. Die Implementierung des \(U:bersetzers
erfolgte unter weitgehendem Einsatz von \(U:bersetzerbauwerkzeugen. Die
Beschreibung der Implementierung konzentriert sich daher besonders auf die
Darstellung des Einsatzes dieser Werkzeuge. Ein abschlie\(ssendes
Kapitel \(u:ber erste praktische Eins\(a:tze von \%Mtc demonstriert die
Leistungsf\(a:higkeit und Laufzeiteffizienz des \(U:bersetzers sowie die Qualit\(a:t
des erzeugten C-Codes.
\s-2
                  
            
               
	     
.nr sN 1-1
.br
.ne 29.7c
.eo
.ds f1 
.ds f2 \n(sN
.ds f3 
.ec
.eo
.ds f4 
.ds f5 \n(sN
.ds f6 
.ec
.eo
.ds f7 
.ds f8 \n(sN
.ds f9 
.ec
.de fX
.fi
.nf
..
\&           
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Einleitung\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Einleitung
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Diese Arbeit beschreibt den Entwurf und die Implementierung des \(U:bersetzers
\%\fIMtc\fP, der in \%Modula-2 geschriebene Programme in lesbaren C-Code
umsetzt.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Motivation und Zielsetzung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Motivation und Zielsetzung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 
[Wirth\|85]
ist eine Weiterentwicklung der Programmiersprache Pascal, die
im wesentlichen um ein Modulkonzept erweitert wurde. An der
GMD Forschungsstelle Karlsruhe wurde der Modula-\(U:bersetzer \%MOCKA
[Engelmann\|87]
entwickelt, der auch vollst\(a:ndig in \%Modula-2 implementiert ist.
\%Modula-2 und \%MOCKA werden zur Zeit an der GMD Forschungsstelle
Karlsruhe
als bevorzugte Werkzeuge zur Programmentwicklung eingesetzt. Insbesondere
sind alle in den letzten drei Jahren am Institut
entwickelten \(U:bersetzerbauwerkzeuge
in \%Modula-2 implementiert.
.sp 0.4v
.ne 2v
.ti +2n
Die Sprache C [Kernighan\|78] wurde urspr\(u:nglich entworfen und
implementiert f\(u:r die Entwicklung des UNIX-Betriebssystems
[UNIX\|79], welches abgesehen von wenigen Teilen,
bei denen extrem hohe Effizienzanforderungen oder spezielle
Maschineneigenschaften
den Einsatz von Assembler notwendig machen, vollst\(a:ndig in C implementiert
ist. Da \%UNIX nicht nur ein Betriebssystem ist, sondern, weniger eng
betrachtet, unter dem Begriff \%UNIX eine Programmierumgebung
mit einer Vielzahl von n\(u:tzlichen Werkzeugen f\(u:r die Programmentwicklung
verstanden
wird, hat \%UNIX in den letzten Jahren, besonders im wissenschaftlichen
Bereich, eine sehr weite Verbreitung gefunden. Auch an der GMD Forschungsstelle
Karlsruhe wird \%UNIX eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Aus den einleitenden Vorbemerkungen l\(a:\(sst sich nun direkt die
haupts\(a:chliche Zielsetzung und das geplante Einsatzgebiet von \%\fIMtc\fP
ableiten:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Modula-\(U:bersetzer \%MOCKA und die am Institut entwickelten
\(U:bersetzerbauwerkzeuge k\(o:nnen mit \%\fIMtc\fP schnell und relativ einfach
auf neue Maschinen \(u:bertragen werden, auf denen das UNIX-System und ein
\(U:bersetzer f\(u:r die Sprache C vorhanden sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die \(U:bersetzerbauwerkzeuge werden auch f\(u:r alle Interessenten
zug\(a:nglich, die einen \(U:bersetzer f\(u:r die im Vergleich mit \%Modula-2
weit verbreitete Sprache C besitzen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Weiterentwicklung der \(U:bersetzerbauwerkzeuge kann in der besser
strukturierten, moderneren und relativ sicheren Sprache \%Modula-2
erfolgen, die Werkzeuge sind aber auch jederzeit, ohne den riesigen Aufwand
einer \(U:bersetzung von Hand, in C und unter \%UNIX verf\(u:gbar.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da \%\fIMtc\fP f\(u:r die \(U:bertragung von fertigen Modula-Programmen
nach C gedacht ist und nicht f\(u:r die Programmentwicklung eingesetzt werden
soll, kann bei der Implementierung davon ausgegangen werden, da\(ss nur korrekte
Programme als Eingabe vorkommen. Insbesondere soll die semantische Korrektheit
der Eingabeprogramme nicht \(u:berpr\(u:ft werden.
Weil die \(u:bersetzten Programme unter Umst\(a:nden noch von Hand weiterbearbeitet
werden sollen, ist
eine wichtige Forderung an die erzeugten Programme, da\(ss sie gut lesbar sind.
.sp 0.4v
.ne 2v
.ti +2n
Ein weiteres Ziel dieser Arbeit ist der praktische Einsatz der bisher
entwickelten \(U:bersetzerbauwerkzeuge bei der Implementierung von \%\fIMtc\fP, um
dabei:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die praktische Einsetzbarkeit der Werkzeuge f\(u:r die Entwicklung eines
gr\(o:\(sseren \(U:bersetzers zu zeigen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Leistungsf\(a:higkeit der Werkzeuge und des (teilweise) generierten
\(U:bersetzers zu demonstrieren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Erfahrungen zu sammeln, die zu einer Verbesserung der Werkzeuge f\(u:hren.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Randbedingungen\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Randbedingungen
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Implementierung des \(U:bersetzers erfolgt auf UNIX-Workstations der
Firmen \%PCS und \%SUN.
Implementierungssprache ist \%Modula-2. Die folgenden an der
GMD Forschungsstelle Karlsruhe entwickelten \(U:bersetzerbauwerkzeuge
standen f\(u:r die Entwicklung von \%\fIMtc\fP zur Verf\(u:gung:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Generator f\(u:r Symbolentschl\(u:ssler \%\fIRex\fP [Grosch\|87b].
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Zerteilergeneratoren \%\fILalr\fP und \%\fIEll\fP [Vielsack\|88].
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%\fIAst\fP [Grosch\|89a], ein Werkzeug zur Spezifikation
und Implementierung von abstrakten Syntaxb\(a:umen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%\fIAg\fP [Grosch\|89b], ein Generator f\(u:r
Attributauswerter.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Das Werkzeug \%\fIEstra\fP [Vielsack\|89] zur Spezifikation
und Implementierung der Transformation attributierter Strukturb\(a:ume.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Neben diesen Werkzeugen
wurden Modula-Moduln aus der umfangreichen Bibliothek \%\fIReuse\fP
[Grosch\|87a] mit wiederverwendbarer Software verwendet.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Vergleichbare Arbeiten\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Vergleichbare Arbeiten
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
In diesem Kapitel sollen kurz zwei mit \%\fIMtc\fP vergleichbare Arbeiten
vorgestellt werden, die sich mit der \(U:bersetzung von Programmen von einer
h\(o:heren Programmiersprache in eine andere h\(o:here Programmiersprache
besch\(a:ftigen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&PTC\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&PTC
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der \(U:bersetzer \%PTC [PTC\|87] war f\(u:r die vorliegende Arbeit von besonderem
Interesse, da die Zielsprache ebenfalls C und die Quellsprache \%Pascal
der Vorg\(a:nger von \%Modula-2 ist.
Er wurde von P. Bergsten bei der Firma Holistic Technology AB,
Gothenburg, Schweden entwickelt.
.sp 0.4v
.ne 2v
.ti +2n
\%PTC verarbeitet ein korrektes Pascal-Programm und erzeugt ein
\(a:quivalentes C-Programm.
Der \(U:bersetzer, der
(fast) vollst\(a:ndiges \%Pascal implementiert,
wurde entworfen, um fertig
entwickelte
Pascal-Programme auf Systeme zu \(u:bertragen, die keinen Pascal-\(U:bersetzer
besitzen. Er ist nicht f\(u:r die Programmentwicklung gedacht. Daher wird die
Korrektheit der Eingabeprogramme auch nicht \(u:berpr\(u:ft und beim
ersten entdeckten
Fehler bricht der \(U:bersetzer mit einer entsprechenden Meldung ab. PTC besitzt
daher keinerlei Fehlerbehandlung und fehlerhafte Programme k\(o:nnen im
schlimmsten Fall sogar zum Absturz des \(U:bersetzers f\(u:hren.
.sp 0.4v
.ne 2v
.ti +2n
Auf die von \%PTC implementierte Abbildung von \%Pascal nach C soll
hier nicht im Detail eingegangen werden. Da \%Modula-2 ein Nachfolger von
\%Pascal ist und daher ein nicht unerheblicher Teil der beiden Sprachen,
abgesehen von kleinen syntaktischen Unterschieden, nahezu identisch ist und
dar\(u:berhinaus an vielen Stellen die Abbildung nach C auf der Hand liegt,
stimmt die von \%PTC implementierte Abbildung f\(u:r die gemeinsamen
Konstrukte von \%Modula-2 und \%Pascal
im Prinzip mit der in Kapitel 4 beschriebenen Abbildung von
\%Modula-2 nach C \(u:berein. Dort wird an den entsprechenden
Stellen
darauf verwiesen, wo besonders elegante L\(o:sungen von \%PTC \(u:bernommen
wurden.
.sp 0.4v
.ne 2v
.ti +2n
Hier soll nur kurz dargestellt werden, welche Probleme bei der Abbildung
f\(u:r \%Modula-2 im Vergleich zu \%Pascal entfallen und welche neu
hinzukommen.
.sp 0.4v
.ne 2v
.ti +2n
Da in \%Modula-2 die Ein-/Ausgabe, die Dateiverwaltung sowie die
Speicherverwaltung nicht Teil der Sprachdefinition sind, entf\(a:llt die f\(u:r
\%Pascal notwendige und teilweise sehr aufwendige Abbildung dieser
Konstrukte, die von \%PTC mit Hilfe der C-Standardbibliothek implementiert
werden. Spr\(u:nge, insbesondere Spr\(u:nge, die eine Prozedur verlassen und die
kein direktes Gegenst\(u:ck in C haben, sind in \%Modula-2 ebenfalls nicht
m\(o:glich. Ein weiteres, von
\%PTC allerdings nicht gel\(o:stes Problem, welches in \%Modula-2
entf\(a:llt, ist die in \%Pascal gegebene M\(o:glichkeit lokal deklarierte
Prozeduren als Prozedurparameter zu \(u:bergeben.
.sp 0.4v
.ne 2v
.ti +2n
Verglichen mit \%Pascal kommen in \%Modula-2 insbesondere
das Modulkonzept und die getrennte \(U:bersetzung neu
hinzu.
Au\(sserdem ist die Reihenfolge der Deklarationen und Anweisungen in
\%Modula-2 nicht so stark eingeschr\(a:nkt wie in \%Pascal und es sind
allgemeine Ausdr\(u:cke in Deklarationen zul\(a:ssig. Das Konzept der
\(U:bergabe von Funktionen bzw. Prozeduren als Parameter wurde in \%Modula-2
zu dem allgemeinen Konzept der Prozedurtypen und -variablen erweitert.
Zus\(a:tzlich neu ist die
M\(o:glichkeit, Felder beliebiger Gr\(o:\(sse an Prozeduren zu \(u:bergeben sowie eine
Reihe von M\(o:glichkeiten zur ,,maschinennahen'' Programmierung.
.sp 0.4v
.ne 2v
.ti +2n
\%PTC ist in \%Pascal implementiert. Das Programm ist im wesentlichen
aus den drei Prozeduren \%\fIparse\fP, \%\fItransform\fP und \%\fIemit\fP aufgebaut.
.sp 0.4v
.ne 2v
.ti +2n
Die Prozedur \%\fIparse\fP liest und zerteilt das Quellprogramm und baut einen
abstrakten Strukturbaum auf. Die Zerteilung arbeitet nach dem Verfahren des
rekursiven Abstiegs. Parallel zur Zerteilung wird eine Definitionstabelle
aufgebaut und die Bezeichneridentifikation durchgef\(u:hrt.
.sp 0.4v
.ne 2v
.ti +2n
Die Prozedur \%\fItransform\fP f\(u:hrt eine Reihe von Baum-zu-Baum
Transformationen durch, die notwendig sind, um das Pascal-Programm nach C zu
\(u:bersetzen. Die wichtigste dieser Transformationen ist die Delokalisierung von
in \%Pascal
lokal deklarierten Prozeduren, da in C keine geschachtelten
Funktionsdeklarationen zul\(a:ssig sind. Zus\(a:tzlich zur Transformation des
Strukturbaums werden bei Bedarf auch Bezeichner zur Vermeidung von
Namenskonflikten umbenannt.
.sp 0.4v
.ne 2v
.ti +2n
Die Prozedur \%\fIemit\fP schlie\(sslich traversiert den transformierten Baum und
gibt die entsprechenden C-Konstrukte aus.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&PascAda\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&PascAda
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Das an der University of California entworfenen \fIPascAda\fP\^-System
[PascAda\|80] besteht aus zwei
\(U:bersetzern; der eine transformiert Pascal-Programme in Ada-Programme, der
zweite f\(u:hrt die entgegengesetzte Transformation durch.
Beide \(U:bersetzer sind in \%Pascal implementiert.
Die wichtigsten Ziele dieses Projekts waren\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Wobei man ber\(u:cksichtigen
mu\(ss, da\(ss das Projekt zu einem Zeitpunkt durchgef\(u:hrt wurde, als gerade eine
erste Definition der Sprache \%Ada aber noch kein
Ada-\(U:bersetzer vorlag.
.nE
\&:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Da die beiden \(U:bersetzer in \%Pascal implementiert sind, f\(u:r das
Implementierungen existieren, stellt der \(U:bersetzer von \%Ada nach
\%Pascal einen \(U:bersetzer f\(u:r (eine Teilmenge von) \%Ada dar.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&M\(o:glichkeit der vorl\(a:ufigen Entwicklung von Software in \%Ada.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Umsetzen existierender, in Pascal implementierter Software nach
\%Ada.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Unterst\(u:tzung der \(U:bertragung von in \%Ada und/oder
\%Pascal implementierter Software auf neue Systeme.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&M\(o:glichkeit zu Experimenten mit \%Ada.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bootstrap eines Ada-\(U:bersetzers.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die \fIPascAda\fP-Gruppe ist bei diesem Projekt folgenderma\(ssen vorgegangen.
Zun\(a:chst wurden zwei Teilmengen \%\fIAdaP\fP und \%\fIPascalA\fP von
\%Ada und \%Pascal definiert, f\(u:r die eine direkte \%1:1
\(U:bersetzung
in die jeweils andere Teilmenge existiert. Im n\(a:chsten Schritt wurden
dann zwei erweiterte Teilsprachen \%\fIAdaPE\fP und \%\fIPascalAE\fP
definiert, f\(u:r welche Transformationsregeln gefunden werden konnten, wie
Konstrukte dieser erweiterten Teilsprachen durch Transformation der
Quellprogramme auf Konstrukte von \%\fIAdaP\fP bzw. \%\fIPascalA\fP
abgebildet werden k\(o:nnen. Da die Semantik von \%Ada eine weitgehende
Obermenge von \%Pascal ist, ist \%\fIPascalAE\fP nahezu vollst\(a:ndiges
\%Pascal. Eine Ausnahme sind z.B. Prozeduren und Funktionen als Parameter
oder nicht lokale Spr\(u:nge. Da f\(u:r viele Sprachkonzepte von \%Ada, wie
z.B. Parallelverarbeitung und Ausnahmebehandlung, keine entsprechenden
Konzepte in \%Pascal existieren und eine Simulation, wenn \(u:berhaupt,
nur mit gro\(ssem Aufwand m\(o:glich
w\(a:re, sind die Einschr\(a:nkungen bei \%\fIAdaPE\fP nat\(u:rlich gr\(o:\(sser.
.sp 0.4v
.ne 2v
.ti +2n
Bei der Implementierung der beiden \(U:bersetzer wurde als gemeinsame
Zwischensprache die Baumstruktur aus einer formalen
Definition von \%Ada [Donzeau\|79] benutzt,
die um einige spezielle Konstrukte f\(u:r
\%\fIPascalAE\fP erweitert wurde. Der \(U:bersetzer von Pascal nach Ada besteht
logisch aus 4 Komponenten:
.sp 0.3vv
.nr a1 0
.af a1 1
.br
.ne 2v
\&\fIPascalToTree:\fP
.in +18n
.if \w'\fIPascalToTree:\fP\ 'u<18n .sp -1v
\&Setzt das Quellprogramm in einen Baum der
Zwischensprache um.
.in -18n
.br
.ne 2v
\&\fIPascalAEtoA:\fP
.in +18n
.if \w'\fIPascalAEtoA:\fP\ 'u<18n .sp -1v
\&Setzt \fIPascalAE\fP-Konstrukte durch Baum-zu-Baum
Transformationen in entsprechende \fIPascalA\fP-Konstrukte um.
.in -18n
.br
.ne 2v
\&\fIPascalACheck:\fP
.in +18n
.if \w'\fIPascalACheck:\fP\ 'u<18n .sp -1v
\&Pr\(u:ft, ob der Baum einem Programm der Teilsprache
\%\fIPascalA\fP entspricht.
.in -18n
.br
.ne 2v
\&\fITreeToAda:\fP
.in +18n
.if \w'\fITreeToAda:\fP\ 'u<18n .sp -1v
\&Setzt den Baum in ein entsprechendes Ada-Programm um.
.in -18n
.sp 0.3vv
Der \(U:bersetzer von \%Ada nach \%Pascal besteht aus 4 analogen
Komponenten.
.sp 0.4v
.ne 2v
.ti +2n
Beide \(U:bersetzer f\(u:hren keine komplette semantische Analyse durch, sondern
pr\(u:fen nur ob ein Programm in der jeweiligen Teilsprache \%\fIPascalAE\fP
bzw. \%\fIAdaPE\fP enthalten ist.
.br
.ne 3
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Die Sprachen\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Die Sprachen
.hE 0 4n 0.1v
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Die Quellsprache Modula-2\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Die Quellsprache Modula-2
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Programmiersprache Modula-2 [Wirth\|85] wurde Ende der siebziger
Jahre an der \%ETH
Z\(u:rich unter der Leitung von Professor N. Wirth entwickelt. \%Modula-2 ist
ein direkter Nachfolger der Programmiersprache \%Pascal. Das wichtigste
neue Sprachkonzept im Vergleich zu \%Pascal ist ein Modulkonzept.
Die folgende Aufz\(a:hlung gibt einen kurzen \(U:berblick \(u:ber \%Modula-2:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein Modula-Programm besteht aus einer Reihe von \(U:bersetzungseinheiten,
die getrennt \(u:bersetzt werden k\(o:nnen. Eine solche \(U:bersetzungseinheit ist
entweder ein Programmodul, ein Definitionsmodul oder ein Implementierungsmodul.
Ein Programmodul stellt ein Hauptprogramm dar. Definitions- und
Implementierungsmoduln treten immer paarweise auf. Es handelt sich dabei jeweils
um einen logisch zusammengeh\(o:renden Modul. Der Definitionsmodul stellt die
Schnittstelle des Moduls dar und spezifiziert die vom Modul exportierten, d.h.
die nach au\(ssen sichtbaren Objekte (Daten und Operationen). Der
Implementierungsmodul enth\(a:lt die Implementierung der nach au\(ssen sichtbaren
Operationen und eventuell weitere lokale Objekte. Der Realisierung des
Geheimnisprinzips dienen die sogenannten opaquen Typen, deren Struktur den
sie benutzenden Moduln verborgen bleibt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle im Modula-Programm benutzten Objekte m\(u:ssen durch eine Deklaration
bekannt gemacht werden, es sei denn, es handelt sich um ein vordefiniertes
Objekt.
Die Objekte von \%Modula-2 sind: Konstanten, Typen, Variablen, Prozeduren
und Moduln.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 ist eine blockstrukturierte Sprache. Zus\(a:tzlich zur
Blockstruktur erlaubt das Modulkonzept eine explizite Kontrolle des
G\(u:ltigkeitsbereichs bzw. der Sichtbarkeit von Objekten. Alle Objekte, die
innerhalb von Deklarationen verwendet werden, m\(u:ssen textuell vor ihrer
Benutzung deklariert werden; ein Objekt kann aber innerhalb einer Anweisung
benutzt werden, die der Deklaration des Objekts textuell vorangeht.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 ist eine streng typisierte Sprache. Die Grundtypen von
\%Modula-2 sind: Zeichen, Wahrheitswerte sowie ganze und reelle
Zahlen verschiedener Gr\(o:\(sse. Neben den Grundtypen besitzt \%Modula-2 einen
umfangreichen Satz von Typkonstruktoren. Die m\(o:glichen Typen sind:
Grundtypen, Aufz\(a:hlungstypen, Unterbereichstypen, Felder, Verbunde,
Verbunde mit Varianten, Mengen, Zeiger und Prozedurtypen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Prozedurdeklarationen bestehen aus einem Prozedurkopf, der angibt,
welche formalen Parameter und welchen Resultattyp\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Der Resultattyp wird nur
bei Funktionsprozeduren angegeben.
.nE
\& die Prozedur besitzt
und einem Rumpf, der lokale Deklarationen und Anweisungen enth\(a:lt.
\%Modula-2 kennt drei Arten von formalen
Parametern: neben den von \%Pascal her bekannten Wert- und
Referenzparametern gibt es noch sogenannte offene Felder. Offene Felder sind
eindimensionale Felder, deren Feldgrenzen bei der Parameterdeklaration nicht
festgelegt werden. Dadurch k\(o:nnen Felder unterschiedlicher Gr\(o:\(sse
von einer Prozedur bearbeitet werden. In \%Modula-2
k\(o:nnen beliebige Objekte lokal zu einer Prozedur deklariert werden. Das
bedeutet insbesondere, da\(ss auch Prozedurdeklarationen geschachtelt werden
k\(o:nnen. Prozeduren k\(o:nnen auch rekursiv aufgerufen werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein (lokaler) Modul besteht im wesentlichen aus einer Reihe von
Deklarationen und einer Anweisungsfolge. Die Anweisungsfolge dient der
Initialisierung von lokalen Objekten. Grunds\(a:tzlich sind innerhalb des Moduls
deklarierte Objekte au\(sserhalb unsichtbar und umgekehrt sind au\(sserhalb
deklarierte Objekte innerhalb des Moduls unsichtbar. Durch Import- bzw.
Exportanweisungen kann der Programmierer die Sichtbarkeit von Objekten explizit
kontrollieren und Objekte innerhalb/au\(sserhalb des Moduls sichtbar werden
lassen. Moduln erm\(o:glichen es also, zusammengeh\(o:rige Daten und Operationen
zusammenzufassen und gegen\(u:ber anderen Programmteilen abzugrenzen. Die Import-
bzw Exportanweisungen bilden dabei die Schnittstellen des Moduls nach au\(ssen.
Ein Definitionsmodul ist im Prinzip nichts anderes, als die (erweiterte)
Exportliste des zugeh\(o:rigen Implementierungsmoduls.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Neben den \(u:blichen arithmetischen, logischen und relationalen
Operatoren sowie Operatoren zum Zugriff auf strukturierte Variablen besitzt
\%Modula-2 auch Operatoren zur Manipulation von Mengen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Anweisungen von \%Modula-2 sind: Zuweisung,
bedingte Anweisung, Fallunterscheidung, verschiedene Schleifenkonstrukte,
Schleifenausgangsanweisung,
R\(u:ckkehranweisung und Prozeduraufruf.
In \%Modula-2 k\(o:nnen auch beliebig strukturiete Objekte als Ganzes
zugewiesen werden. Eine Sprunganweisung
existiert in \%Modula-2 nicht. Eine Spezialit\(a:t von \%Modula-2 (und
\%Pascal) ist die WITH-Anweisung, die es erm\(o:glicht, auf Komponenten
von Verbunden
ohne Qualifikation durch den Namen des Verbundes zuzugreifen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 bietet eine Reihe von M\(o:glichkeiten, die f\(u:r eine
,,maschinennahe'' Programmierung notwendig sind. Insbesondere k\(o:nnen die Regeln
der strengen Typisierung umgangen und die Adressen von beliebigen Variablen
bestimmt werden. Die meisten dieser M\(o:glichkeiten
sind Datentypen und Prozeduren, die im vordefinierten Pseudomodul \%SYSTEM
enthalten sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\%Modula-2 erlaubt die Spezifikation von quasiparallelen Prozessen
mit Hilfe von Koroutinen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Definition der Ein- und Ausgabe sowie der Datei- und
Speicherverwaltung sind nicht Teil der Sprachdefinition von \%Modula-2.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Die Zielsprache C\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Die Zielsprache C
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Sprache C [Kernighan\|78] wurde zu Beginn der siebziger Jahre
von D. Ritchie f\(u:r die
Entwicklung des UNIX-Betriebssystems entworfen und implementiert. C ist eine
relativ maschinennahe Sprache, die sich besonders f\(u:r die Entwicklung von
Betriebssystemen und anderen hardwarenahen Systemteilen eignet. Es wurden aber
auch zahlreiche \(U:bersetzer und umfangreiche Anwendungssoftware wie z.B.
Datenbankanwendungen in C implementiert. Die folgende Aufz\(a:hlung soll einen
kurzen \(U:berblick \(u:ber die Sprache C geben, sofern sie f\(u:r diese Arbeit
relevant ist:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein C-Programm besteht aus einer Reihe von Quelldateien (Moduln), die
eine Folge von Typ-, Daten- und Funktionsdeklarationen enthalten und vom
C-\(U:bersetzer getrennt \(u:bersetzt werden k\(o:nnen. Im Gegensatz zu
\%Modula-2 werden vom C-\(U:bersetzer aber keinerlei Pr\(u:fungen \(u:ber die
Grenzen der einzelnen Quelldateien hinweg vorgenommen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der C-Pr\(a:prozessor, welcher ein Teil der Sprachdefinition von C ist,
ist ein Makroprozessor, der Textersatz vornehmen, Dateien in eine Quelldatei
einf\(u:gen und Teile eines Programms von der \(U:bersetzung ausschlie\(ssen kann.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&In C m\(u:ssen alle Objekte vor ihrer Anwendung deklariert werden. Es
besteht jedoch die M\(o:glichkeit von Vorw\(a:rtsdeklarationen und von sogenannten
\fIextern\fP\^-Deklarationen, mit deren Hilfe in anderen Quelldateien deklarierte
Objekte bekannt gemacht werden k\(o:nnen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C kennt eine einfache Art von Blockstruktur: Variablen k\(o:nnen innerhalb
von Funktionen in Bl\(o:cken deklariert werden und verdecken globale Objekte bzw.
Variablen in umfassenden Bl\(o:cken mit dem gleichen Namen. Funktionen k\(o:nnen
jedoch nicht lokal in einer anderen Funktion deklariert werden, d\(u:rfen also
nicht statisch geschachtelt sein.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Lebensdauer bzw. Sichtbarkeit von Objekten werden in C u.a. durch ihre
Speicherklasse festgelegt. Lokale Variablen von Funktionen k\(o:nnen dabei
folgende Speicherklassen haben:
.sp 0.1vv
.if \n(.nu<4n .sp -0.1vv
.nr a2 0
.af a2 a
.br
.ne 2v
\&\fIstatic:\fP
.in +12n
.if \w'\fIstatic:\fP\ 'u<12n .sp -1v
\&Lebensdauer entspricht der Programmdauer. Dies
entspricht den \fIown\fP\^-Va\%ria\%blen von \%Algol.
.in -12n
.br
.ne 2v
\&\fIauto:\fP
.in +12n
.if \w'\fIauto:\fP\ 'u<12n .sp -1v
\&Variablen liegen auf dem Keller. Lebensdauer von
Block\%ein- bis Block\%aus\%tritt.
.in -12n
.br
.ne 2v
\&\fIregister:\fP
.in +12n
.if \w'\fIregister:\fP\ 'u<12n .sp -1v
\&Lebensdauer wie \fIauto\fP\^-Objekte, diese sollen aber nach
M\(o:glichkeit vom \(U:bersetzer in einem Register abgelegt werden.
.in -12n
.sp 0.1vv
Die Lebensdauer von globalen Variablen ist die gesamte Programmdauer. Die
Angabe der Speicherklasse \fIstatic\fP verhindert bei globalen Objekten, da\(ss sie
au\(sserhalb der sie enthaltenden Quelldatei sichtbar sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C ist keine streng typisierte Sprache. F\(u:r arithmetische Typen ist eine
gro\(sse Zahl von impliziten Typumwandlungen definiert. Neben impliziten
Typumwandlungen sind auch explizite Konvertierungen m\(o:glich. Zuweisungen
zwischen Zeigern verschiedenen Typs sind ebenfalls m\(o:glich. Die Grundtypen von
C sind: Zeichen, ganze und reelle Zahlen mit verschiedenem
Speicherbedarf. Die zusammengesetzten Datentypen von C sind: Zeiger, Vektoren
(Felder), Strukturen (Verbunde)\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ In der deutschsprachigen Fachliteratur
haben sich die Begriffe Vektor
und Struktur f\(u:r die entsprechenden C-Datenstrukturen eingeb\(u:rgert.
.nE
\&,
Varianten und Aufz\(a:hlungen. Eine Variante ist eine
Struktur, bei der sich die Komponenten \(u:berlagern. Es handelt sich also um
eine eingeschr\(a:nkte Art von variantem Verbund.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Funktionsdeklaration besteht aus dem Ergebnistyp
der Funktion, der Deklaration der Parameter und aus
lokalen Deklarationen und
Anweisungen in Form eines Blocks. Wie bereits erw\(a:hnt k\(o:nnen
Funktionsdeklarationen nicht geschachtelt werden. Als Hauptprogramm fungiert
die Funktion \fImain\fP. Die Parameter\(u:bergabe erfolgt durch Wert\(u:bergabe
(\fIcall by value\fP). Bei Vektoren wird ein Zeiger auf den Anfang des
Vektors \(u:bergeben (\fIcall by reference\fP). Funktionen k\(o:nnen auch
rekursiv aufgerufen werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C besitzt eine gro\(sse Zahl von Operatoren. Die wichtigsten dieser
Operatoren sind: Arithmetische, logische und relationale Operatoren, Operatoren
zur Selektion von Komponenten strukturierter Variablen und
Operatoren zur Bitmanipulation.
Dar\(u:berhinaus gibt es noch eine Reihe von speziellen Operatoren wie
bedingte Ausdr\(u:cke oder Inkrement- und Dekrementoperatoren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Anweisungen von C sind: Zuweisung, Sprunganweisung, bedingte
Anweisung, Fallunterscheidung, verschiedene Schleifenkonstrukte,
Schleifenausgangsanweisung, R\(u:ckkehranweisung und Prozeduraufruf.
Die Zuweisung ist allerdings eingeschr\(a:nkt: Vektoren k\(o:nnen nicht als Ganzes
zugewiesen werden und Strukturen nur bei neueren Implementierungen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C besitzt einen Adre\(ssoperator, mit dem die Adressen s\(a:mtlicher
Objekte bestimmt werden k\(o:nnen. Insbesondere kann man auch die Adressen von
Funktionen bestimmen und diese dann sp\(a:ter \(u:ber diese Adressen aufrufen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Vergleich\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Vergleich
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Beim Vergleich von \%Modula-2 und C zeigt sich, da\(ss C, trotz der auch in
\%Modula-2
vorhandenen M\(o:glichkeiten zur ,,maschinennahen'' Programmierung, die
maschinenn\(a:here Sprache ist. \%Modula-2 besitzt ein deutlich h\(o:heres
Abstraktionsniveau und an vielen Punkten m\(a:chtigere Ausdrucksmittel.
Allerdings besteht, wenn man von den Koroutinen einmal absieht, die
M\(o:glichkeit in C nicht direkt vorhandene Modula-Konstrukte
durch eine Kombination von
primitiveren C-Konstrukten zu realisieren. So k\(o:nnen z.B. die Mengen von
\%Modula-2 in C mit Hilfe der Operatoren zur
Bitmanipulation realisiert
werden.
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Punkte erfordern bei der Abbildung besonderen Aufwand:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C kennt kein Modulkonzept, welches dem von \%Modula-2 vergleichbar
w\(a:re. Insbesondere existieren keine den opaquen Typen und den
lokalen Moduln entsprechenden Konzepte.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Regeln hinsichtlich G\(u:ltigkeit und Sichtbarkeit von Bezeichnern
weisen eine Reihe von Unterschieden auf, z.B. verlangt C im Gegensatz zu
\%Modula-2, da\(ss alle Objekte immer vor ihrer Anwendung deklariert werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die zusammengesetzten Typen von C sind weniger m\(a:chtig als die
zusammengesetzten Typen von \%Modula-2. Besondere
Schwierigkeiten
bereitet, da\(ss
sich die
Behandlung von Vektoren von der Behandlung anderer Variablen unterscheidet.
Auch die eingeschr\(a:nkte Form von varianten Verbunden in C erfordert eine
besondere Behandlung.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Da C im Gegensatz zu \%Modula-2 keine geschachtelten
Funktionsdeklarationen kennt, mu\(ss die in \%Modula-2 vom \(U:bersetzer
vorgenommene Verwaltung der Prozedurschachteln zum Zugriff auf die lokalen
Variablen von statisch umfassenden Prozeduren (Verweis auf den statischen
Vorg\(a:nger) auf geeignete Art und Weise mit Hilfe von C-Code vorgenommen
werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C kennt kein den offenen Feldern entsprechendes Konzept der
Parameter\(u:bergabe.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Abgesehen von den oben genannten Punkten kann ein gro\(sser Teil der
Deklarationen sowie die meisten Anweisungen und Ausdr\(u:cke ohne gro\(sse Probleme
direkt nach C \(u:bersetzt werden. Allerdings zeigt es sich bei der im
folgenden Kapitel
beschriebenen Abbildung, da\(ss manchmal auch schon kleine semantische
Unterschiede, bei sich direkt entsprechenden Sprachkonstrukten, die Abbildung
deutlich verkomplizieren k\(o:nnen.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Abbildung von Modula-2 nach C\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Abbildung von Modula-2 nach C
.hE 0 4n 0.1v
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Grundlagen der Abbildung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Grundlagen der Abbildung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Bevor man eine Abbildung von Modula-2 nach C definieren kann,
mu\(ss man zun\(a:chst kl\(a:ren, welche Definition der beiden Sprachen
als Basis f\(u:r diese Abbildung verwendet werden soll.
Die wichtigsten Gr\(u:nde daf\(u:r sind:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Seit ihrer Entstehung unterlagen beide Sprachen einer gewissen
Evolution: manche Sprachelemente wurden ver\(a:ndert, andere sind neu
hinzugekommen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Verschiedene Implementierungen unterscheiden sich fast immer
in einigen Details.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die vorhandenen Sprachdefinitionen sind nicht in allen Punkten
v\(o:llig eindeutig.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Zur Zeit wird zwar f\(u:r beide Sprachen an einer
standardisierten Sprachversion gearbeitet, aber zum einen liegen
diese Standards bisher noch nicht endg\(u:ltig vor, zum anderen d\(u:rfte nach
dem Vorliegen der Standards noch einige Zeit vergehen, bis \(U:bersetzer
verf\(u:gbar sind, die sie implementieren. Das Vorgehen in dieser
Abbildung orientiert sich daher am geplanten Einsatz des 
\(U:bersetzers: \(U:bertragung von mit dem Karlsruher Modula-\(U:bersetzer
\%MOCKA
unter dem UNIX-Betriebssystem
entwickelten Programmen nach C.
.sp 0.4v
.ne 2v
.ti +2n
\%MOCKA implementiert die Sprache \%Modula-2 im
wesentlichen so, wie sie von N. Wirth [Wirth\|85] definiert wurde.
Diese Definition bildet, neben dem
MOCKA-Benutzerhandbuch [Engelmann\|87], die
Ausgangsbasis der Abbildung, die dar\(u:berhinaus auch die
meisten von \%MOCKA vorgenommenen Spracherweiterungen
ber\(u:cksichtigt. Insbesondere die Abbildung der Grundtypen, die
zugrundegelegten Regeln hinsichtlich Typkompatibilit\(a:t und die
Behandlung von Mengen orientiert sich an der Implementierung von \%MOCKA.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r die Sprache C wurde die deutsche \(U:bersetzung der bereits etwas \(a:lteren
Sprachbeschreibung von B.W. Kernighan und D. Ritchie
[Kernighan\|78, Kernighan\|83] als Ausgangsbasis gew\(a:hlt.
Es werden jedoch auch einige
Sprachelemente wie z.B. Zuweisung von Strukturen als Ganzes verwendet,
die zum damaligen Zeitpunkt noch nicht in allen Implementierungen
verf\(u:gbar waren.
Die gestellte Mindestanforderung an die erzeugten C-Programme ist,
da\(ss sie von den an der GMD Forschungsstelle Karlsruhe verf\(u:gbaren
C-\(U:bersetzern der Firmen \%SUN und \%PCS
akzeptiert werden.
.sp 0.4v
.ne 2v
.ti +2n
In der folgenden Beschreibung der Abbildung
wird an den entsprechenden Stellen auf m\(o:glicherweise
implementierungsabh\(a:ngige Annahmen besonders hingewiesen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Programmrepr\(a:sentation\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Programmrepr\(a:sentation
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die erzeugten C-Programme werden zur Erh\(o:hung der Lesbarkeit durch
geeignete Einr\(u:ckungen und Verwendung von Zwischenr\(a:umen formatiert.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Bezeichner\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Bezeichner
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die m\(o:glichen Modula-Bezeichner bilden eine Teilmenge der m\(o:glichen
C-Bezeichner, insbesondere werden in beiden Sprachen Gro\(ss- und
Kleinbuchstaben unterschieden. Die Bezeichner k\(o:nnen daher in der Regel
direkt aus dem Modula-Programm in das C-Programm \(u:bernommen werden.
Um Namenskonflikte im erzeugten C-Programm
zu vermeiden, ist es jedoch in den folgenden F\(a:llen notwendig, den Bezeichner
durch das Hinzuf\(u:gen eines Pr\(a:fix umzubenennen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner ist ein Schl\(u:sselwort der Sprache C.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner wird bereits f\(u:r ein vom \(U:bersetzer vordefiniertes
Objekt verwendet.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Aufgrund der unterschiedlichen Regeln hinsichtlich des
G\(u:ltigkeitsbereichs von Bezeichnern oder durch eine f\(u:r die Abbildung
nach C notwendige Transformation des Modula-Programms
w\(u:rde ein Namenskonflikt entstehen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Der Pr\(a:fix hat die Form \%\fIC_nnn_\fP\^, wobei \%\fInnn\fP f\(u:r eine
eindeutige Nummer steht. Die Abk\(u:rzungen \%\fInnn\fP und \%\fIxxx\fP
werden im folgenden f\(u:r die Bezeichnung von vom \(U:bersetzer vergebenen
Nummern benutzt.
.sp 0.4v
.ne 2v
.ti +2n
Es sei an dieser Stelle darauf verwiesen, da\(ss bei \(a:lteren
C-\(U:bersetzern zur Unterscheidung von Bezeichnern h\(a:ufig nur
wenige Zeichen verwendet werden. Da aber bei neueren C-\(U:bersetzern
hier meistens keine Restriktionen mehr bestehen, wird dies bei der
Abbildung nicht ber\(u:cksichtigt.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Numerische Konstanten\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Numerische Konstanten
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die ganzzahligen Konstanten von \%Modula-2 werden gem\(a:\(ss der folgenden
Tabelle mit regul\(a:ren Ausdr\(u:cken nach C \(u:bersetzt:
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
ce| ce
lefTT| lefTT.
Modula-2|C
_
[0-9]+|[0-9]+
[0-7]+ B|0 [0-7]+
[0-7]+ C|(unsigned char) '\e[0-7]+'
[0-9] [0-9A-F]* H|0X [0-9] [0-9A-F]*
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.1\fP: Abbildung von ganzzahligen Konstanten
.ce 0
.sp 1.5
.zE
Bei den dezimalen Konstanten m\(u:ssen f\(u:hrende Nullen
entfernt werden, da sie sonst in C als oktale Konstanten
interpretiert werden.
.sp 0.4v
.ne 2v
.ti +2n
Ganzzahlige Konstanten haben in C den Typ \fIint\fP oder \fIlong\fP, d.h.
sie werden als ganze Zahl mit Vorzeichen interpretiert. \%Modula-2
definiert, da\(ss eine ganzzahlige Konstante \fIn\fP, deren Wert im Bereich
\%MAX\^(INTEGER)\ <\ \fIn\fP\ \(<=\ MAX\^(CARDINAL)
liegt, den Typ \%CARDINAL hat, d.h. \fIn\fP wird als ganze Zahl ohne
Vorzeichen interpretiert.
Bei einer direkten \(U:bersetzung einer solchen Konstanten entsprechend der obigen
Tabelle nach C, w\(u:rde das dazugeh\(o:rige Bitmuster vom C-\(U:bersetzer als
negative Zahl interpretiert. Daher wird einer solchen Konstanten in C eine
explizite Typumwandlung in den Typ \%\fIunsigned\ long\fP vorangestellt,
um eine korrekte Interpretation als ganze Zahl ohne Vorzeichen durch den
C-\(U:bersetzer zu erzwingen.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r Zeichenkonstanten der Form \%[0-7]+\ C existiert ein \(a:hnliches
Problem. \%MOCKA erlaubt Zeichenkonstanten \fIc\fP im Bereich
\%0\ \(<=\ \fIc\fP\ \(<=\ 255.
In C haben Zeichenkonstanten den Typ \%\fIchar\fP. Werden C-Zeichenkonstanten
oder -variablen z.B. in relationalen Ausdr\(u:cken verwendet, so werden sie
zun\(a:chst implizit in den Typ \%\fIint\fP umgewandelt. Diese
Umwandlung ist maschinenabh\(a:ngig. Eine Zeichenkonstante, deren Wert als
oktales Bitmuster definiert ist, kann dabei negativ erscheinen. Der
Modula-Ausdruck
\%0C\ <\ 377C
ist immer wahr,
der C-Ausdruck
\%'\e0'\ <\ '\e377'
ist dagegen, abh\(a:ngig von der jeweiligen Maschine, wahr oder falsch.
Um diese Fehlinterpretation zu vermeiden, wird, wie der obigen Tabelle zu
entnehmen ist, solchen Zeichenkonstanten in C eine explizite Typumwandlung
in den Typ
\%\fIunsigned\ char\fP vorangestellt, was zur Folge hat, da\(ss bei einer
impliziten Typumwandlung in den Typ \%\fIint\fP kein negativer Wert mehr
entstehen kann.
.sp 0.4v
.ne 2v
.ti +2n
Im Modula-Programm enthaltene Gleitpunktkonstanten k\(o:nnen textuell
in das erzeugte C-Programm eingesetzt werden, da die in \%Modula-2
zul\(a:ssigen Gleitpunktkonstanten eine Teilmenge der in C
zul\(a:ssigen Gleitpunktkonstanten darstellen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Zeichenketten\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Zeichenketten
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung von Zeichenketten h\(a:ngt davon ab, wie sie im
Modula-Programm verwendet werden. Dabei mu\(ss insbesondere
folgendes beachtet werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Zeichenkette der L\(a:nge n ist in \%Modula-2 vom Typ
\%ARRAY\ [\^0\^..\^n\^-1\^]\ OF\ CHAR.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Zeichenkette der L\(a:nge 1 ist in \%Modula-2
kompatibel mit dem Typ \%CHAR.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&In C wird eine Zeichenkette als initialisierter Vektor von
Zeichen betrachtet, der am Ende ein zus\(a:tzliches NUL-Zeichen enth\(a:lt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C unterscheidet zwischen Zeichenkonstanten und Zeichenketten der
L\(a:nge 1.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Bei der Abbildung wird daher folgenderma\(ssen vorgegangen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine Zeichenkette der Sprache Modula-2 mit L\(a:nge \%n\ >\ 1
wird auf eine Zeichenkette der Sprache C abgebildet.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Falls eine Zeichenkette der L\(a:nge 1 in einem Kontext benutzt wird,
in dem ein Ausdruck vom Typ CHAR erwartet wird, dann wird sie auf eine
C-Zeichenkonstante abgebildet. Wird diese Zeichenkette jedoch in einem Kontext
benutzt, in dem ein Ausdruck vom Typ
\%ARRAY\ [\^0\^..\^0\^]\ OF\ CHAR
erwartet wird, dann wird sie zu einer C-Zeichenkette.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Zeichen m\(u:ssen in C
innerhalb von Zeichenketten und -konstanten durch das
Fluchtsymbol\ \e\ maskiert werden:\ \ \e\ \ '\ \ ".
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Kommentare\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Kommentare
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Kommentare im Modula-Programm k\(o:nnten auf C-Kommentare abgebildet
werden, wobei ber\(u:cksichtigt werden m\(u:\(sste, da\(ss C keine geschachtelten
Kommentare kennt. Da aber in Modula-2 Kommentare an jeder beliebigen Stelle des
Programms stehen k\(o:nnen und es keine allgemeinen Regeln bez\(u:glich der
Zuordnung von Kommentaren zu Programmstellen gibt, w\(u:rde im erzeugten
C-Programm \(em bei jeder f\(u:r diese Zuordnung gew\(a:hlten L\(o:sung \(em
ein erheblicher
Teil der Kommentare an die falschen Programmstellen plaziert. Daher ist
es sinnvoller auf die Kommentare im C-Programm v\(o:llig zu verzichten.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&G\(u:ltigkeit und Sichtbarkeit\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&G\(u:ltigkeit und Sichtbarkeit
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Regeln bez\(u:glich G\(u:ltigkeit und Sichtbarkeit von Bezeichnern
in \%Modula-2 und C weisen eine Reihe von Unterschieden auf, die bei der
Abbildung ber\(u:cksichtigt werden m\(u:ssen.
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 erm\(o:glicht es durch das Modulkonzept den G\(u:ltigkeitsbereich
bzw. die Sichtbarkeit
von in globalen oder lokalen Moduln\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Ein globaler Modul ist ein
Programmodul oder er besteht aus einem Definitions- und einem
Implementierungsmodul.
.nE
\&
vereinbarten Bezeichnern mit
Import- bzw. Exportanweisungen explizit zu kontrollieren. Au\(sserdem
kann man, insbesondere zur Vermeidung von Namenskonflikten, importierte
Bezeichner durch den Namen des sie exportierenden Moduls qualifizieren.
C hat kein vergleichbares Modulkonzept. Die einzige in C vorhandene
M\(o:glichkeit zur expliziten Kontrolle des G\(u:ltigkeitsbereichs von Bezeichnern
ist, die Sichtbarkeit von globalen Objekten durch Angabe der
Speicherklasse \%\fIstatic\fP auf die sie enthaltende Quelldatei zu
beschr\(a:nken. Daher wird bei der Abbildung nach C wie folgt vorgegangen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle von globalen Moduln exportierten Bezeichner werden in den
C-Programmen in der qualifizierten Form \%\fIModulname_Bezeichner\fP geschrieben,
um Namenskonflikte zu vermeiden. Eine Qualifikation nur bei Namenskonflikten
ist nicht mit einer getrennten \(U:bersetzung von globalen Moduln nach C
vereinbar.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&In lokalen Moduln deklarierte Bezeichner werden
in unqualifizierter Form geschrieben. Sie m\(u:ssen durch einen
Pr\(a:fix umbenannt werden, falls bei der Abbildung der lokalen Moduln nach
C Namenskonflikte entstehen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle globalen Funktionen und Variablen, die nicht
exportiert werden, werden in C in der Speicherklasse \%\fIstatic\fP vereinbart,
um ihre Sichtbarkeit auf die sie enthaltende Quelldatei zu beschr\(a:nken.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 erlaubt, da\(ss ein Bezeichner in einer Anweisung verwendet
wird, die textuell der Deklaration des Bezeichners vorausgeht; dies ist in C
nicht zul\(a:ssig\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Einzige Ausnahme: Funktionen die ein Resultat vom Typ \fIint\fP
liefern.
.nE
\&.
Dieses Problem wird folgenderma\(ssen gel\(o:st:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle Prozedurdeklarationen werden an das Ende des sie enthaltenden
Deklarationsteils verschoben. Abgesehen von dieser Verschiebung bleibt
die urspr\(u:ngliche Reihenfolge der Deklarationen erhalten. Damit erfolgen
alle Konstanten-, Variablen- und Typdeklarationen vor ihrer ersten Verwendung
in einer Anweisung.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle Prozeduren, die vor
ihrer Vereinbarung verwendet werden, m\(u:ssen im C-Programm vor ihrer
ersten Benutzung durch eine Deklaration der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
Speicherklasse  Ergebnistyp  Prozedurname  ();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
bekannt gemacht werden. Eine solche Deklaration \(em die einer
\fIforward\fP\^-Deklaration in \%Pascal entspricht\(em ist insbesondere
dann notwendig, wenn sich Prozeduren gegenseitig rekursiv aufrufen.
Die Speicherklasse ist \%\fIstatic\fP, falls die Prozedur nicht exportiert
wird, und \%\fIextern\fP, falls sie exportiert wird.
.in -4n
.sp 0.1vv
.sp 0.3vv
Der folgende Ausschnitt eines Modula-Programms
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
PROCEDURE Expr;
BEGIN
  Term;
  WHILE Token = "+" DO
    Token := GetToken ();
    Term;
  END;
END Expr;
.sp 0.4v
.br
.ne 3
PROCEDURE Term;
BEGIN
  Factor;
  ...
.sp 0.4v
.br
.ne 3
PROCEDURE Factor;
BEGIN
  CASE Token OF
  | "(" : Token := GetToken (); Expr;
  ...
VAR  Token : CHAR;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
CHAR Token;
.sp 0.4v
extern void Term   ();
extern void Factor ();
.sp 0.4v
.br
.ne 3
void Expr()
{
    Term();
    while (Token == '+') {
        Token = GetToken();
        Term();
    }
}
.sp 0.4v
.br
.ne 3
void Term()
{
    Factor();
  ...
.sp 0.4v
.br
.ne 3
void Factor()
{
    switch (Token) {
    case '(' :
        Token = GetToken(); Expr();
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 verlangt, da\(ss in Deklarationen verwendete Bezeichner vor ihrer
ersten Anwendung vereinbart werden. Um jedoch die Definition von
,,rekursiven'' Typen zu erm\(o:glichen, kann bei der Deklaration von
Zeigertypen der Name des Bezugstyps vor seiner Deklaration verwendet werden.
Das folgende Beispiel zeigt eine solche ,,rekursive'' Definition:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  tTree = POINTER TO tNode;
  tNode = RECORD
             Key   : INTEGER;
             Left  ,
             Right : tTree;
          END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Da C die Verwendung von Strukturnamen erlaubt, bevor eine vollst\(a:ndige
Definition der Struktur vorliegt, kann die obige Definition durch
Einf\(u:hrung eines Strukturnamens nach C \(u:bersetzt werden:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef struct S_1 *tTree;
.sp 0.4v
typedef struct S_1 {
    INTEGER Key;
    tTree   Left, Right;
} tNode;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Ist der Bezugstyp kein Verbund, so ist eine Abbildung nach C nur mit
erheblichem Aufwand m\(o:glich. Eine allgemeine L\(o:sung k\(o:nnte
folgenderma\(ssen aussehen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Handelt es sich nicht um eine ,,rekursive'' Typdeklaration,
dann werden die Deklarationen derart umgeordnet, da\(ss alle Vereinbarungen der
beteiligten Typen vor ihrer ersten Anwendung erfolgen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Dies entspricht
einer topologischen Sortierung des gerichteten Graphen, der durch die
Relation ,,wird verwendet zur Deklaration von'' definiert wird.
.nE
\&.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Handelt es sich um eine ,,rekursive'' Typdeklaration, dann m\(u:ssen
einige oder alle der beteiligten Typen in C zu einer Struktur gemacht werden.
Die folgende Deklaration
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  tPointer1 = POINTER TO tPointer2;
  tPointer2 = POINTER TO tPointer1;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
w\(u:rde dann in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef struct S_2 *tPointer1;
.sp 0.4v
typedef struct S_2 {
    tPointer1 *X;
} tPointer2;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Diese L\(o:sung ist jedoch mit einem erheblichen \(U:bersetzungsaufwand
verbunden. Dar\(u:berhinaus mu\(ss man ber\(u:cksichtigen, da\(ss
Zeigerdeklarationen, in denen der Bezugstyp erst nach dem Zeigertyp
definiert wird, in der Praxis haupts\(a:chlich zur Definition von
Listen, B\(a:umen oder \(a:hnlichen Datenstrukturen verwendet werden. In diesen
F\(a:llen ist der Bezugstyp aber fast immer ein Verbund.
Aus diesen Gr\(u:nden ist es sinnvoller, Modula-Programme, die solche
Typdeklarationen
enthalten, nur dann nach C zu \(u:bersetzen, wenn der Bezugstyp ein
Verbund ist.
.sp 0.4v
.ne 2v
.ti +2n
Symbolische Konstanten werden in C mit Hilfe der \fI#define\fP\^-Anweisung des
C-Pr\(a:prozessors vereinbart.
Bei der Abbildung mu\(ss ber\(u:cksichtigt werden, da\(ss
der G\(u:ltigkeitsbereich eines mit \%\fI#define\fP vereinbarten Makros
der gesamte Rest der Quelldatei ist.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r mit \%\fItypedef\fP vereinbarte Typnamen gilt laut C-Sprachbeschreibung
die \(u:bliche Blockstruktur von C. Das hei\(sst eine Deklaration der Art
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef char tType;
  ...
{
    typedef int tType;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
ist eigentlich zul\(a:ssig. Viele C-\(U:bersetzer sind jedoch nicht in der
Lage, eine derartige Deklaration zu verarbeiten.
.sp 0.4v
.ne 2v
.ti +2n
Die oben genannten Einschr\(a:nkungen f\(u:r die mehrfache
Verwendung von Konstanten- und Typnamen werden bei der
\(U:bersetzung
dadurch gel\(o:st, da\(ss die Namen von Konstanten und Typen
durch eine Umbenennung innerhalb einer Quelldatei eindeutig
gemacht werden.
.br
.ne 4
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Deklarationen\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Deklarationen
.hE 4n 5n 0v
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Konstantendeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Konstantendeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung von Konstantendeklarationen ist abh\(a:ngig von der Art
der Konstante.
.sp 0.4v
.ne 2v
.ti +2n
Eine Konstante, deren Wert eine Zeichenkette mit L\(a:nge
\%n\ >\ 1 ist, wird auf einen Vektor von Zeichen
abgebildet, der mit der angegebenen Zeichenkette initialisiert
wird. Ist der Wert der Konstante eine Zeichenkette der L\(a:nge 1, dann wird
diese Konstante im C-Programm mit einer \fI#define\fP\^-Anweisung als
Zeichenkonstante definiert. Wird diese Konstante jedoch in einem Kontext
benutzt, in dem ein Ausdruck mit Typ
\%ARRAY\ [\^0\^..\^0\^]\ OF\ CHAR
erwartet wird, dann mu\(ss der Wert der Konstante als Zeichenkette direkt
f\(u:r den Konstantennamen eingesetzt werden.
.sp 0.4v
.ne 2v
.ti +2n
Alle \(u:brigen im Modula-Programm vereinbarten Konstanten werden im
erzeugten C-Programm mit einer \fI#define\fP\^-Anweisung
vereinbart. Konstante
Ausdr\(u:cke werden dabei auf die entsprechenden C-Ausdr\(u:cke abgebildet,
wenn der Ausdruck auch in C einen konstanten Ausdruck bildet.
Konstante Ausdr\(u:cke, die logische Operatoren, einen in C als Funktion
definierten Operator oder eine in C als Funktion definierte Standardfunktion
enthalten, sind in C nicht mehr konstant.
Solche Ausdr\(u:cke werden bei der \(U:bersetzung ausgewertet und der Wert des
Ausdrucks wird f\(u:r den Ausdruck eingesetzt. Diese Unterscheidung ist
notwendig, damit benannte Konstanten in C f\(u:r Fallmarken von
\fIswitch\fP\^-Anweisungen und zur Dimensionierung von Vektoren verwendet werden
k\(o:nnen. Die Alternative, konstante Ausdr\(u:cke immer schon bei der
\(U:bersetzung auszuwerten, vermindert die Lesbarkeit der erzeugten Programme
und wurde daher verworfen.
Somit werden die folgenden Deklarationen
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CONST
  Message       = "hello world";
  BitsPerBitset = SIZE (BITSET) * 8;
  EmptySet      = {};
  MaxToken      = 63;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CHAR Message[] = "hello world";
.sp 0.4v
#define BitsPerBitset   (sizeof(BITSET) * 8)
#define EmptySet        0XL
#define MaxToken        63
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Eine Auswertung von konstanten Ausdr\(u:cken bei der \(U:bersetzung nach C
ist in den meisten F\(a:llen
problemlos m\(o:glich. Die von \%MOCKA
gemachte Einschr\(a:nkung, da\(ss konstante Ausdr\(u:cke keine Standardfunktionen
enthalten d\(u:rfen, wird dabei fallengelassen. Schwierigkeiten bereitet
aber die Auswertung der Funktionen \%SIZE, \%TSIZE, \%MAX
und \%MIN, da diese sowohl von der Abbildung der Typen nach C
als auch von der Typabbildung des verwendeten C-\(U:bersetzers abh\(a:ngen. Dieses
Problem wird folgenderma\(ssen gel\(o:st:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der \(U:bersetzer enth\(a:lt eine Tabelle, in der vermerkt ist, welche
Gr\(o:\(sse die Grund-, Standard-, Aufz\(a:hlungs-, Mengen- und Zeigertypen in C haben. Die
obigen Standardfunktionen k\(o:nnen f\(u:r diese Typen mit Hilfe der Tabelle
ausgewertet werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Feld- oder Verbundtypen als Argumente sind nicht zul\(a:ssig, da dazu
die genaue Typabbildung des C-\(U:bersetzers, insbesondere die m\(o:glicherweise
notwendige Ausrichtung von Strukturkomponenten, bekannt sein m\(u:\(sste.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da der C-Pr\(a:prozessor Textersatz vornimmt, wird der Wert aller mit
\%\fI#define\fP vereinbarten Konstanten im C-Programm textuell
f\(u:r den Konstantennamen eingesetzt. Deshalb ist es nicht sinnvoll,
Zeichenketten mit \%\fI#define\fP zu vereinbaren, denn in einem
C-Programm sind alle Zeichenketten verschieden, selbst wenn sie aus der
gleichen Zeichenfolge bestehen. Das bedeutet, da\(ss das erzeugte Objektprogramm
bei mehrfacher Anwendung eines mit \%\fI#define\fP vereinbarten
Konstantennamens die zugeh\(o:rige Zeichenkette
ebenfalls mehrfach enthalten w\(u:rde. Die Deklaration als initialisierter
Vektor vermeidet dies.
.sp 0.4v
.ne 2v
.ti +2n
Wird der Wert der Modula-Konstante durch einen konstanten Ausdruck
spezifiziert, mu\(ss bei der Abbildung nach C noch folgendes beachtet
werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Ausdruck mu\(ss, wegen des vom C-Pr\(a:prozessor vorgenommenen
Textersatzes, geklammert werden, um eine korrekte Auswertungsreihenfolge
zu garantieren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Falls der Ersatztext Namen enth\(a:lt, die nicht selbst als Makros
vereinbart sind, mu\(ss darauf geachtet werden, da\(ss nicht auf subtile Art
und Weise im C-Programm Namenskonflikte entstehen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Konstante Ausdr\(u:cke werden vom C-\(U:bersetzer bereits bei der
\(U:bersetzung des C-Programms ausgewertet.
.in -4n
.sp 0.1vv
.sp 0.3vv
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Typdeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Typdeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die im Modula-Programm vereinbarten Typen werden im erzeugten C-Programm
mittels einer \fItypedef\fP\^-Anweisung vereinbart.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Typkompatibilit\(a:t\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Typkompatibilit\(a:t
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die von \%MOCKA implementierten Regeln
hinsichtlich Typ- und Zuweisungskompatibilit\(a:t, die weniger streng sind,
als die
in der Sprachbeschreibung von \%Modula-2 enthaltenen, bilden die Grundlage
f\(u:r diese Abbildung. Es mu\(ss besonders darauf geachtet werden, da\(ss Typen,
die in \%Modula-2 typ- bzw. zuweisungskompatibel sind, dies auch
im erzeugten C-Programm sind. Dabei k\(o:nnen folgende Eigenschaften von C
vorteilhaft ausgenutzt werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&C definiert f\(u:r arithmetische Typen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Zu den arithmetischen Typen
geh\(o:ren in C die Typen: \%\fIchar\fP, \%\fIint\fP, \%\fIfloat\fP
und \%\fIdouble\fP. Der Typ \%\fIint\fP kann mit einer Gr\(o:\(ssenangabe
\%\fIshort\fP oder \%\fIlong\fP versehen sein. Au\(sserdem kann man
\%\fIchar\fP\^- und \fIint\fP\^-Objekte auch als
\%\fIunsigned\fP, d.h. als ganze Zahl ohne Vorzeichen,
vereinbaren.
.nE
\& eine gro\(sse Zahl von impliziten Typumwandlungen in Ausdr\(u:cken
bei der Zuweisung und der Parameter\(u:bergabe. Arithmetische Typen
k\(o:nnen daher in C fast in beliebiger Kombination verwendet werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Von den meisten C-\(U:bersetzern werden Zeichen und ganzzahlige
Werte, unabh\(a:ngig von ihrem tats\(a:chlichen Speicherbedarf, bei der
Parameter\(u:bergabe mit 4 Byte \(u:bergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der C-\(U:bersetzer erlaubt Zuweisungen zwischen Zeigern verschiedenen
Typs. Bei der \(U:bergabe von Zeigern an eine Funktion darf sich der Typ des
aktuellen Parameters vom Typ des formalen Parameters unterscheiden. Diese
Zuweisungen bzw. Parameter\(u:bergaben erfolgen als reine Kopien, ohne jede
Umwandlung. Ohne eine explizite Typumwandlung wird das Pr\(u:fprogramm
\%\fIlint\fP,
mit dem C-Programme auf semantische Fehler untersucht werden k\(o:nnen, an
diesen Stellen Typfehler melden, was aber nicht unbedingt bedeuten mu\(ss, da\(ss
die Programme wirklich fehlerhaft sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der C-\(U:bersetzer nimmt praktisch keine Typpr\(u:fungen vor.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Bei der Abbildung der nicht zusammengesetzten Typen wird darauf geachtet,
da\(ss die Gr\(o:\(sse der Typen im C-Programm wenn m\(o:glich der von \%MOCKA
f\(u:r die entsprechenden Modula-Typen vorgesehenen Gr\(o:\(sse entspricht. Mit dieser
Voraussetzung und aufgrund der oben geschilderten Eigenschaften von C sind
im erzeugten C-Programm nur an einigen wenigen Stellen explizite
Typumwandlungen notwendig, damit die C-Programme korrekt funktionieren.
Durch die Angabe einer Option bei der \(U:bersetzung von \%Modula-2 nach
C kann man \%\fIMtc\fP allerdings dazu veranlassen, weitere explizite
Typumwandlungen zu
erzeugen, die f\(u:r das korrekte Funktionieren der erzeugten C-Programme nicht
unbedingt notwendig sind und daher normalerweise wegen der damit verbundenen
schlechteren Lesbarkeit der C-Programme weggelassen werden, die aber dazu
f\(u:hren, da\(ss \%\fIlint\fP keine Typfehler mehr meldet.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Grundtypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Grundtypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Menge der vordefinierten Grundtypen von \%Modula-2, die
aus den
Typen \%INTEGER, \%CARDINAL,
\%BOOLEAN, \%CHAR, \%REAL, \%LONGREAL und \%LONGINT
besteht, ist entsprechend der von \%MOCKA implementierten Spracherweiterung
um die Grundtypen \%SHORTINT, \%SHORTCARD und \%LONGCARD
erweitert. Die Definition dieser Grundtypen ist in der Definitionsdatei
\%SYSTEM.h enthalten, die mit Hilfe einer
\fI#in\%clude\fP\^-\%An\%wei\%sung
vom C-Pr\(a:prozessor in jedes erzeugte C-Programm eingef\(u:gt wird.
Die folgende Aufz\(a:hlung zeigt die Definition
der Grundtypen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Da \%MOCKA die Typen \%INTEGER und
\%LONGINT sowie \%CARDINAL und \%LONGCARD als
synonym vereinbart, werden sie auch bei der Abbildung nach
C als synonym vereinbart.
.nE
\&:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
typedef short           SHORTINT;
typedef long            LONGINT;
typedef LONGINT         INTEGER;
.sp 0.4v
.br
.ne 3
typedef unsigned short  SHORTCARD;
typedef unsigned long   LONGCARD;
typedef LONGCARD        CARDINAL;
.sp 0.4v
.br
.ne 3
typedef unsigned char   BOOLEAN;
#define FALSE           (BOOLEAN)0
#define TRUE            (BOOLEAN)1
.sp 0.4v
typedef unsigned char   CHAR;
.sp 0.4v
.br
.ne 2
typedef float           REAL;
typedef double          LONGREAL;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Der Typ \%CHAR mu\(ss, wegen der Probleme bei der impliziten Umwandlung von
Zeichenwerten in ganzzahlige Werte (s. Kap. \n(h1.2.2), in C als
\%\fIunsigned\ char\fP und nicht als \%\fIchar\fP definiert werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Aufz\(a:hlungstypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Aufz\(a:hlungstypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die auf den ersten Blick naheliegende Abbildung von Aufz\(a:hlungstypen
ist, die Aufz\(a:hlungstypen von \%Modula-2 direkt
auf die Aufz\(a:hlungstypen von C abzubilden. Die Deklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  Color = (red, green, blue);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
w\(u:rde damit in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef enum {red, green, blue} Color;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die C-Sprachbeschreibung legt fest, da\(ss die in der Aufz\(a:hlung
genannten Namen als Konstanten vereinbart sind und \(u:berall
dort verwendet werden k\(o:nnen, wo in C Konstanten zul\(a:ssig sind.
Die Konstanten erhalten aufeinanderfolgende ganzzahlige Werte, wobei
die erste Konstante der Aufz\(a:hlung den Wert 0 hat. Viele C-\(U:bersetzer
verbieten jedoch, Aufz\(a:hlungskonstanten z.B. in Vergleichen oder
zur Indizierung von Vektoren zu verwenden. Diese Einschr\(a:nkung kann
allerdings umgangen werden, indem Aufz\(a:hlungskonstante in diesen
F\(a:llen mittels einer expliziten Typumwandlung in einen \fIint\fP\^-Wert
umgewandelt werden:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
a[(int)red] = 1;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Eine weitere Schwierigkeit ist, da\(ss eine Reihe von C-\(U:bersetzern es nicht
vertr\(a:gt, wenn eine Aufz\(a:hlungskonstante innerhalb einer Funktion lokal
neu deklariert wird. Solche Aufz\(a:hlungskonstanten m\(u:\(ssten daher umbenannt
werden.
.sp 0.4v
.ne 2v
.ti +2n
Um die oben genannten Probleme zu vermeiden, wurde folgende Abbildung
gew\(a:hlt: der Aufz\(a:hlungstyp wird entsprechend der Anzahl
von Aufz\(a:hlungskonstanten in einen \fIunsigned\fP\^-Typ geeigneter Gr\(o:\(sse
umgesetzt; die Aufz\(a:hlungskonstanten werden mit \fI#define\fP\^-Anweisungen
als symbolische Konstanten vereinbart.
F\(u:r die Namen der Aufz\(a:hlungskonstanten gilt wie f\(u:r alle mit \%\fI#define\fP
vereinbarten Konstantennamen, da\(ss sie bei Bedarf durch eine Umbenennung innerhalb
der sie enthaltenden Quelldatei eindeutig gemacht werden m\(u:ssen (s. Kap. \n(h1.3).
Die obige Deklaration wird dann zu:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define red     0
#define green   1
#define blue    2
.sp 0.4v
typedef unsigned char Color; 
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Der Vorteil dieser L\(o:sung ist, da\(ss keine Typumwandlungen mehr notwendig
sind; der Nachteil eine schlechtere Lesbarkeit der Typdeklaration.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Unterbereichstypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Unterbereichstypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Unterbereichstypen werden nach C abgebildet, indem mit Hilfe einer
\fItypedef\fP\^-Anweisung der Name des Unterbereichstyps als
synonym zum Namen des
Basistyps vereinbart wird. Ist der Basistyp
in der Deklaration des Unterbereichstyps nicht explizit angegeben,
so mu\(ss er aus dem Typ der unteren und/oder oberen Grenze des
Unterbereichstyps abgeleitet werden. Sind die untere/obere Grenze
ganzzahlige Konstanten, dann legt die Sprachbeschreibung von
\%Modula-2 fest, da\(ss der Basistyp \%INTEGER ist, falls
die untere Grenze eine negative Zahl ist, und ansonsten \%CARDINAL.
Somit werden die folgenden Deklarationen
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  TrafficLight  = [red..green];
  tToken        = [0..MaxToken];
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef Color     TrafficLight;
typedef CARDINAL  tToken;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Felder\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Felder
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Eine direkte Abbildung der Felder der Sprache \%Modula-2 auf die Vektoren
der Sprache C ist, wegen der ungew\(o:hnlichen Semantik der Vektoren,
nicht sinnvoll. Vektoren k\(o:nnen nicht als Ganzes zugewiesen werden
oder als Wertparameter \(u:bergeben werden. Bei der Zuweisung und der
Parameter\(u:bergabe wird ein Vektorname immer als Zeiger auf das erste
Element des Vektors interpretiert. Aus diesem Grund mu\(ss in C die
Zuweisung eines Vektors elementweise erfolgen.
Will man den Vektor als Wertparameter
\(u:bergeben, mu\(ss der \(u:bergebene Vektor am Anfang der
Funktion in einen lokal vereinbarten Vektor kopiert werden.
Da neuere C-\(U:bersetzer in der Lage sind Strukturen als Ganzes zuzuweisen oder
sie als Wertparameter an Funktionen zu \(u:bergeben, wird
diese Schwierigkeit umgangen, indem ein Feld auf eine
Struktur mit einem Vektor \fIA\fP als einziger Komponente abgebildet wird
[PTC\|87].
Die Anzahl der Elemente von Vektoren wird in C durch einen
konstanten Ausdruck angegeben, daher mu\(ss bei der \(U:bersetzung f\(u:r den
Indextyp ein konstanter Ausdruck erzeugt werden, der angibt
wieviele verschiedene Werte der Indexbereich umfa\(sst.
Die folgenden Typdeklarationen
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE
  tString       = ARRAY [0..255] OF CHAR;
  tTokenSet     = ARRAY [0..1] OF BITSET; 
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
werden in C also zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
typedef struct S_3 {
    CHAR A[255 + 1];
} tString;
.sp 0.4v
.br
.ne 3
typedef struct S_4 {
    BITSET A[1 + 1];
} tTokenSet;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Diese L\(o:sung hat mehrere Vorteile: Zun\(a:chst wird damit die Zuweisung von
Feldern bzw. ihre \(U:bergabe als Wertparameter erheblich effizienter, weil
kein C-Code zum Kopieren mehr
notwendig ist, sondern direkt der Zuweisungsoperator
bzw. der Parameter\(u:bergabemechanismus von C verwendet
werden kann. Der vom C-\(U:bersetzer daf\(u:r erzeugte Code
ist in der Regel effizienter, da spezielle Assembler-Befehle
verwendet werden k\(o:nnen. Der zweite Vorteil ist eine Vereinfachung des
\(U:bersetzers, weil Felder jetzt bei der Zuweisung, der Parameter\(u:bergabe
und der Adre\(ssbestimmung wie alle anderen Datentypen behandelt werden k\(o:nnen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Verbunde\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Verbunde
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 verlangt die Eindeutigkeit der Komponentennamen eines Verbundes
lediglich innerhalb der Definition des Verbundtyps. Insbesondere kann man
in einem Deklarationsteil den gleichen Komponentennamen in der
Definition von zwei verschiedenen Verbunden benutzen. Die C-Sprachbeschreibung
fordert, da\(ss die Namen aller Komponenten
von zwei im gleichen G\(u:ltigkeitsbereich vereinbarten Strukturen
untereinander verschieden sind\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Ausnahme: Zwei Strukturen
beginnen mit der gleichen Folge von Komponenten.
.nE
\&.
Die meisten neueren C-\(U:bersetzer sind hier allerdings gro\(ssz\(u:giger und
verlangen die Eindeutigkeit nur innerhalb der Definition einer
Struktur. Diese Regel
wird voraussichtlich auch im neuen C-Sprachstandard enthalten sein. Daher werden
Verbunde direkt, ohne Ber\(u:cksichtigung von m\(o:glichen Namenskonflikten
aufgrund identischer Komponentennamen,
auf die Strukturen der Sprache C abgebildet. Somit wird die Typdeklaration
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  date = RECORD
               day   : [1..31];
               month : [1..12];
               year  : CARDINAL;
             END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef struct S_5 {
    CARDINAL day;
    CARDINAL month;
    CARDINAL year;
} date;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Die Strukturen, auf die die Felder und Verbunde der Sprache \%Modula-2
abgebildet werden, erhalten immer einen Strukturnamen. Diese Strukturnamen
werden in den erzeugten C-Programmen an verschiedenen Stellen ben\(o:tigt,
z.B. bei der \(U:bersetzung von Vorw\(a:rtsreferenzen in Zeigerdeklarationen
(s. Kap. \n(h1.3). Wegen der getrennten
\(U:bersetzung und zur Vermeidung von Namenskonflikten haben die Strukturnamen
der in einem Definitionsmodul definierten Verbunde und Felder in C die lange
Form \%\fIModulname_nnn\fP\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Besteht der Modulname nur aus einem
Buchstaben, so wird das Zeichen _ verdoppelt, um theoretisch m\(o:gliche
Namenskonflikte mit anderen vom \(U:bersetzer erzeugten Bezeichnern zu
verhindern.
.nE
\&; alle \(u:brigen Strukturnamen haben die k\(u:rzere
Form \%\fIS_nnn\fP.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Verbunde mit Varianten\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Verbunde mit Varianten
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Datenstruktur Variante der Sprache C entspricht einem varianten Teil eines
Verbundes in \%Modula-2. Eine Variante in C kann allerdings \(em im
Gegensatz zu einer Variante in \%Modula-2 \(em nur
eine einzige Komponente zur gleichen
Zeit enthalten\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Die f\(u:r die jeweiligen Datenstrukturen der beiden
Sprachen gebr\(a:uchlichen deutschen Begriffe sind hier leider etwas verwirrend.
Eine Komponente der C-Datenstruktur Variante (Englisch: Union) entspricht
einer Variante eines varianten Teils eines Modula-Verbundes.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Die Typdeklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
TYPE  tRecord =    RECORD
                     x ,
                     y : CHAR;
.br
.ne 3
        CASE      tag0 : Color OF
        | red   : a, b : CHAR;
        | green : c, d : CHAR;
        | blue  : e, f : CHAR;
        END;
                     z : CHAR;
.br
.ne 2
        CASE      tag1 : BOOLEAN OF
        | TRUE  : u, v : INTEGER;
        | FALSE : r, s : INTEGER;
        END;
      END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
typedef struct S_6 {
    CHAR    x, y;
    Color   tag0;
.br
.ne 2
    union {
        struct {CHAR a, b;} V_1;
        struct {CHAR c, d;} V_2;
        struct {CHAR e, f;} V_3;
    } U_1;
    CHAR    z;
    BOOLEAN tag1;
.br
.ne 2
    union {
        struct {INTEGER u, v;} V_1;
        struct {INTEGER r, s;} V_2;
    } U_2;
} tRecord;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Jeder variante Teil des Modula-Verbundes wird in C zu einer Variante. In C mu\(ss
die Variante allerdings, da sie eine Komponente der umfassenden Struktur ist,
einen zus\(a:tzlichen Komponentennamen \%\fIU_nnn\fP bekommen, wobei
\%\fInnn\fP angibt, um den
wievielten varianten Teil des Modula-Verbundes es sich handelt. Zur
Umgehung der Einschr\(a:nkung, da\(ss Varianten in C nur genau eine Komponente zur
gleichen Zeit enthalten k\(o:nnen, mu\(ss jede Variante des Modula-Verbundes in C
zus\(a:tzlich in eine Struktur geklammert werden. Diese Strukturen erhalten den
Komponentennamen \%\fIV_nnn\fP, wobei \%\fInnn\fP
angibt, um die wievielte Variante innerhalb
eines varianten Teils es sich jeweils handelt. Bei der \(U:bersetzung des Zugriffs
auf Varianten m\(u:ssen diese zus\(a:tzlichen Komponentennamen dann entsprechend
ber\(u:cksichtigt werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Mengen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Mengen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Mengen werden in C einheitlich auf den Typ
\%\fIunsigned\ long\fP abgebildet. Damit kann
eine Menge maximal 16 oder 32 Elemente enthalten\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ \%MOCKA macht die
gleiche Einschr\(a:nkung, daher d\(u:rfte dies in unserem Fall keine wirkliche
Einschr\(a:nkung bedeuten.
.nE
\& je nach Gr\(o:\(sse des Typs auf der Zielmaschine.
Diese Abbildung vereinfacht die Behandlung von Mengen und steigert zus\(a:tzlich die
Effizienz der Mengenverarbeitung, da jetzt:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Konstante Mengen in C als Hexadezimalkonstante oder als konstante
Ausdr\(u:cke dargestellt werden
k\(o:nnen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die Mengenoperationen in C weitgehend ohne zus\(a:tzliche Funktionsaufrufe
mit den Operatoren zur Bitmanipulation implementiert werden
k\(o:nnen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Mengen als Wertparameter \(u:bergeben und als Funktionsergebnis
geliefert werden k\(o:nnen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.zA
.sp 0.4v
.ne 2v
.ti +2n
Der Standardtyp \%BITSET ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef unsigned long BITSET;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Zeiger\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Zeiger
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Zeigertypen werden direkt auf die Zeigertypen der Sprache C
abgebildet. Damit wird
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  PtrToCardinal = POINTER TO CARDINAL;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef CARDINAL *PtrToCardinal;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Wie oben bereits erl\(a:utert, werden die
Zeigerdeklarationen, in denen der Bezugstyp erst
nach dem Zeigertyp vereinbart wird, auf F\(a:lle beschr\(a:nkt,
in denen der Bezugstyp ein Verbund oder ein Feld ist.
.zA
.sp 0.4v
.ne 2v
.ti +2n
Die Konstante \%NIL ist in \%SYSTEM.h als
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define NIL     0L
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
definiert.
.zE
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Prozedurtypen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Prozedurtypen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Ein Prozedurtyp wird in C zu einem Zeiger auf eine
Funktion mit entsprechendem Ergebnistyp.
Somit wird die Typdeklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TYPE  Function = PROCEDURE (CARDINAL): CARDINAL;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in folgende C-Deklaration umgesetzt:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef CARDINAL (*Function)();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zA
.sp 0.4v
.ne 2v
.ti +2n
Der Standardtyp \%PROC ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef void (*PROC)();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Variablendeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Variablendeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Variablendeklarationen werden auf entsprechende C-Variablendeklarationen
abgebildet, die aus einem Typnamen und einer Liste von Deklaratoren
[Kernighan\|78] bestehen.
Die folgenden Variablendeklarationen (s. Beispiele Kap. \n(h1.3 und \n(h1.\n(h2.2)
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
VAR
  x, y  : POINTER TO INTEGER;
  i, j  : CARDINAL;
  p, q  : BOOLEAN;
  s     : BITSET;
  F     : Function;
  S     : tString;
  t     : tTree;
.br
.ne 5
  w, v  : ARRAY [0..7] OF
            RECORD
              ch    : CHAR;
              count : CARDINAL;
            END;
.br
.ne 2
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
werden somit in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
INTEGER     *x, *y;
CARDINAL    i, j;
BOOLEAN     p, q;
BITSET      s;
Function    F;
tString     S;
tTree       t;
.sp 0.4v
.br
.ne 6
struct S_7 {
    struct S_8 {
        CHAR     ch;
        CARDINAL count;
    } A[7 + 1];
} w, v;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Prozedurdeklarationen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Prozedurdeklarationen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Deklaration einer Prozedur oder Funktion wird
in C auf eine Funktionsdeklaration abgebildet.
Eine Prozedur hat als C-Funktion
den Ergebnistyp \%\fIvoid\fP, womit in C angedeutet wird, da\(ss die
Funktion kein Ergebnis liefert.
Sowohl \%Modula-2 als auch C erlauben rekursive Aufrufe
von Prozeduren bzw. Funktionen. Prozedurdeklarationen k\(o:nnen in
Modula-2 beliebig geschachtelt werden; C erlaubt keine geschachtelten
Funktionsdeklarationen. Aus diesem Grund mu\(ss ein Modula-Programm, das
solche geschachtelten Prozedurdeklarationen enth\(a:lt, bei der
\(U:bersetzung nach C derart transformiert werden, da\(ss keine
geschachtelten Prozedurdeklarationen mehr vorhanden sind.
Bei dieser Transformation m\(u:ssen besonders die beiden folgenden Punkte
beachtet werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der Deklaration einer lokalen Prozedur in \%Modula-2 k\(o:nnen
Konstanten und/oder Typen verwendet werden, die in einer statisch
umfassenden Prozedur vereinbart sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine lokale Prozedur kann auf eine lokale Variable
einer statisch umfassenden Prozedur zugreifen.
Um diesen Zugriff zur Laufzeit zu erm\(o:glichen, enth\(a:lt in \%Modula-2
jede Prozedurschachtel einen Verweis auf die Schachtel
ihres statischen Vorg\(a:ngers.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Geschachtelte Prozedurdeklarationen werden daher folgenderma\(ssen behandelt:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ist eine Prozedur \fIQ\fP lokal in einer Prozedur \fIP\fP deklariert,
dann steht die Funktion \fIQ\fP in C vor der Funktion \fIP\fP.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle lokalen
Konstanten- und Typdeklarationen der Prozedur \fIP\fP
werden in C zu globalen Deklarationen,
die vor die Funktion \fIQ\fP plaziert werden, damit sie
auch f\(u:r \fIQ\fP sichtbar sind.
Im Prinzip w\(u:rde es gen\(u:gen, nur solche lokalen
Konstanten- und Typen von \fIP\fP global zu vereinbaren,
die in \fIQ\fP benutzt werden\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ 
Dies gilt dann nat\(u:rlich auch rekursiv f\(u:r alle lokalen Objekte,
die in der Deklaration dieser Konstanten- und Typen verwendet werden.
.nE
\&.
Zur Vereinfachung der Transformation werden aber alle lokalen Konstanten-
und Typdeklarationen aus dem Modula-Programm in C zu globalen Deklarationen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Um in C der Funktion \fIQ\fP den Zugriff auf lokal in \fIP\fP vereinbarte Variablen
zu erm\(o:glichen, gibt es verschiedene M\(o:glichkeiten. Eine
Alternative ist, da\(ss die Funktion \fIP\fP die Adressen der lokalen Variablen
als zus\(a:tzliche Parameter an \fIQ\fP \(u:bergibt,
eine zweite Alternative verwendet
globale Zeigervariablen [PTC\|87], um den Zugriff zu realisieren. Diese
beiden Varianten werden unten n\(a:her beschrieben und miteinander
verglichen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei dieser Transformation k\(o:nnen eventuell Namenskonflikte
entstehen. Diese werden in C durch Umbenennungen gel\(o:st.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Zur Erl\(a:uterung der obigen Transformation und der beiden Alternativen, den
Zugriff auf lokale Variablen zu erm\(o:glichen, dient der folgende Ausschnitt
eines Modula-Programms:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
PROCEDURE p;
.sp 0.4v
TYPE
  tCard = CARDINAL;
.sp 0.4v
VAR
  i, j  : tCard;
.sp 0.4v
.br
.ne 4
  PROCEDURE q;
  BEGIN
    i := 1;
  END q;
.sp 0.4v
.br
.ne 3
  PROCEDURE r;
  BEGIN
    j := 1;
    q;
  END r;
.sp 0.4v
.br
.ne 3
BEGIN
  r;
END p;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die erste Alternative einer Funktion \fIQ\fP, den Zugriff auf lokal in einer
Funktion \fIP\fP vereinbarte Variablen zu erm\(o:glichen, geht von folgender
\(U:berlegung aus: Da die Prozedur \fIQ\fP im Modula-Programm lokal zur Prozedur
\fIP\fP vereinbart ist, ruft die Prozedur \fIP\fP irgendwann, m\(o:glicherweise
indirekt \(u:ber den Aufruf weiterer lokaler Prozeduren, die Prozedur \fIQ\fP auf.
Ist dies nicht der Fall, dann ist die Prozedur \fIQ\fP ,,nutzlos'' und kann aus dem
Programm gestrichen werden. Um in C der Funktion \fIQ\fP den Zugriff auf ihre lokalen
Variablen zu erm\(o:glichen, \(u:bergibt \fIP\fP deren Adressen als zus\(a:tzliche
Parameter an \fIQ\fP. Wegen des m\(o:glicherweise indirekten
Aufrufs von \fIQ\fP mu\(ss zur Bestimmung der zus\(a:tzlichen Parameter der
Aufrufgraph der lokalen Prozeduren betrachtet werden. Einige der
zus\(a:tzlichen Parameter haben eventuell nur die Funktion, die Adressen
der Va\%ria\%blen entlang des Aufrufgraphen weiterzureichen. Prozedurvariablen
m\(u:ssen dabei nicht ber\(u:cksichtigt werden, da in \%Modula-2 nur global
auf Ebene 0 vereinbarte Prozeduren als Wert von Prozedurvariablen zul\(a:ssig
sind.
.sp 0.4v
.ne 2v
.ti +2n
Der folgende Datenflu\(ssalgorithmus berechnet die Mengen \%\fIParam\^(p)\fP,
die angeben, um welche Parameter die Parameterlisten der lokalen
Prozeduren bei der Abbildung nach C erweitert werden m\(u:ssen:
.sp 0.4v
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
BEGIN
  LocalProc := { p | p ist eine auf Ebene k \(>= 1 vereinbarte Prozedur }
.sp 0.4v
  GlobalVar := { v | v ist eine auf Ebene 0 vereinbarte Variable }
.sp 0.4v
.zA
  FORALL p \(mo LocalProc DO
    Local(p) := { v | v ist eine lokale Variable von p }
.sp 0.4v
    Call(p)  := { q | q \(mo LocalProc \(ba p ruft q auf }
.sp 0.4v
    Use(p)   := { v | v wird in p benutzt \(ba v \o'/\(mo' Local(p) \(ba v \o'/\(mo' GlobalVar }
.sp 0.4v
    Param(p) := Use(p)
  END
.zE
.sp 0.4v
.zA
  REPEAT
    Changed := FALSE
.sp 0.4v
    FORALL p \(mo LocalProc DO
      Old := Param(p)
.sp 0.4v
      Param(p) \(cu:= \(cu Param(q) \e Local(p)
\^                 q \(mo Call(p)
.sp 0.4v
      Changed := Changed OR (Param(p) \(!= Old)
    END
  UNTIL NOT Changed
END
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Die REPEAT-Schleife im obigen Algorithmus
ist notwendig, weil der Aufrufgraph der lokalen Prozeduren
m\(o:glicherweise aufgrund von Rekursion Zyklen enth\(a:lt. Die
Effizienz des Algorithmus ist stark abh\(a:ngig von der Reihenfolge, in der die
Prozeduren der Menge \%\fILocalProc\fP
bearbeitet werden. Nach M\(o:glichkeit sollte jede
Prozedur erst bearbeitet werden, wenn alle ihre Nachfolger im Aufrufgraph
bereits bearbeitet wurden. Enth\(a:lt der Aufrufgraph
keine Zyklen, dann sind bei dieser
Bearbeitungsreihenfolge h\(o:chstens zwei Iterationen notwendig.
Mit diesem Algorithmus wird das obige Beispiel
in C zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
typedef CARDINAL tCard;
.sp 0.4v
static void q(i)
tCard *i;
{
    *i = 1;
}
.sp 0.4v
.br
.ne 3
static void r(i, j)
tCard *i, *j;
{
    *j = 1;
    q(i);
}
.sp 0.4v
.br
.ne 3
void p()
{
    tCard i, j;
.sp 0.4v
.br
.ne 2
    r(&i, &j);
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die zweite Alternative einer Funktion \fIQ\fP, den Zugriff auf lokal in \fIP\fP
vereinbarte Variablen zu erm\(o:glichen ist, f\(u:r jede dieser Variablen
eine globale Zei\%ger\%va\%ria\%ble zu vereinbaren. Am Anfang der Funktion \fIP\fP
werden die Adressen dieser lokalen Variablen an die globalen
Zeigervariablen zugewiesen. Damit dies auch funktioniert, wenn die Funktion \fIP\fP
rekursiv aufgerufen wird, werden die urspr\(u:nglichen Werte der globalen
Zeigervariablen am Anfang von \fIP\fP in lokalen Zeigervariablen gesichert
und am Ende von \fIP\fP wieder zur\(u:ckgeschrieben. Die Funktion \fIQ\fP kann jetzt
\(u:ber die globalen Zeigervariablen auf die lokalen Variablen von \fIP\fP
zugreifen. Damit wird das obige Beispiel
in C zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
typedef CARDINAL tCard;
.sp 0.4v
static tCard *G_1_i;
static tCard *G_2_j;
.sp 0.4v
.br
.ne 4
static void q()
{
    *G_1_i = 1;
}
.sp 0.4v
.br
.ne 3
static void r()
{
    *G_2_j = 1;
    q();
}
.sp 0.4v
.br
.ne 4
void p()
{
    tCard i, j;
    tCard *L_1, *L_2;
.sp 0.4v
.br
.ne 2
    L_1 = G_1_i; G_1_i = &i;
    L_2 = G_2_j; G_2_j = &j;
.sp 0.4v
    r();
.sp 0.4v
.br
.ne 3
    G_1_i = L_1;
    G_2_j = L_2;
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Eine m\(o:gliche Optimierung w\(a:re, zu bestimmen, ob die Funktion \fIP\fP
rekursiv aufgerufen wird und nur in diesem Fall den Wert der globalen
Zeigervariablen lokal in \fIP\fP zu sichern.
.sp 0.4v
.ne 2v
.ti +2n
Beide oben vorgestellten Varianten funktionieren in \%Modula-2 auch im
Zusammenhang mit Prozedurvariablen, da in \%Modula-2 als Wert von
Prozedurvariablen nur global auf Ebene 0 vereinbarte Prozeduren zul\(a:ssig
sind. Damit entf\(a:llt die z.B. in \%Pascal vorhandene Schwierigkeit,
beim Aufruf einer lokalen Prozedur die bei der Zuweisung an die
Prozedurvariable g\(u:ltige Umgebung zu bestimmen.
.sp 0.4v
.ne 2v
.ti +2n
Ein Vergleich der beiden oben vorgestellten Alternativen ergibt folgendes:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der \(U:bersetzung nach C ist der Aufwand f\(u:r die erste
Alternative, wegen der Notwendigkeit die Aufrufabh\(a:ngigkeiten der
lokalen Prozeduren zu analysieren, erheblich
h\(o:her als der Aufwand f\(u:r die zweite Alternative.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Wird innerhalb einer Prozedur \fIP\fP eine lokale Prozedur \fIQ\fP mehrfach
aufgerufen, m\(u:ssen die Adressen der lokalen Variablen von \fIP\fP bei 
jedem Aufruf von \fIQ\fP als Parameter \(u:bergeben werden. Au\(sserdem haben die
Parameter manchmal nur die Funktion die Adressen der Va\%ria\%blen entlang des
Aufrufgraphen weiterzureichen. Im Gegensatz dazu
werden die Adressen der lokalen Variablen nur einmal an die globalen
Zeigervariablen zugewiesen, jedoch verursacht die lokale Sicherung der
Werte der globalen Zeigervariablen zus\(a:tzlichen Aufwand.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Speicheraufwand f\(u:r beide Alternativen ist in der
Regel sehr gering.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da der Berechnungsaufwand f\(u:r die erste Alternative bei der \(U:bersetzung
verh\(a:ltnism\(a:\(ssig hoch ist und der Aufwand zur Laufzeit bei der zweiten
Alternative in den meisten F\(a:llen geringer ist,
wurde die zweite Alternative f\(u:r den \(U:bersetzer ausgew\(a:hlt.
.sp 0.4v
.ne 2v
.ti +2n
Ein besonderes Problem entsteht, wenn in der Deklaration einer lokalen
Variablen ein anonymer strukturierter Typ verwendet wird. \(U:bersetzt man
diese Variablendeklaration wie in Kapitel \n(h1.\n(h2.3
beschrieben nach C, dann ist der f\(u:r den strukturierten Typ erzeugte
Strukturnamen nur lokal in der betreffenden Funktion sichtbar und kann
daher nicht in der Deklaration einer globalen Zeigervariablen verwendet werden.
Aus diesem Grund wird bei der \(U:bersetzung nach C f\(u:r solche anonymen
strukturierten Typen zun\(a:chst eine globale Strukturdeklaration erzeugt,
die den Typ beschreibt. Der zu dieser Strukturdeklaration dazugeh\(o:rige
Strukturnamen kann dann in der Deklaration der globalen Zeigervariablen
benutzt werden. Damit wird folgender Ausschnitt eines Modula-Programms
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
PROCEDURE p;
.sp 0.4v
  VAR a : ARRAY [0..127] OF CHAR;
.sp 0.4v
.br
.ne 5
  PROCEDURE q;
  BEGIN
    (* Zugriff auf a *)
  END q;
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
struct S_9 {
    CHAR A [127 + 1];
};
  ...
struct S_9 *G_3_a;
.br
.ne 6
  ...
void p()
{
    struct S_9 a;
    struct S_9 *L_3;
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Formale Parameter\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Formale Parameter
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Bei der Abbildung der formalen Parameter m\(u:ssen drei F\(a:lle unterschieden
werden: offene Felder, Wertparameter und Referenzparameter.
Die offenen Felder m\(u:ssen bei der Abbildung getrennt
behandelt werden, da C kein vergleichbares Konzept kennt und daher,
insbesondere wenn das offene Feld als Wertparameter \(u:bergeben wird,
in C eine Simulation
des gew\(u:nschten Effekts notwendig wird. Die Abbildung von ,,normalen''
Parametern macht hingegen wenig M\(u:he.
.hA 5 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4.\n(h5
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4.\n(h5'u
\&Wert- und Referenzparameter\fP
.hC 1v 0n 0v (4n+5n+7n+9n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4.\n(h5\ 
.hD 11n
\&Wert- und Referenzparameter
.hE (4n+5n+7n+9n) 11n 0v
.sp 0.4v
.ne 2v
.ti +2n
In C werden alle Parameter \(em mit Ausnahme der
Vektoren \(em als Wertparameter \(u:bergeben. Daher
kann die Deklaration eines Wertparameters, mit der oben beschriebenen
Abbildung der Felder, direkt auf die entsprechende Parameterdeklaration
in C abgebildet werden.
Hierbei wird allerdings vorausgesetzt, da\(ss der C-\(U:bersetzer
in der Lage ist auch beliebige Strukturen als Wertparameter zu \(u:bergeben.
.sp 0.4v
.ne 2v
.ti +2n
Die semantische Bedeutung eines Referenzparameters in Modula-2 ist, da\(ss dem
Unterprogramm die Adresse des aktuellen Parameters, der in diesem Fall
eine Variable sein mu\(ss, \(u:bergeben wird und das Unterprogramm dann
\(u:ber die Adresse direkt auf diese Variable zugreift. Da in C die
Adresse jeder Variablen mit dem Operator & bestimmt werden kann, erreicht
man in C den Effekt eines Referenzparameters, indem man den formalen Parameter
als Zeiger vereinbart und bei der Parameter\(u:bergabe die Adresse der
Variablen an das Unterprogramm \(u:bergibt. Innerhalb des
Unterprogramms wird dann \(em genau wie in Modula-2 \(em \(u:ber die
Adresse auf diese
Variable zugegriffen. Der einzige Unterschied ist, da\(ss in C die
Operatoren zur Adre\(ssbestimmung und zur Dereferenzierung explizit
aufgeschrieben werden m\(u:ssen. Semantisch besteht jedoch kein Unterschied.
.sp 0.4v
.ne 2v
.ti +2n
Der folgende Ausschnitt eines Modula-Programms, der die Verwendung von Wert-
und Referenzparametern zeigt,
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
VAR  GlobalRestartSet, LocalRestartSet : tTokenSet;
  ...
.br
.ne 3
PROCEDURE Union (VAR t1: tTokenSet; t2: tTokenSet);
BEGIN
  t1[0] := t1[0] + t2[0];
  t1[1] := t1[1] + t2[1];
END Union;
.br
.ne 2
   ...
Union (GlobalRestartSet, LocalRestartSet);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
tTokenSet GlobalRestartSet, LocalRestartSet;
  ...
.br
.ne 3
void Union(t1, t2)
tTokenSet *t1;
tTokenSet t2;
{
    t1->A[0] = t1->A[0] | t2.A[0];
    t1->A[1] = t1->A[1] | t2.A[1];
}
.br
.ne 2
  ...
Union(&GlobalRestartSet, LocalRestartSet);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 5 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4.\n(h5
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4.\n(h5'u
\&Offene Felder\fP
.hC 1v 0n 0v (4n+5n+7n+9n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4.\n(h5\ 
.hD 11n
\&Offene Felder
.hE (4n+5n+7n+9n) 11n 0v
.sp 0.4v
.ne 2v
.ti +2n
Offene Felder erfordern in C eine spezielle Behandlung,
die aber dadurch vereinfacht wird, da\(ss in \%Modula-2 f\(u:r sie
nur elementweiser Zugriff und die \(U:bergabe als aktueller Parameter an ein
Unterprogramm definiert ist, dessen formaler
Parameter ebenfalls ein offenes Feld ist.
.sp 0.4v
.ne 2v
.ti +2n
Die \(U:bergabe der offenen Felder wird in C dadurch realisiert, da\(ss
als aktueller Parameter ein Zeiger auf den Feldanfang \(u:bergeben wird.
Da diese Art der \(U:bergabe in C allgemein f\(u:r die \(U:bergabe von Vektoren
benutzt wird, wird die Deklaration eines offenen Feldes in eine
Parameterdeklaration der Sprache C umgesetzt, die angibt, da\(ss der Parameter
ein Vektor ist\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Zur Umgehung der damit verbundenen Einschr\(a:nkungen
werden die ,,normalen'' Felder auf Strukturen mit einem Vektor als Komponente
abgebildet (s. Kap. \n(h1.4.2.5).  F\(u:r offene Felder sind diese
Einschr\(a:nkungen aber
unproblematisch, da f\(u:r sie in \%Modula-2 \(a:hnliche Einschr\(a:nkungen
gelten wie f\(u:r die Vektoren in C.
.nE
\&.
Dabei spielt es bei der \(U:bergabe zun\(a:chst keine Rolle, ob das offene
Feld im Modula-Programm
als Wert- oder Referenzparameter vereinbart wurde (siehe unten).
.sp 0.4v
.ne 2v
.ti +2n
Ein zus\(a:tzlicher Parameter enth\(a:lt die aktuelle Anzahl von Feldelementen.
Dieser Parameter wird ben\(o:tigt, um innerhalb des Unterprogramms f\(u:r
ein als Wertparameter vereinbartes offenes Feld einen lokalen Vektor
entsprechender Gr\(o:\(sse anlegen zu k\(o:nnen. Au\(sserdem ist der
Parameter zur \(U:bersetzung
der Standardfunktionen \%HIGH und \%SIZE notwendig, mit denen die
obere Grenze bzw. die Gr\(o:\(sse des
offenen Feldes bestimmt werden kann.
.sp 0.4v
.ne 2v
.ti +2n
Erfolgt aus einer Prozedur \fIQ\fP, die lokal zu einer Prozedur \fIP\fP deklariert
ist, ein Zugriff auf ein offenes Feld \fIa\fP von \fIP\fP, dann mu\(ss auch der
zus\(a:tzliche Parameter mit der aktuellen Anzahl von Elementen des Feldes \fIa\fP,
genau wie die Adresse von \fIa\fP (s. Kap. \n(h1.\n(h2.\n(h3), an eine globale Variable
zugewiesen werden, da auch in \fIQ\fP ein Aufruf
\%HIGH\^(\fIa\fP\|)
bzw.
\%SIZE\^(\fIa\fP\|)
m\(o:glich ist und \fIQ\fP somit auch Zugriff auf den aktuellen Wert des
zus\(a:tzlichen Parameters von P haben mu\(ss. 
.sp 0.4v
.ne 2v
.ti +2n
Beim Zugriff auf ein Element des
offenen Feldes, bei der Bestimmung seiner Adresse und seiner \(U:bergabe
als aktueller Parameter an eine Prozedur mu\(ss entsprechend
ber\(u:cksichtigt werden, da\(ss die Abbildung der offenen Felder sich von der
Abbildung der ,,normalen'' Felder unterscheidet.
.sp 0.4v
.ne 2v
.ti +2n
Die Deklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE Sort (VAR a : ARRAY OF CARDINAL);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C abgebildet auf
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
void Sort(a, O_1)
CARDINAL a[]; LONGCARD O_1;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Der erste Parameter \fIa\fP enth\(a:lt den Zeiger auf den Feldanfang, der zweite
Parameter \%\fIO_1\fP die aktuelle Anzahl von Feldelementen.
.sp 0.4v
.ne 2v
.ti +2n
Die Behandlung der \(U:bergabe eines offenen Feldes als Wertparameter
wird zun\(a:chst an einem Beispiel demonstriert:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE WriteS (s : ARRAY OF CHAR);
VAR  i : CARDINAL;
BEGIN
  FOR i := 0 TO HIGH (s) DO WriteC (s[i]); END;
END WriteS;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
Diese Prozedur wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 5
void WriteS(s, O_2)
CHAR s[]; LONGCARD O_2;
{
    CARDINAL i;
    OPEN_ARRAY_LOCALS
.sp 0.4v
.br
.ne 4
    ALLOC_OPEN_ARRAYS(O_2 * sizeof(CHAR), 1)
    COPY_OPEN_ARRAY(s, O_2, CHAR)
    {
        CARDINAL B_1 = 0, B_2 = (O_2 - 1);
.sp 0.4v
.br
.ne 5
        if (B_1 <= B_2)
          for (i = B_1;; i += 1) {
              WriteC(s[i]);
              if (i >= B_2) break;
          }
.br
.ne 3
    }
    FREE_OPEN_ARRAYS
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Der zweite Parameter von \%\fIWriteS\fP
\%\fIO_2\fP enth\(a:lt wieder die aktuelle Anzahl von
Feldelementen. Der erste Parameter \fIs\fP enth\(a:lt beim Prozeduraufruf zun\(a:chst
die Anfangsadresse des \(u:bergebenen Feldes.
\%OPEN_ARRAY_LOCALS,
\%ALLOC_OPEN_ARRAYS, \%COPY_OPEN_ARRAY und \%FREE_OPEN_ARRAYS
sind in \%SYSTEM.h definierte Makros.
\%OPEN_ARRAY_LOCALS ist die Definition von lokalen Hilfsvariablen, die in
den \(u:brigen Makros ben\(o:tigt werden.
Die Aufgabe von
\%ALLOC_OPEN_ARRAYS ist, einen Speicherblock ausreichender Gr\(o:\(sse f\(u:r das
als Wertparameter \(u:bergebene Feld zu beschaffen.
\%COPY_OPEN_ARRAY bestimmt zun\(a:chst die Anfangsadresse eines
lokalen Vektors geeigneter Gr\(o:\(sse und Ausrichtung im von
\%ALLOC_OPEN_ARRAYS beschafften Speicherblock, kopiert das \(u:bergebene
Feld in diesen lokalen Vektor und
weist schlie\(sslich die Anfangsadresse des lokalen
Vektors an den Parameter \fIs\fP zu.
\%FREE_OPEN_ARRAYS gibt den Speicherplatz f\(u:r den von
\%ALLOC_OPEN_ARRAYS beschafften Speicherblock wieder frei.
\%FREE_OPEN_ARRAYS mu\(ss am Ende des Unterprogramms sowie vor
jeder RETURN-An\%wei\%sung
innerhalb des Unterprogramms stehen. Die genaue
Definition dieser Makros h\(a:ngt von den auf der Zielmaschine verf\(u:gbaren 
Bibliotheksfunktionen ab. Eine M\(o:glichkeit w\(a:re folgende:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#define SYSTEM_ALIGN            8
#define SYSTEM_MASK             (~(SYSTEM_ALIGN - 1))
.sp 0.4v
#define OPEN_ARRAY_LOCALS       char *BLOCK_POINTER, *FREE_POINTER;
.sp 0.4v
.br
.ne 5
#define ALLOC_OPEN_ARRAYS(size, arrays) \e
    BLOCK_POINTER = FREE_POINTER = \e
        malloc((unsigned)((size) + (arrays) * (SYSTEM_ALIGN - 1)));
.sp 0.4v
#define FREE_OPEN_ARRAYS        free(BLOCK_POINTER);
.sp 0.4v
.br
.ne 7
#define COPY_OPEN_ARRAY(array, elems, type) \e
{ \e
    int ARRAY_SIZE = elems * sizeof(type); \e
    \e
    array = (type *)memcpy(FREE_POINTER, (char *)array, ARRAY_SIZE); \e
    FREE_POINTER += (ARRAY_SIZE + (SYSTEM_ALIGN - 1)) & SYSTEM_MASK; \e
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Konstante \%SYSTEM_ALIGN ist maschinenabh\(a:ngig und sorgt daf\(u:r, da\(ss
die Anfangsadressen der lokalen Vektoren korrekt ausgerichtet sind.
Die Bibliotheksfunktion \%\fImalloc\fP beschafft Speicherplatz auf der Halde,
\%\fIfree\fP gibt diesen Speicherplatz wieder frei. Die Bibliotheksfunktion
\%\fImemcpy\^(s1,\|s2,\|n)\fP kopiert \fIn\fP Zeichen von \fIs2\fP
nach \fIs1\fP und
liefert den Zeiger \fIs1\fP als Ergebnis.
.sp 0.4v
.ne 2v
.ti +2n
An einigen Maschinen stehen auch Bibliotheksfunktionen zur Verf\(u:gung,
mit denen man den Speicherplatz erheblich effizienter in der Aufrufschachtel
des Unterprogramms beschaffen kann\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ An der \%SUN z.B. existiert eine
solche Bibliotheksfunktion mit dem Namen \%\fIalloca\fP.
.nE
\&.
Bei der R\(u:ckkehr wird dieser Speicherplatz dann automatisch freigegeben. Das
Makro \%FREE_OPEN_ARRAYS w\(a:re in diesem Fall leer.
.sp 0.4v
.ne 2v
.ti +2n
Da der zuletzt f\(u:r die Speicherung von offenen Feldern beschaffte
Speicherblock
immer als erster wieder freigegeben wird,
k\(o:nnte man die Aufrufe von \%\fImalloc\fP und \%\fIfree\fP auch durch
Aufrufe von selbstprogrammierten Funktionen zur Speicherverwaltung ersetzen,
die den angeforderten
Speicher kellerartig verwalten und daher wahrscheinlich effizienter
programmiert werden k\(o:nnen als \%\fImalloc\fP und \%\fIfree\fP, die die
Anforderung und Freigabe von Speicherplatz in beliebiger Reihenfolge
unterst\(u:tzen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Standardprozeduren und -funktionen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Standardprozeduren und -funktionen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Dieser Abschnitt enth\(a:lt die Definition der Standardprozeduren und -funktionen
in C. Alle diese Definitionen sind in \%SYSTEM.h
bzw. \%SYSTEM.c enthalten.
.sp 0.4v
.ne 2v
.ti +2n
Da \%ABS eine \(u:berladene Funktion ist, existieren in C verschiedene
Definitionen von \%ABS.
Abh\(a:ngig vom Typ und der Art des aktuellen Parameters, wird in
C ein Aufruf der entsprechenden Funktion bzw. des entsprechenden Makros
eingesetzt. Die verschiedenen Definitionen von \%ABS haben folgende Form:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#define ABS(x)          ((x) < 0 ? -(x) : (x))
#define ABSSC(x)        ((SHORTCARD) (x))
#define ABSLC(x)        ((LONGCARD) (x))
#define ABSSI(x)        ((SHORTINT) ABSLI((LONGINT) (x)))
#define ABSR(x)         ((REAL) ABSLR(x))
.sp 0.4v
.br
.ne 2
extern LONGINT ABSLI();
extern LONGREAL ABSLR();
.sp 0.4v
.br
.ne 5
LONGINT ABSLI(x)
register LONGINT x;
{
    return (x < 0 ? -x : x);
}
.sp 0.4v
.br
.ne 5
LONGREAL ABSLR(x)
register LONGREAL x;
{
    return (x < 0 ? -x : x);
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Das Makro \%ABS, das nur benutzt wird, wenn der Parameter \fIx\fP
ein konstanter Ausdruck ist, kann nicht in allen F\(a:llen
verwendet werden, da \fIx\fP m\(o:glicherweise ein Funktionsaufruf mit
Seiteneffekten ist und in diesem Fall die doppelte Auswertung von \fIx\fP
zu Fehlern f\(u:hren w\(u:rde.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktion \%CAP ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
extern CHAR CAP();
.sp 0.4v
.zA
CHAR CAP(ch)
register CHAR ch;
{
    return (ch >= 'a' && ch <= 'z' ? ch - 'a' + 'A' : ch);
}
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
CAP ist nicht als Makro definiert, um eine mehrfache Auswertung von \fIch\fP
zu verhindern.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktionen f\(u:r Typumwandlungen \%CHR, \%FLOAT, \%ORD,
\%TRUNC und \%VAL sind wie folgt definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define CHR(x)          ((CHAR) (x))
#define FLOAT(x)        ((REAL) (x))
#define ORD(x)          ((CARDINAL) (x))
.zE
.zA
#define TRUNC(x)        ((CARDINAL) (x))
#define VAL(T,x)        ((T) (x))
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Umwandlung von Gleitkommawerten in ganzzahlige Werte ist in C nicht exakt
definiert. In der Regel wird aber mit der obigen Definition von \%TRUNC der
gew\(u:nschte Effekt erzielt. Es ist jedoch nicht v\(o:llig ausgeschlossen, da\(ss
in manchen Implementierungen gerundet wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Standardfunktion \%SIZE, zur Bestimmung der Anzahl der von einer Variablen oder
einem Typ ben\(o:tigten Speichereinheiten, wird normalerweise direkt
auf den C-Operator \%\fIsizeof\fP
abgebildet.
Ist der aktuelle Parameter von \%SIZE jedoch ein offenes Feld, dann ergibt
sich die von diesem Feld ben\(o:tigte Anzahl von Speichereinheiten aus:
\%\fIsizeof\^(Elementtyp)\fP * \fIaktueller Anzahl von Feldelementen\fP.
.sp 0.4v
.ne 2v
.ti +2n
Die Behandlung der Funktionen \%MAX und \%MIN h\(a:ngt von der Art des an sie
als Argument \(u:bergebenen Typs ab. F\(u:r einen Aufz\(a:hlungs- oder
einen Unterbereichstyp \fIT\fP ist der Wert von \%MIN\^(\fIT\fP\|) bzw.
\%MAX\^(\fIT\fP\|) aus der
Typdefinition bekannt und wird daher textuell in das erzeugte
C-Programm eingesetzt. F\(u:r die vordefinierten Standardtypen,
auf die diese Funktionen anwendbar sind,
sind in \%SYSTEM.h Definitionen von symbolischen Konstanten der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define MIN_CARDINAL    ...
#define MAX_CARDINAL    ...
.zE
.zA
#define MIN_BOOLEAN     FALSE
#define MAX_BOOLEAN     TRUE
  ...
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
enthalten. Diese symbolischen Konstanten werden im C-Programm
f\(u:r die Aufrufe von \%MIN bzw. \%MAX eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Ist der aktuelle Parameter der Funktion \%HIGH kein offenes Feld, dann ist
der Wert von \%HIGH\^(\fIa\fP\|) bei der \(U:bersetzung bekannt und wird in das
C-Programm als Konstante eingesetzt. Ist der aktuelle Parameter jedoch ein
offenes Feld, dann wird \%HIGH\^(\fIa\fP\|) im C-Programm zum Ausdruck
\%(\fIO_nnn\fP\^\ -\ 1). Der Parameter \%\fIO_nnn\fP der Funktion,
die \fIa\fP als formalen Parameter hat, gibt \(em wie oben erw\(a:hnt \(em die aktuelle
Anzahl der Feldelemente des offenen Feldes an.
.zA
.sp 0.4v
.ne 2v
.ti +2n
Die Standarfunktion \%ODD ist folgenderma\(ssen definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define ODD(x)          ((BOOLEAN)((x) & 01))
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Die Standardprozeduren \%DEC, \%INC, \%EXCL und
\%INCL haben folgende Definition:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define DEC(x)          (x)--
#define DEC1(x,n)       x -= n
#define INC(x)          (x)++
#define INC1(x,n)       x += n
.zE
.zA
#define EXCL(s,i)       s &= ~(0X1L << (i))
#define INCL(s,i)       s |= 0X1L << (i)
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Ein Aufruf der Standardprozedur \%HALT wird in C zu einem Aufruf
der Bibliotheksfunktion \%\fIexit\fP. Da \%HALT in der Regel in
Fehlerf\(a:llen benutzt wird, wird \%\fIexit\fP, entsprechend der in C
\(u:blichen Konvention, mit dem Argument 1 aufgerufen, um der Umgebung
den Fehler anzuzeigen.
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 definiert, da\(ss Aufrufe
\%NEW\^(\^\fIp\fP\|) bzw. \%DISPOSE\^(\^\fIp\fP\|)
der Standardprozeduren \%NEW bzw. \%DISPOSE ersetzt werden durch
Aufrufe
\%ALLOCATE\^(\^\fIp\fP,\ TSIZE\^(\fIT\fP\|))
bzw.
\%DEALLOCATE\^(\^\fIp\fP,\ TSIZE\^(\fIT\fP\|)),
wobei \fIp\fP vom Typ
\%POINTER\ TO\ \fIT\fP
sein mu\(ss und \%ALLOCATE bzw. \%DEALLOCATE vom Benutzer
definierte und an der Aufrufstelle
sichtbare Prozeduren mit folgender Definition sein m\(u:ssen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
PROCEDURE ALLOCATE      (VAR a: ADDRESS; size: CARDINAL);
PROCEDURE DEALLOCATE    (VAR a: ADDRESS; size: CARDINAL);
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Daher wird folgendes Modula-Programmfragment
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
FROM Storage    IMPORT ALLOCATE, DEALLOCATE;
  ...
VAR p: POINTER TO INTEGER;
  ...
NEW (p); p^ := 1; DISPOSE (p);
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
  ...
INTEGER *p;
  ...
Storage_ALLOCATE(&p, sizeof(INTEGER));
*p = 1;
Storage_DEALLOCATE(&p, sizeof(INTEGER));
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Lokale Moduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Lokale Moduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
C kennt kein den lokalen Moduln entsprechendes Konzept. Daher mu\(ss ein
Modula-Programm, das lokale Moduln enth\(a:lt derart transformiert werden, da\(ss keine
lokalen Moduln mehr vorhanden sind. Dies wird mit folgender Transformation
erreicht:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle Objekte, die in einem lokalen Modul deklariert sind, werden zu
lokalen Objekten der Prozedur bzw. \(U:bersetzungseinheit, die das lokale
Modul in ihrem Deklarationsteil enth\(a:lt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Rumpf des lokalen Moduls wird zu einer parameterlosen
Prozedur. Diese Prozedur wird am Anfang des Anweisungsteils der
Prozedur oder \(U:bersetzungseinheit aufgerufen, die den lokalen Modul
in ihrem Deklarationsteil enth\(a:lt. Sind
mehrere lokale Moduln vorhanden, dann erfolgen diese Aufrufe entsprechend
der Reihenfolge der lokalen Moduln im Quelltext. Dies entspricht der in
der Sprachdefinition
von \%Modula-2 geforderten Reihenfolge.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Da lokale Moduln mit Hilfe von Import- bzw. Exportanweisungen
eine explizite Kontrolle der Sichtbarkeit von Bezeichnern erlauben,
k\(o:nnen bei dieser Transformation m\(o:glicherweise Namenskonflikte
entstehen. Diese werden in C durch eine Umbenennung von Bezeichnern gel\(o:st.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Diese Transformation mu\(ss durchgef\(u:hrt werden,
bevor die Reihenfolge der Deklarationen umgeordnet wird und
bevor geschachtelte Prozedurdeklarationen transformiert werden.
.sp 0.4v
.ne 2v
.ti +2n
Die \(U:bersetzung des Moduls \fIGlobal\fP nach C soll die oben beschriebene
Transformation nochmals verdeutlichen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
MODULE Global;
.sp 0.4v
VAR  a : INTEGER;
.sp 0.4v
.br
.ne 4
MODULE Local;
EXPORT QUALIFIED a;
VAR
  a : INTEGER;
.br
.ne 3
BEGIN
  a := 1;
END Local;
.sp 0.4v
.br
.ne 3
BEGIN
  a := Local.a;
END Global.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
In C wird \fIGlobal\fP zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#include "SYSTEM.h"
.sp 0.4v
static INTEGER a;
static INTEGER C_1_a;
.sp 0.4v
.br
.ne 4
static void Local()
{
    C_1_a = 1;
}
.sp 0.4v
.br
.ne 3
void Global()
{
    Local();
.sp 0.4v
    a = C_1_a;
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Ausdr\(u:cke\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Ausdr\(u:cke
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Bei der \(U:bersetzung von Ausdr\(u:cken mu\(ss darauf geachtet werden, da\(ss die
Auswertungsreihenfolge im erzeugten C-Programm der Auswertungsreihenfolge im
Modula-Programm entspricht. Dabei ist insbesondere von Bedeutung, da\(ss
sich der Vorrang der Operatoren in \%Modula-2 und C teilweise deutlich unterscheidet.
Eine korrekte Auswertungsreihenfolge mu\(ss daher bei Bedarf durch das Setzen
von Klammern erzwungen werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Operanden\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Operanden
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung von Zeichenketten und Zahlen wurde bereits in Kapitel \n(h1.2 
besprochen.
.sp 0.4v
.ne 2v
.ti +2n
Mengen werden in einen C-Ausdruck umgesetzt,
der die gew\(u:nschte Menge liefert\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ So definierte Mengenkonstanten und
konstante Elemente werden vom C-\(U:bersetzer bereits bei der \(U:bersetzung
ausgewertet.
.nE
\&. Die folgende Menge
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
{1..2, i..j, j + 2}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
SET_cRNG(1, 2) | SET_RANGE(i, j) | SET_ELEM(j + 2)
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
\%SET_ELEM, \%SET_cRNG und \%SET_RANGE sind in \%SYSTEM.h
bzw. \%SYSTEM.c folgenderma\(ssen definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define SYSTEM_MaxSet   (sizeof(unsigned long) * 8 - 1)
.sp 0.4v
#define SET_ELEM(el)    (0X1L << (el))
#define SET_cRNG(lo,hi) \e
    ((lo) <= (hi) ? ~0XL >> (lo) << (lo) + SYSTEM_MaxSet - (hi) \e
     >> SYSTEM_MaxSet - (hi) : 0XL)
.zE
.zA
#define SET_RANGE(lo, hi) \e
    SET_RANGE1((CARDINAL)(lo), (CARDINAL)(hi))
.sp 0.4v
extern unsigned long SET_RANGE1();
.zE
.sp 0.4v
.zA
unsigned long SET_RANGE1(lo, hi)
register CARDINAL lo, hi;
{
    return (lo <= hi ? ~0XL >> lo << lo + SYSTEM_MaxSet - hi
            >> SYSTEM_MaxSet - hi : 0XL);
}
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Die Funktion \%SET_RANGE1 wird f\(u:r nicht konstante Elemente verwendet,
um eine mehrfache Auswertung von \fIlo\fP und \fIhi\fP zu verhindern.
.sp 0.4v
.ne 2v
.ti +2n
Alle von globalen Moduln exportierten Bezeichner werden im C-Programm in der
qualifizierten Form \fIModulname_Bezeichner\fP geschrieben.
Nicht von globalen Moduln exportierte
Bezeichner werden unver\(a:ndert nach C \(u:bernommen, sind aber bei Bedarf
zur L\(o:sung eines Namenskonfliktes mit einem Pr\(a:fix versehen.
.sp 0.4v
.ne 2v
.ti +2n
Die Selektion einer Verbundkomponente
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
R.f
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
R.f
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wenn die Komponente nicht in einem varianten Teil des Verbundes enthalten
ist. Ist die Komponente in einem varianten Teil enthalten, so erfolgt die
Selektion entsprechend der oben vorgestellten Abbildung von varianten Verbunden mit:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
R.U_xxx.V_nnn.f
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Der Zugriff auf ein Feldelement
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
A[E]
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird entsprechend der oben beschriebenen Abbildung von Feldern in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
A.A[E - Lwb]
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wenn \fIA\fP kein offenes Feld ist.
Da in C alle Vektoren die untere Grenze 0 besitzen, mu\(ss beim
Zugriff auf ein Feldelement die in \%Modula-2 angegebene untere
Grenze \fILwb\fP des Feldes abgezogen werden, sofern diese ungleich 0 ist.
Ist \fIA\fP ein offenes Feld, so erfolgt der Zugriff entsprechend der
oben vorgestellten Abbildung von offenen Feldern auf Vektoren mit:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
A[E]
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Dereferenzierung von Zeigervariablen
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
P^
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
*P
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Eine Dereferenzierung ist, wegen der oben beschriebenen Abbildung
von Referenzparametern auf Zeiger, auch notwendig, wenn \fIP\fP ein
Referenzparameter ist.
.sp 0.4v
.ne 2v
.ti +2n
Der Funktionsaufruf
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
F()
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
F()
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wenn \fIF\fP keine Prozedurvariable ist. Ist \fIF\fP eine Prozedurvariable, so
ist, da Prozedurtypen in C als Zeiger auf Funktionen repr\(a:sentiert
werden, eine zus\(a:tzliche Dereferenzierung notwendig:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
(*F)()
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Die Klammerung von \%*\fIF\fP ist notwendig, weil in C der Vorrang von
() gr\(o:\(sser ist als der Vorrang von *.
.sp 0.4v
.ne 2v
.ti +2n
Eine Dereferenzierung gefolgt von der Selektion einer Verbundkomponente
wird auf den in C speziell f\(u:r diese Operationsfolge
vorgesehenen Operator \%\-> abgebildet.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Operatoren\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Operatoren
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die arithmetischen Operatoren werden entsprechend der folgenden
Tabelle nach C abgebildet:
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
ce| ce
cefTT| cefTT.
Modula-2|C
_
+|+
-|-
*|*
/|/
DIV|/
MOD|%
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.2\fP: Abbildung der arithmetischen Operatoren
.ce 0
.zE
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Im Gegensatz zu \%Modula-2 ist allerdings in der C-Sprachbeschreibung
nicht eindeutig definiert, welches Ergebnis die Operatoren / und %
liefern, falls einer der Operanden eine negative Zahl ist. Bei
der Abbildung werden aber solche m\(o:glichen Unterschiede in der
Arithmetik nicht ber\(u:cksichtigt.
.sp 0.4v
.ne 2v
.ti +2n
Da sowohl \%Modula-2 als auch C die Kurzauswertung logischer Ausdr\(u:cke
verlangen, k\(o:nnen die logischen Operatoren \%NOT, \%AND und \%OR
direkt auf die C-Operatoren \%!, \%&& und \%|| abgebildet werden.
.sp 0.4v
.ne 2v
.ti +2n
Mit der vereinfachenden Annahme, da\(ss alle Mengen nur Wortgr\(o:\(sse
(\%\fIunsigned\fP \%\fIlong\fP) haben, k\(o:nnen die Mengenoperatoren
in C leicht mit Hilfe der Operatoren zur Bitmanipulation
realisiert werden. Die folgende Tabelle zeigt die
\(U:bersetzung der Mengenoperatoren:
.sp 1.5
.zA
.TS
delim($$)tab(;) center box;
ce| ce
cefTT| cefTT.
Modula-2;C
_
+;|
-;SET_DIFF
*;&
/;^
\&=;==
#;!=
<=;SET_IS_SUBSET1
>=;SET_IS_SUBSET2
IN;IN
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.3\fP: Abbildung der Mengenoperatoren
.ce 0
.zE
.sp 1.5
Die Makros \%SET_DIFF, \%IN,
\%SET_IS_SUBSET1 und \%SET_IS_SUBSET2 sind in \%SYSTEM.h
wie folgt definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define SET_DIFF(s1,s2)         ((s1) & ~(s2))
#define IN(x,s)                 ((BOOLEAN)((s) >> (x) & 0X1L))
.zE
.zA
#define SET_IS_SUBSET1(s1,s2)   ((BOOLEAN)!((s1) & ~(s2)))
#define SET_IS_SUBSET2(s1,s2)   ((BOOLEAN)!((s2) & ~(s1)))
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Aufgrund der oben angegebenen Abbildung der Modula-Typen nach C, k\(o:nnen
die relationalen Operatoren von \%Modula-2 immer direkt auf die
relationalen Operatoren von C abgebildet werden.
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Ausdr\(u:cke (s. Beispiele Kap. \n(h1.4.3)
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
i DIV 3
NOT p OR q
(i + j) * (i - j)
s - {8, 9, 13}
(1 <= i) AND (i < 100)
.br
.ne 3
t^.Key = 0
{13..15} <= s
i IN {0, 5..8, 15}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
werden in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
i / 3
!p || q
(i + j) * (i - j)
SET_DIFF(s, SET_ELEM(8) | SET_ELEM(9) | SET_ELEM(13))
1 <= i && i < 100
.br
.ne 3
t->Key == 0
SET_IS_SUBSET1(SET_cRNG(13, 15), s)
IN(i, SET_ELEM(0) | SET_cRNG (5, 8) | SET_ELEM(15))
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.br
.ne 4
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Anweisungen\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Anweisungen
.hE 4n 5n 0v
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Zuweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Zuweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Aufgrund der Abbildung der Typen nach C kann \(em mit
einer Ausnahme \(em die Zuweisung direkt auf den C-Zuweisungsoperator
= abgebildet werden. Die einzige Ausnahme ist die Zuweisung von
Zeichenketten, die mit der Bibliotheksfunktion \fIstrncpy\fP durchgef\(u:hrt
wird. Die Funktion \%\fIstrncpy\^(s,\|t,\|n)\fP kopiert eine
Zeichenkette, die \(em wie in C \(u:blich \(em durch ein NUL-Zeichen beendet
wird von \fIt\fP nach \fIs\fP.
Es werden jedoch maximal die als drittes Argument \fIn\fP \(u:bergebene
Anzahl von Zeichen kopiert. Damit kann gerade die in \%Modula-2
f\(u:r die Zuweisung von Zeichenketten geltende Regel ,,Zeichenketten
der L\(a:nge \fIn1\fP k\(o:nnen auch an Felder von Zeichen der L\(a:nge
\%\fIn2\ >\ n1\fP
zugewiesen werden. Der Wert der Zeichenkette wird in diesem Fall
um ein NUL-Zeichen verl\(a:ngert.'' implementiert werden. Die
folgenden Zuweisungen (s. Beispiele Kap. \n(h1.4.3)
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
w := v;
F := log2;
s := {2, 3, 5..7, 11};
.br
.ne 3
t^.Key := j;
w[i+1].ch := "a";
S := "hello world";
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
werden somit in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
w = v;
F = log2;
s = SET_ELEM(2) | SET_ELEM(3) | SET_cRNG(5, 7) | SET_ELEM(11);
.br
.ne 3
t->Key = j;
w.A[i+1].ch = 'a';
(void)strncpy(S.A, "hello world", sizeof(S.A));
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Es sei an dieser Stelle noch einmal ausdr\(u:cklich darauf hingewiesen, da\(ss
auch das Feld \fIv\fP, wegen der Abbildung von Feldern auf Strukturen mit
einem Vektor als Komponente, an das Feld \fIw\fP als Ganzes zugewiesen werden kann.
Wie bereits erw\(a:hnt, wird dabei allerdings vorausgesetzt, da\(ss
der C-\(U:bersetzer Strukturen als Ganzes zuweisen kann.
.sp 0.4v
.ne 2v
.ti +2n
Der Name einer Funktion wird in C, wenn er nicht zum Aufruf der Funktion
verwendet wird, als Zeiger auf die Funktion verstanden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Prozeduraufruf\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Prozeduraufruf
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Aufruf einer Prozedur wird in einen Aufruf der
entsprechenden C-Funktion \(u:bersetzt. Handelt es sich beim Bezeichner
der Prozedur um eine Prozedurvariable, dann ist, wegen der Abbildung
der Prozedurtypen auf Zeiger auf Funktionen, eine Dereferenzierung
beim Aufruf notwendig.
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung der aktuellen Parameter ist abh\(a:ngig von der Art
der formalen Parameter:
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter ein Wertparameter (kein offenes Feld), dann
wird der aktuelle Parameter in den entsprechenden C-Ausdruck
\(u:bersetzt. Die \(U:bergabe von Zeichenketten
macht dabei aber aus zwei Gr\(u:nden Schwierigkeiten:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Zeichenketten werden in C auf Zeichenketten
oder einen initialisierten Vektor von Zeichen
abgebildet. Felder von Zeichen werden auf eine Struktur mit
einem Vektor von Zeichen als Komponente abgebildet.
Zeichenketten bzw. Vektoren werden in C aber im Gegensatz zu Strukturen nicht
als Ganzes an eine Funktion \(u:bergeben, sondern es wird nur ein Zeiger auf den
Anfang der Zeichenkette bzw. des Vektors \(u:bergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der Parameter\(u:bergabe gelten die gleichen Regeln wie bei
der Zuweisung. Das bedeutet, da\(ss die L\(a:nge der Zeichenkette kleiner
sein darf, als die L\(a:nge des als formaler Parameter angegebenen
Feldes.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Diese beiden Probleme k\(o:nnen gel\(o:st werden, indem die Zeichenkette
vor dem Aufruf der Funktion an eine tempor\(a:re
Feldvariable zugewiesen und dann diese Feldvariable als aktueller
Parameter \(u:bergeben wird.
Die L\(o:sung ist allerdings wegen der zus\(a:tzlichen Zuweisung nicht
besonders effizient.
Der Aufruf der Prozedur \fIWriteString\fP aus dem
folgenden Ausschnitt eines Modula-Programms
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE WriteString (s : tString);
  ...
WriteString ("hello world");
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
wird in C dann zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
tString X_1;
  ...
(void)strncpy(X_1.A, "hello world", sizeof(X_1.A));
  ...
WriteString(X_1);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter ein Referenzparameter (kein offenes Feld), dann mu\(ss
der aktuelle Parameter eine Variable sein. Da Referenzparameter in C auf
Zeiger abgebildet werden, mu\(ss die Adresse dieser Variablen in C bei
der Parameter\(u:bergabe mit dem Operator & bestimmt und \(u:bergeben werden.
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter ein offenes Feld, dann mu\(ss in C
die Adresse des aktuellen Parameters \(u:bergeben
werden. Dies gilt auch dann, wenn das als formaler
Parameter angegebene offene Feld ein Wertparameter ist
(vgl. Kap. \n(h1.4.4.1.2).
Dabei m\(u:ssen, entsprechend der Art des aktuellen Parameters,
folgende F\(a:lle unterschieden werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Wenn der aktuelle Parameter eine Zeichenkette ist, dann
wird in C automatisch ein Zeiger auf das erste Zeichen dieser
Zeichenkette \(u:bergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ist der aktuelle Parameter ein offenes Feld, dann wird in C wegen
der Abbildung der offenen Felder auf Vektoren automatisch ein Zeiger auf
den Feldanfang \(u:bergeben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Falls der aktuelle Parameter in C weder eine Zeichenkette
noch ein Vektor ist, dann mu\(ss die Adresse
des aktuellen Parameters wie \(u:blich mit dem Operator & bestimmt
werden.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Zus\(a:tzlich zur Adresse des Feldes mu\(ss in C ein
Parameter mit der Anzahl von Feldelementen \(u:bergeben werden. Falls der
aktuelle Parameter ebenfalls ein offenes Feld ist, wird der zu diesem
Feld dazugeh\(o:rige Parameter mit der Anzahl von Feldelementen
\(u:bergeben. Sonst ist die Anzahl von Feldelementen bei der \(U:bersetzung
bekannt und wird als Konstante in das C-Programm eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
\%MOCKA erlaubt \(em im Gegensatz zur
Sprachbeschreibung von \%Modula-2 \(em auch Zeichenketten als aktuelle
Parameter, wenn das offene Feld ein Referenzparameter ist. Mit der oben
beschriebenen Abbildung wird auch dieser Fall abgedeckt.
.sp 0.4v
.ne 2v
.ti +2n
Die \(U:bersetzung des folgenden Ausschnitts eines Modula-Programms
demonstriert die \(U:bergabe von offenen Feldern
als Parameter noch einmal (s. Beispiele Kap. \n(h1.4.3):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
PROCEDURE p (VAR s1: ARRAY OF CHAR; s2: ARRAY OF CHAR);
BEGIN
  q (s1, s2);
END p;
.zE
.zA
  ...
p (S, "hello world");
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Dieser Ausschnitt wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
void p(s1, O_3, s2, O_4)
CHAR s1[]; LONGCARD O_3;
CHAR s2[]; LONGCARD O_4;
{
    OPEN_ARRAY_LOCALS
.sp 0.4v
    ALLOC_OPEN_ARRAYS(O_4 * sizeof(CHAR), 1);
    COPY_OPEN_ARRAY(s2, O_4, CHAR);
.sp 0.4v
    q(s1, O_3, s2, O_4);
.sp 0.4v
    FREE_OPEN_ARRAYS
}
.br
.ne 2
  ...
p(S.A, 256L, "hello world", 11L);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&IF-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&IF-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die \fIif\fP\^-Anweisung
in C entspricht genau der IF-Anweisung in \%Modula-2,
wenn man bedenkt, da\(ss der ELSIF-Teil von \%Modula-2 nur eine
abk\(u:rzende Schreibweise f\(u:r Ketten von Bedingungen ist.
Damit wird
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
IF (ch >= "A") AND (ch <= "Z") THEN
  ReadIdentifier;
ELSIF (ch >= "0") AND (ch <= "9") THEN
  ReadNumber;
ELSE
  SpecialCharacter;
END
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
if (ch >= 'A' && ch <= 'Z') {
    ReadIdentifier();
} else if (ch >= '0' && ch <= '9') {
    ReadNumber();
.br
.ne 2
} else {
    SpecialCharacter();
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&CASE-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&CASE-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die CASE-Anweisung wird in eine \fIswitch\fP\^-Anweisung
\(u:bersetzt. Alle in \%Modula-2 f\(u:r die Fallmarken zul\(a:ssigen Typen
sind, mit der oben beschriebenen Abbildung der Typen nach C, auch in
C f\(u:r den \fIswitch\fP\^-Ausdruck und
die Fallmarken zul\(a:ssig. Die Listen mit Fallmarken
und Bereichsangaben
werden in eine Folge von C-Fallmarken der Form
\%\fIcase\ constant\ :\fP umgesetzt. Konstante Ausdr\(u:cke, die in
\%Modula-2 als Fallmarken zul\(a:ssig sind, m\(u:ssen dabei bereits
w\(a:hrend der \(U:bersetzung nach C ausgewertet werden, wenn der entsprechende
C-Ausdruck kein konstanter Ausdruck ist.
Die \fIdefault\fP\^-Marke der \fIswitch\fP\^-Anweisung entspricht
dem ELSE-Teil der
CASE-Anweisung.
.sp 0.4v
.ne 2v
.ti +2n
Die Anweisung
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CASE ch OF
| "A".."Z" : ReadIdentifier;
| "0".."9" : ReadNumber;
ELSE
  SpecialCharacter;
END
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
wird in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
switch (ch) {
case 'A' :
case 'B' :
  ...
.br
.ne 3
case 'Z' :
    ReadIdentifier();
    break;
.sp 0.4v
.br
.ne 2
case '0' :
  ...
.br
.ne 3
case '9' :
    ReadNumber();
    break;
.sp 0.4v
.br
.ne 3
default :
    SpecialCharacter();
    break;
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
In C mu\(ss nach jeder Anweisungsfolge, die zu einer Folge von Fallmarken
geh\(o:rt, eine \fIbreak\fP\^-\%An\%wei\%sung stehen, damit die
\fIswitch\fP\^-Anweisung verlassen wird.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Schleifen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Schleifen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die \%WHILE-, \%REPEAT- und LOOP-Schleife werden folgenderma\(ssen
nach C \(u:bersetzt:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
while (...) {          do {                      for (;;) {
  ...                    ...                       ...
}                      } while (!(...))          } EXIT_xxx:;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Die Marke \fIEXIT_xxx\fP dient als Sprungziel f\(u:r die \fIgoto\fP\^-Anweisungen, in
welche die EXIT-Anweisungen innerhalb der LOOP-Schleife \(u:bersetzt werden.
.sp 0.4v
.ne 2v
.ti +2n
Eine direkte \(U:bersetzung der FOR-Schleife
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FOR v := a TO b BY c DO ... END;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in die \fIfor\fP\^-Schleife der Sprache C
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
for (v = a; v <= b; v += c) { ... };    /* falls c >= 0 */
for (v = a; v >= b; v += c) { ... };    /* falls c <  0 */
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
ist wegen der unterschiedlichen Semantik der beiden Schleifenkonstrukte
in den meisten F\(a:llen nicht m\(o:glich. \%Modula-2 verlangt, da\(ss
Anfangs- und Endwert der Schleife genau einmal vor dem ersten
Schleifendurchlauf ausgewertet werden. Die Schrittweite \fIc\fP mu\(ss ein
konstanter Ausdruck sein. In C wird der zweite Ausdruck der \fIfor\fP\^-Schleife
vor jedem Schleifendurchlauf ausgewertet. Ist au\(sserdem der Typ \fIT\fP
der
Schleifenkontrollvariablen \fIv\fP ein arithmetischer Typ und gilt f\(u:r den
Endwert der
Schleife \fIb\fP, da\(ss
\%\fIb\fP\ \(>=\ MAX\^(\fIT\fP\|)\ -\ \fIc\fP\ +\ 1
(falls \%\fIc\fP\ >\ 0)
bzw.
\%\fIb\fP\ \(<=\ MIN\^(\fIT\fP\|)\ -\ \fIc\fP\ -\ 1
(falls \%\fIc\fP\ <\ 0), dann
terminiert die Schleife in C nicht, da die Schleifenkontrollvariable am
Schleifenende vor der erneuten Auswertung der Abbruchbedingung inkrementiert
wird und ein unbemerkter \(U:ber- bzw. Unterlauf stattfindet.
.sp 0.4v
.ne 2v
.ti +2n
Daher wird die obige FOR-Schleife bei positiver Schrittweite \fIc\fP in
die folgende zusammengesetzte C-Anweisung \(u:bersetzt:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
{
    T B_xxx = a, B_nnn = b;
.sp 0.4v
.br
.ne 6
    if (B_xxx <= B_nnn)
      for (v = B_xxx, B_nnn = FOR_LIMIT_UP(B_nnn, c, MIN(T));; v += c) {
          ...
          if (v >= B_nnn) break;
      }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Bei negativer Schrittweite \fIc\fP wird die FOR-Schleife in C zu:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
{
    T B_xxx = a, B_nnn = b;
.sp 0.4v
.br
.ne 6
    if (B_xxx >= B_nnn)
      for (v = B_xxx, B_nnn = FOR_LIMIT_DOWN(B_nnn, c, MAX(T));; v += c) {
          ...
          if (v <= B_nnn) break;
      }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Diese \(U:bersetzung der FOR-Schleife vermeidet die oben angesprochenen
Schwierigkeiten, da Anfangs- und Endwert der Schleife nur einmal ausgewertet
werden und die Abbruchbedingung am Schleifenende gepr\(u:ft wird, bevor die
Schleifenkontrollvariable inkrementiert wird.
Durch den Aufruf der in \%SYSTEM.h definierten Makros
\%FOR_LIMIT_UP und \%FOR_LIMIT_DOWN wird der Schleifenendwert vor der
ersten Ausf\(u:hrung des Schleifenrumpfes geeignet korrigiert, um einen
\(U:ber- bzw. Unterlauf der Schleifenkontrollvariablen zu verhindern. Die
beiden Makros haben folgende Definition:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
#define FOR_LIMIT_UP(last, step, min) \e
    ((last) < (min) + ((step) - 1) ? (min) : (last) - ((step) - 1))
.sp 0.4v
#define FOR_LIMIT_DOWN(last, step, max) \e
    ((last) > (max) + ((step) + 1) ? (max) : (last) - ((step) + 1))
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Ist der Wert der Schrittweite \%\fIc\fP\ \(mo\ {-1,\ 0,\ 1}, dann ist die
Korrektur des Schleifenendwertes \(u:berfl\(u:ssig und wird weggelassen.
.sp 0.4v
.ne 2v
.ti +2n
Wegen der damit verbundenen besseren Lesbarkeit der C-Programme, wird
die FOR-Schleife in die ,,normale'' \fIfor\fP\^-Schleife der Sprache C \(u:bersetzt,
wenn der Endwert der Schleife eine Konstante ist und ein \(U:ber- bzw.
Unterlauf der Schleifenkontrollvariablen nicht auftreten kann.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&WITH-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&WITH-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die WITH-Anweisung
hat kein direktes Gegenst\(u:ck in C. Sie wird in eine
zusammengesetzte Anweisung \(u:bersetzt, die am Anfang die Deklaration
und Initialisierung einer Zeigervariablen enth\(a:lt. Diese Zeigervariable
wird mit der Adresse der Struktur initialisiert, die dem in
der WITH-Anweisung
angesprochenen Verbund des Modula-Programms entspricht.
Innerhalb der WITH-Anweisung
wird in C dann \(u:ber diese Zeigervariable
auf die Strukturkomponenten zugegriffen.
Diese \(U:bersetzung erf\(u:llt die Forderung der Sprachdefinition von
\%Modula-2, da\(ss der Selektor, welcher den in der
WITH-Anweisung
angesprochenen Verbund festlegt, nur einmal ausgewertet wird.
Damit wird die folgende Anweisung
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
WITH t^ DO
  Key := 0; Left := NIL; Right := NIL;
END
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
{
    register tNode *W_1 = t;
.sp 0.4v
    W_1->Key = 0; W_1->Left = NIL; W_1->Right = NIL;
}
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&RETURN-Anweisung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&RETURN-Anweisung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die \fIreturn\fP\^-Anweisung
in C entspricht genau der RETURN-An\%wei\%sung in
\%Modula-2, wobei allerdings die \(em aus der Sprachdefinition von
\%Modula-2 nicht eindeutig hervorgehende \(em Einschr\(a:nkung gemacht
wird, da\(ss der Ergebnistyp einer Funktion kein Feld- oder Verbundtyp
sein darf\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ \%MOCKA macht diese Einschr\(a:nkung auch.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Wie oben erw\(a:hnt m\(u:ssen vor jeder RETURN-An\%wei\%sung die vor
dem Aufruf der betreffenden Prozedur bzw. Funktion \fIP\fP g\(u:ltigen Werte
der globalen Zeigervariablen, die zur \(U:bersetzung des Zugriffs auf lokale
Variablen von \fIP\fP ben\(o:tigt werden, wiederhergestellt werden.
Au\(sserdem mu\(ss der Speicherplatz wieder freigegeben werden, der
f\(u:r die als Wertparameter \(u:bergebenen offenen Felder angefordert wurde.
Enth\(a:lt bei einer Funktion der RETURN-Ausdruck aber einen
Zugriff auf ein offenes Feld oder den Aufruf einer (lokalen) Funktion, dann
d\(u:rfte das Zur\(u:ckschreiben der alten Werte der globalen Zeigervariablen und
die Freigabe des Speichers eigentlich erst nach der RETURN-Anweisung erfolgen,
was nicht m\(o:glich ist. In diesem Fall wird daher die RETURN-Anweisung zu einer
zusammengesetzten Anweisung, die am Anfang die Deklaration einer lokalen
Variablen enth\(a:lt, welche mit dem RETURN-Ausdruck initialisiert wird. Danach erst
werden die alten Werte der globalen Zeigervariablen zur\(u:ckgeschrieben, der
Speicher f\(u:r offene Felder freigegeben und der Wert des RETURN-Ausdrucks an
die aufrufende Prozedur zur\(u:ckgeliefert. Damit wird der folgende Ausschnitt
eines Modula-Prgramms
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
PROCEDURE p (a : ARRAY OF CHAR): CHAR;
BEGIN
  ...
  RETURN a[0];
END p;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in C zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
CHAR p(a, O_5)
CHAR a[]; LONGCARD O_5;
{
    ...
.br
.ne 3
    {
        CHAR R_1 = a[0];
.sp 0.4v
.br
.ne 4
        FREE_OPEN_ARRAYS
        RETURN R_1;
    }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Laufzeitpr\(u:fungen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Laufzeitpr\(u:fungen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Durch die Angabe einer Option bei der \(U:bersetzung kann man \%\fIMtc\fP dazu
veranlassen, Laufzeitpr\(u:fungen zu erzeugen, die die Abgabe einer
entsprechenden Fehlermeldung mit Angabe der Position im C-Quellprogramm und
den Abbruch des C-Programms zur Folge haben, falls
in einer CASE-Anweisung durch den Selektorausdruck keine Fallmarke ausgew\(a:hlt
wird und der ELSE-Teil fehlt oder falls eine Funktion kein Ergebnis liefert.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Modul SYSTEM\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Modul SYSTEM
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
C ist eine relativ ,,maschinennahe'' Sprache. Daher steht ein gro\(sser
Teil der in Modula-2 vom Modul \%SYSTEM zur Verf\(u:gung gestellten
Hilfsmittel f\(u:r die maschinennahe Programmierung auch in C zur
Verf\(u:gung.
.sp 0.4v
.ne 2v
.ti +2n
Da C allerdings keine Koroutinen kennt, m\(u:\(sste man diese
in C auf geeignete Weise simulieren. Da aber eine Simulation sowohl
aufwendig als auch ineffizient w\(a:re und au\(sserdem die Verwendung
von Koroutinen, wenn es sich nicht um spezielle Systemprogramme
handelt, relativ selten ist, unterst\(u:tzt der \(U:bersetzer die
Abbildung von \%NEWPROCESS, \%TRANSFER und \%IOTRANSFER nicht.
.sp 0.4v
.ne 2v
.ti +2n
Die vom \(U:bersetzer unterst\(u:tzten Objekte aus dem Modul \%SYSTEM
sind: die Typen \%WORD und \%ADDRESS, die Funktionen \%ADR
und \%TSIZE
sowie die Funktionen f\(u:r den Typtransfer. Au\(sserdem wird noch die
von \%MOCKA implementierte Spracherweiterung
um den Typ \%BYTE, der synonym zum Typ \%WORD ist, ber\(u:cksichtigt.
.sp 0.4v
.ne 2v
.ti +2n
Eine Typtransferfunktion wird in C als eine explizite Umwandlung
in den angegebenen Typ realisiert, die dadurch ausgedr\(u:ckt wird, da\(ss
dem betreffenden Wert der Name des gew\(u:nschten Datentyps in Klammern
vorangestellt wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Typen \%BYTE und \%WORD sind in \%SYSTEM.h folgenderma\(ssen
definiert:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef unsigned char WORD;
typedef WORD          BYTE;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Damit die \(U:bergabe eines aktuellen Parameters an eine Prozedur, in
welcher der entsprechende formale Parameter den Typ \%WORD bzw. \%BYTE
hat, auch in C korrekt funktioniert, m\(u:ssen alle Typen, die bei der
Typabbildung von \%MOCKA die gleiche Gr\(o:\(sse wie \%WORD bzw.
\%BYTE zugewiesen bekommen, auch in C die gleiche Gr\(o:\(sse haben.
.sp 0.4v
.ne 2v
.ti +2n
Ist der formale Parameter einer Prozedur vom Typ \%ARRAY\ OF\ WORD
bzw. \%ARRAY\ OF\ BYTE, dann hat die entsprechende C-Funktion
\(em wie bei allen offenen Feldern \(em einen zus\(a:tzlichen Parameter,
der die aktuelle Anzahl von Feldelementen enth\(a:lt.
Bei der Parameter\(u:bergabe mu\(ss bestimmt werden, welche Gr\(o:\(sse in
Worten bzw. Bytes der aktuelle Parameter hat. Abgesehen davon
wird ein offenes Feld mit Elementen vom Typ \%WORD bzw. \%BYTE
genauso behandelt
wie jedes andere offene Feld auch. Der folgende Ausschnitt
eines Modula-Programms
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
PROCEDURE WriteBytes (VAR a: ARRAY OF WORD);
  ...
WriteBytes (w);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
wird in C zu
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
void WriteBytes(a, O_6)
WORD a[]; LONGCARD O_6;
  ...
WriteBytes(&w, sizeof(w));
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
Bei dieser Abbildung wird angenommen, da\(ss
\%\fIsizeof\fP\|(WORD) bzw. \%\fIsizeof\fP\|(BYTE)
den Wert 1 haben.
Ist der aktuelle Parameter ein offenes Feld, dann ist die
Gr\(o:\(sse des aktuellen Parameters in Worten bzw. Bytes:
\%\fIsizeof\^(Elementtyp)\fP * \fIaktuelle Anzahl von Feldelementen\fP.
.sp 0.4v
.ne 2v
.ti +2n
Der Typ \%ADDRESS ist definiert als:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef unsigned char *ADDRESS;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
In \%Modula-2 ist der Typ \%ADDRESS kompatibel mit allen anderen
Zeigertypen. Wegen der in C vorhandenen M\(o:glichkeit Zeiger verschiedenen
Typs einander zuzuweisen oder einen Zeiger an eine Funktion zu \(u:bergeben,
dessen Typ sich vom Typ des formalen Parameters unterscheidet, erfordert
diese in \%Modula-2 definierte Typkompatibilit\(a:t bei der Abbildung
nach C keine spezielle Behandlung.
Allerdings wird bei der Zuweisung in C eine explizite Typumwandlung erzeugt,
um sonst vom C-\(U:bersetzer ausgegebene Warnungen zu unterdr\(u:cken.
.sp 0.4v
.ne 2v
.ti +2n
In Modula-2 k\(o:nnen alle
arithmetischen Operatoren auf Operanden mit Typ \%ADDRESS angewandt
werden, da \%ADDRESS auch kompatibel mit dem Typ \%CARDINAL ist.
Damit k\(o:nnen beliebige Adre\(ssberechnungen durchgef\(u:hrt werden. In C kann nur
ein ganzzahliger Wert zu einem Zeiger addiert oder von einem Zeiger
subtrahiert werden und zwei Zeiger
k\(o:nnen subtrahiert werden. Au\(sserdem ist in C Zeigerarithmetik so
definiert, da\(ss der Ausdruck \fIp+1\fP den Wert von \fIp\fP, erh\(o:ht um
die Gr\(o:\(sse des Objekts auf welches \fIp\fP zeigt, liefert.
Hat \%\fIsizeof\^(ADDRESS)\fP den Wert 1, dann ergibt sich
hier allerdings
kein Unterschied zur
Adre\(ssarithmetik in Modula-2.
Wird daher im Modula-Programm der Typ \%ADDRESS innerhalb von arithmetischen
Ausdr\(u:cken in einer in C nicht zul\(a:ssigen Kombination verwendet, dann wird
der betreffende Operand in C zuerst in den Typ \%CARDINAL umgewandelt und falls
notwendig der Wert des gesamten Ausdrucks in den Typ \%ADDRESS
zur\(u:ckgewandelt\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ MOCKA definiert, da\(ss ein arithmetischer Ausdruck in dem
mindestens ein Operand den Typ \%ADDRESS hat den Resultattyp \%ADRRESS
hat.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktion \%TSIZE wird, wie die Standardfunktion \%SIZE, auf den
C-Operator \%\fIsizeof\fP abgebildet.
.sp 0.4v
.ne 2v
.ti +2n
\%ADR ist in \%SYSTEM.h mit Hilfe des C-Operators &
zur Adre\(ssbestimmung als folgendes Makro definiert:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define ADR(x)          ((ADDRESS) &(x))
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Da offene Felder auf Vektoren abgebildet werden und ein Vektorname als
Ausdruck einen Zeiger auf das erste Element des Vektors liefert,
wird f\(u:r die Bestimmung der Adresse eines offenen Feldes das
Makro \%ADR1 anstelle von \%ADR benutzt:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define ADR1(x)         ((ADDRESS) x)
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.br
.ne 4
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&\(U:bersetzungseinheiten\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&\(U:bersetzungseinheiten
.hE 4n 5n 0v
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Definitionsmoduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Definitionsmoduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Ein Definitionsmodul \%\fIM.md\fP wird in eine Definitionsdatei
\%\fIM.h\fP \(u:bersetzt, die die vom Modul \fIM\fP exportierten Gr\(o:\(ssen beschreibt.
Diese Definitionsdatei wird mit einer
\fI#include\fP\^-An\%wei\%sung in alle
Moduln, die \fIM\fP importieren und in das
C-Programm \%\fIM.c\fP, welches die \(U:bersetzung des zu
\%\fIM.md\fP dazugeh\(o:rigen Implementierungsmoduls ist, eingef\(u:gt.
.sp 0.4v
.ne 2v
.ti +2n
Alle im Definitionsmodul \%\fIM.md\fP vereinbarten
Objekte werden in C in der qualifizierten Form \%\fIM_Objektname\fP geschrieben\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ 
Ausnahme: Die Komponentennamen einer Struktur werden in unqualifizierter Form
geschrieben, da sie immer bereits durch den Namen der Struktur, die sie enth\(a:lt,
qualifiziert sind.
.nE
\&.
.sp 0.4v
.ne 2v
.ti +2n
Konstanten- und Typdefinitionen werden wie im Kapitel \(u:ber
Deklarationen besprochen nach C umgesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Die Definitionsdatei enth\(a:lt
eine \fIextern\fP\^-Deklaration f\(u:r jede exportierte Variable. Diese Deklaration
legt die Eigenschaften wie Datentyp und Speicherbedarf der Variablen fest,
damit sie in allen Moduln, die die Variable benutzen, bekannt sind. Mit der
\fIextern\fP\^-Deklaration wird aber kein Speicherplatz reserviert. Die eigentliche
Vereinbarung der Variablen, die daf\(u:r sorgt, da\(ss Speicherplatz reserviert
wird, ist in \%\fIM.c\fP enthalten.
.sp 0.4v
.ne 2v
.ti +2n
Wird in der Definition einer exportierten Variablen ein anonymer strukturierter
Typ verwendet, so enth\(a:lt in C nur die \fIextern\fP\^-Deklaration in der
Definitionsdatei die vollst\(a:ndige Strukturdeklaration dieses Typs. In der
eigentlichen Vereinbarung in \%\fIM.c\fP wird der in der
\fIextern\fP\^-Deklaration eingef\(u:hrte Strukturname zur Beschreibung des Typs
verwendet. Diese Unterscheidung ist notwendig, da eine doppelt vorhandene
vollst\(a:ndige Strukturdeklaration vom C-\(U:bersetzer als unzul\(a:ssige
Redeklaration der betreffenden Struktur zur\(u:ckgewiesen wird. Somit wird der
folgende Ausschnitt des Definitionsmoduls \fIParser.md\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
VAR ParsTab : ARRAY [0..127] OF CHAR;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in der Definitionsdatei \fIParser.h\fP zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
extern struct Parser_1 {
    CHAR A[127 + 1];
} Parser_ParsTab;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
und im Programm \fIParser.c\fP zu
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
struct Parser_1 Parser_ParsTab;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Da Zeichenketten der L\(a:nge \%n\ >\ 1 auf einen initialisierten Zeichenvektor
abgebildet werden, mu\(ss eine in einem Definitionsmodul als Konstante vereinbarte
Zeichenkette bei der \(U:bersetzung nach C wie eine exportierte Variable behandelt
werden. Das bedeutet, da\(ss in der Definitionsdatei \%\fIM.h\fP eine
\fIextern\fP\^-Deklaration und im Programm \%\fIM.c\fP die eigentliche
Vereinbarung und Initialisierung der Konstante enthalten ist.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r jede von \fIM\fP exportierte Prozedur ist
ebenfalls eine \fIextern\fP\^-Deklaration vorhanden, die den Namen und den
Ergebnistyp der f\(u:r die Prozedur erzeugten C-Funktion in allen Moduln
bekannt macht, die die Prozedur importieren.
.sp 0.4v
.ne 2v
.ti +2n
Der Definitionsmodul \%\fITree.md\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 6
DEFINITION MODULE Tree;
.sp 0.4v
CONST  NoTree   = NIL;
.sp 0.4v
TYPE
  tTree         = POINTER TO tNode;
  tNode         = RECORD
                    Key   : INTEGER;
                    Left  ,
                    Right : tTree;
                  END;
.sp 0.4v
.br
.ne 5
VAR  Root       : tTree;
.sp 0.4v
PROCEDURE MakeNode (Key: INTEGER; Left, Right: tTree): tTree;
.sp 0.4v
END Tree.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zur Definitionsdatei \fITree.h\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
#define Tree_NoTree     NIL
.sp 0.4v
typedef struct Tree_1 *Tree_tTree;
.zA
typedef struct Tree_1 {
    INTEGER    Key;
    Tree_tTree Left, Right;
} Tree_tNode;
.zE
.sp 0.4v
.br
.ne 3
extern  Tree_tTree Tree_Root;
.sp 0.4v
extern  Tree_tTree Tree_MakeNode();
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&FOREIGN-Moduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&FOREIGN-Moduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%MOCKA erlaubt es, da\(ss in C
geschriebene Prozeduren im Modula-Programm aufgerufen werden. Diese
Prozeduren m\(u:ssen in sogenannten \%FOREIGN-\%Mo\%dul deklariert sein,
die als Definitionsmoduln fungieren\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ FOREIGN-Mo\%duln k\(o:nnen auch
Typ- und Konstantendeklarationen enthalten.
.nE
\&.
Bei der \(U:bersetzung von \%Modula-2
nach C wird ein FOREIGN-\%Mo\%dul im Prinzip
wie ein
Definitionsmodul behandelt. Der einzige Unterschied ist, da\(ss alle
dort definierten Prozeduren im erzeugten C-Programm nicht mit dem
Modulnamen qualifiziert werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Implementierungs- und Programmoduln\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Implementierungs- und Programmoduln
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Ein Implementierungs- oder Programmodul \%\fIM.mi\fP wird in ein C-Programm
\%\fIM.c\fP \(u:bersetzt. \%\fIM.c\fP enth\(a:lt neben
der \(U:bersetzung der im Implementierungs- oder Programmodul enthaltenen
Konstanten-, Typ-, Variablen- und Prozedurdeklarationen
auch Vereinbarungen f\(u:r die in der Definitionsdatei
\%\fIM.h\fP in \fIextern\fP\^-Deklarationen erw\(a:hnten
exportierten Variablen.
.sp 0.4v
.ne 2v
.ti +2n
\%SYSTEM.h mit der Definition der Standardtypen, -prozeduren
und -funktionen wird in
jedes erzeugte C-Programm als erste Definitionsdatei eingef\(u:gt.
.sp 0.4v
.ne 2v
.ti +2n
Da auch in C eine getrennte \(U:bersetzung m\(o:glich ist, k\(o:nnen alle vom
\(U:bersetzer f\(u:r Implementierungs- bzw. Programmoduln erzeugten
C-Programme vom C-\(U:bersetzer getrennt \(u:bersetzt werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&IMPORT-Anweisungen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&IMPORT-Anweisungen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
IMPORT-Anweisungen werden in eine Folge von
\fI#include\fP\^-An\%wei\%sun\%gen \(u:bersetzt.
Damit eine Definitionsdatei nicht mehrfach in ein C-Programm eingef\(u:gt
wird\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Mehrfach vorhandene identische Typ- bzw. Konstantendeklarationen innerhalb
einer Quelldatei sind in C nicht zul\(a:ssig.
.nE
\&, wird am Anfang jeder
Definitionsdatei \%\fIM.h\fP der Makroname \%DEFINITION_\fIM\fP mit einer
\fI#define\fP\^-An\%wei\%sung definiert und die IMPORT-Anweisung
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FROM M IMPORT ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
in die Pr\(a:prozessor-Anweisungen
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#ifndef DEFINITION_M
#include "M.h"
#endif
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
\(u:bersetzt. Damit wird erreicht, da\(ss die Definitionsdatei \%\fIM.h\fP
nur genau einmal in eine Quelldatei eingef\(u:gt wird.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Opaque Typen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Opaque Typen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
In Modula-2 ist es erlaubt im Definitionsmodul nur den Namen eines Typs zu
vereinbaren, dessen vollst\(a:ndige Definition dann im Implementierungsmodul
enthalten sein mu\(ss. Diese Typen, deren Struktur den sie importierenden Moduln
unbekannt ist, werden als opaque Typen bezeichnet. Opaque Typen sind
immer Zeigertypen.
.sp 0.4v
.ne 2v
.ti +2n
Die Abbildung nach C wird folgenderma\(ssen gehandhabt: In der Definitionsdatei
wird ein opaquer Typ als
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef OPAQUE Modulname_Typname;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
vereinbart. Der Typ
\%OPAQUE ist in \%SYSTEM.h als
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
typedef ADDRESS OPAQUE;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
definiert.
.sp 0.4v
.ne 2v
.ti +2n
Da auf opaque Typen in \%Modula-2 au\(sserhalb des Moduls
in dem sie definiert sind, nur Zuweisung und Vergleich anwendbar sind,
ist bei der \(U:bersetzung von Moduln, die diese Typen importieren
keine spezielle Behandlung von opaquen Typen notwendig. Die im
Implementierungsmodul enthaltene vollst\(a:ndige Definition des opaquen Typs
wird in eine zweite \fItypedef\fP\^-Anweisung
umgesetzt. Da der Typname in der
Definitionsdatei qualifiziert wird, ergeben sich dabei keine Namenskonflikte.
Auch innerhalb des nach C \(u:bersetzten Implementierungsmoduls wird die
Typdefinition aus der Definitionsdatei in allen Deklarationen benutzt. Um
jedoch eine korrekte Anwendung des opaquen Typs in Anweisungen
zu erzwingen, wird vor jeder Dereferenzierung eine explizite Typumwandlung
in den vollst\(a:ndigen Typ eingef\(u:gt.
.sp 0.4v
.ne 2v
.ti +2n
Der Definitionsmodul \fILists.md\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 5
DEFINITION MODULE Lists;
.sp 0.4v
FROM SYSTEM     IMPORT ADDRESS;
.sp 0.4v
TYPE  tList;
.sp 0.4v
.br
.ne 3
PROCEDURE Insert (VAR List: tList; Elmt: ADDRESS);
  ...
END Lists.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zur Definitionsdatei \fILists.h\fP
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#define DEFINITION_Lists
.sp 0.4v
typedef OPAQUE Lists_tList;
.sp 0.4v
extern  void Lists_Insert();
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Der Implementierungsmodul \fILists.mi\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 6
IMPLEMENTATION MODULE Lists;
.sp 0.4v
FROM SYSTEM     IMPORT ADDRESS;
.sp 0.4v
TYPE
  tList = POINTER TO tElmt;
  tElmt = RECORD
            Elmt : ADDRESS;
            Next : tList;
          END;
.sp 0.4v
.br
.ne 3
PROCEDURE Insert (VAR List: tList; Elmt: ADDRESS);
VAR  Head : tList;
BEGIN
  Head       := MakeElmt (Elmt);
  Head^.Next := List;
  List       := Head;
END Insert;
.br
.ne 2
  ...
END Lists.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird in C zum Programm \fILists.c\fP
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
#include "SYSTEM.h"
.sp 0.4v
#ifndef DEFINITION_Lists
#include "Lists.h"
#endif
.sp 0.4v
typedef struct S_1 *tList;
.zA
typedef struct S_1 {
    ADDRESS     Elmt;
    Lists_tList Next;
} tElmt;
.zE
.sp 0.4v
.br
.ne 4
void Lists_Insert(List, Elmt)
Lists_tList *List; ADDRESS Elmt;
{
    Lists_tList Head;
.sp 0.4v
    Head = MakeElmt(Elmt);
    ((tList)Head)->Next = List;
    *List = Head;
}
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Modulinitialisierung\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Modulinitialisierung
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Modulinitialisierung wird in C mit folgendem Schema behandelt: F\(u:r
jeden Implementierungsmodul wird in C eine parameterlose
Initialisierungsroutine erzeugt. Diese ruft zun\(a:chst
die Initialisierungsroutinen aller direkt importierten Moduln in der
textuellen Reihenfolge der zugeh\(o:rigen IMPORT-Anweisungen
auf und enth\(a:lt dann die Anweisungen aus dem Rumpf des Moduls.
Um eine korrekte und vollst\(a:ndige Initialisierung aller Moduln zu
erreichen, m\(u:ssen dabei auch die IMPORT-Anweisungen aus dem zum
Implementierungsmodul dazugeh\(o:rigen Definitionsmodul ber\(u:cksichtigt werden.
Diese Reihenfolge
der Initialisierung entspricht genau der in der Sprachdefinition
von Modula-2 geforderten Reihenfolge. Damit die Initialisierungsroutine nicht
mehrfach ausgef\(u:hrt wird, enth\(a:lt sie eine boolesche Variable, die angibt,
ob die Routine bereits aufgerufen wurde. Nur beim ersten Aufruf wird sie
ausgef\(u:hrt.
Somit haben die Initialisierungsroutinen folgende Form:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
void BEGIN_Modulname()
{
    static BOOLEAN has_been_called = FALSE;
.sp 0.4v
    if (!has_been_called) {
        has_been_called = TRUE;
.sp 0.4v
.br
.ne 3
        /*
         *  Initialisierungsroutinen der
         *  importierten Moduln aufrufen.
         *
.br
.ne 5
         *  Anweisungen des Modulrumpfs
         *  ausf\(u:hren.
         */
    }
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Diese Behandlung der Modulinitialisierung erfordert zur Laufzeit einen etwas
erh\(o:hten Aufwand, da ein Teil der Initialisierungsroutinen m\(o:glicherweise
mehrfach aufgerufen wird. Der gro\(sse Vorteil dieser L\(o:sung ist aber, da\(ss
alle Moduln korrekt initialisiert werden, ohne da\(ss bei der \(U:bersetzung
des Programmoduls bestimmt werden mu\(ss, welche Moduln in einem Programm
benutzt werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Hauptprogramm\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Hauptprogramm
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Rumpf des Programmoduls bildet in \%Modula-2 das Hauptprogramm.
In C wird er zu der Funktion \%BEGIN_MODULE. Diese ruft zun\(a:chst die
Initialisierungsroutinen aller direkt importierten Moduln auf und enth\(a:lt dann
die Anweisungen aus dem Rumpf des Programmoduls.
.sp 0.4v
.ne 2v
.ti +2n
Die Datei \%SYSTEM.c enth\(a:lt eine feste Definition der Funktion
\%\fImain\fP, die in C das Hauptprogramm
bildet. Diese Funktion hat folgendes Aussehen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
int    SYSTEM_argc;
char **SYSTEM_argv;
char **SYSTEM_envp;
.sp 0.4v
.br
.ne 3
main(argc, argv, envp)
int argc;
char *argv[], *envp[];
{
  SYSTEM_argc = argc;
  SYSTEM_argv = argv;
  SYSTEM_envp = envp;
.sp 0.4v
  BEGIN_MODULE();
.sp 0.4v
.br
.ne 2
  exit(0);
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Vor dem Aufruf von \%BEGIN_MODULE werden in \%\fImain\fP die
Programmparameter behandelt. In C und unter \%UNIX k\(o:nnen beim Aufruf
eines Programms Argumente aus der Kommandozeile an das Programm \(u:bergeben
werden. Das erste Argument \%\fIargc\fP ist die Anzahl der Argumente, das
zweite Argument \%\fIargv\fP ist ein Zeiger auf einen Vektor mit
Zeichenketten, die die Argumente enthalten. Das dritte Argument \%\fIenvp\fP
schlie\(sslich erm\(o:glicht den Zugriff auf UNIX-Variablen der Aufrufumgebung.
.sp 0.4v
.ne 2v
.ti +2n
Die MOCKA-Bibliothek enth\(a:lt ein \%FOREIGN-\%Mo\%dul,
welches die Definition von
Prozeduren enth\(a:lt, welche Modula-Programmen den Zugriff auf die
Programmparameter erm\(o:glichen. Die Implementierung dieses FOREIGN-Moduls ist
bei \%MOCKA ein Teil des Laufzeitsystems. Die obige Behandlung der
Programmparameter in der Funktion \%\fImain\fP erm\(o:glicht es, dieses
\%FOREIGN-\%Mo\%dul in C zu implementieren.
.sp 0.4v
.ne 2v
.ti +2n
Die Funktion \%\fImain\fP wird mit \%\fIexit\^(0)\fP beendet,
um der Aufrufumgebung anzuzeigen, da\(ss die Ausf\(u:hrung des Programms
erfolgreich war.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Implementierung des \(U:bersetzers\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Implementierung des \(U:bersetzers
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Bild \n(h1.1 gibt einen kurzen \(U:berblick \(u:ber die einzelnen Phasen
des \(U:bersetzers \%\fIMtc\fP, die f\(u:r die Implementierung der Phasen verwendeten
\(U:bersetzerbauwerkzeuge (in Klammern hinter den Namen der Phasen)
sowie \(u:ber die wichtigsten intern auftretenden
Datenstrukturen, die der Kommunikation der einzelnen \(U:bersetzerphasen dienen.
.bA
\s-2
.PS
define data #
	box invis ht 0.3i wid 1.3i $2 $1
#
define text #
	$1 at $2.w - (1.8i, 0) ljust
#
lineht	= 0.2i
linewid	= 0.2i
moveht	= 0.2i
movewid	= 0.2i
boxwid	= 1.7i
boxht	= 0.7i
	down
	data("Aktuelle \(U:bersetzungseinheit", at (0,0))
	arrow
B1:	box "Lexikalische und" "syntaktische Analyse" "Baumaufbau"
	line
	data("Strukturbaum der aktuellen \(U:bersetzungseinheit")
	arrow
B2:	box "Behandlung der getrennten" "\(U:bersetzung"
	line
	data("Vollst\(a:ndiger Strukturbaum")
	arrow
B3:	box "Semantische Analyse" "Berechnung von Attributen" "f\(u:r die Codeerzeugung"
	line
	data("Attributierter Strukturbaum")
	arrow
B4:	box "Codeerzeugung"
	arrow
	data("C-Programm und/oder C-Definitionsdatei(en)")
	move to B2.e; move right
D:	data("Definitionsmoduln")
	arrow left from D.w 
	text("\fIParse (Rex, Ell, Ast)\fP", B1)
	text("\fIGetDefinitionModules\fP", B2)
	text("\fIEval (Ag)\fP", B3)
	text("\fIDoCode (Estra)\fP", B4)
.PE
\&\s+2
.sp 0.4v
.ce 9999
\&\fBBild \n(h1.1\fP: Phasen des \(U:bersetzers \%\fIMtc\fP
.ce 0
.bB 1v
.sp 0.4v
.ne 2v
.ti +2n
Die folgenden Kapitel enthalten eine genauere Besprechung der Aufgaben und
Implementierung der einzelnen Phasen des \(U:bersetzers, wobei besonderer Wert
auf die Darstellung des Einsatzes der Werkzeuge gelegt wird.
Grundlegende Begriffe und Techniken des \(U:bersetzerbaus
[Aho\|86, Waite\|84] werden dabei als weitgehend bekannt
vorausgesetzt.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Lexikalische Analyse\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Lexikalische Analyse
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Sym\%bol\%ent\%schl\(u:ss\%ler liest das Eingabeprogramm
zeichenweise und zerlegt es
in eine Folge von Grundsymbolen, die an den Zerteiler weitergereicht werden.
Seine Aufgaben sind im einzelnen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Erkennen der m\(o:glichen Grundsymbole der Sprache \%Modula-2:
Bezeichner, ganze Zahlen (oktal, dezimal oder hexadezimal), reelle Zahlen,
Zeichenkonstanten, Zeichenketten, Schl\(u:sselw\(o:rter, Operatoren und
Trennsymbole.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Berechnung der Attribute der Grundsymbole:
.sp 0.1vv
.if \n(.nu<4n .sp -0.1vv
.nr a2 0
.af a2 a
.sp 0.1vv
.if \n(.nu>4n .sp -0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Quelltextposition
.in -4n
.sp 0.1vv
.sp 0.1vv
.if \n(.nu>4n .sp -0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&semantische Information
.in -4n
.sp 0.1vv
.sp 0.1vv
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\(U:berlesen von Kommentaren, Zwischenr\(a:umen und Zeilenwechseln.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Melden von illegalen Zeichen und nicht geschlossenen Kommentaren und
Zeichenketten.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die Kodierung der erkannten Grundsymbole und deren Attribute werden an den
Zerteiler weitergereicht.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Attribute der Grundsymbole\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Attribute der Grundsymbole
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Quelltextposition der Grundsymbole wird f\(u:r sp\(a:tere Fehlermeldungen
ben\(o:tigt.
Sie setzt sich zusammen aus dem Namen der Eingabedatei sowie aus Zeile und
Spalte des Grundsymbols innerhalb der Eingabedatei. Warum auch der Name der
Eingabedatei mit in die Quelltextposition aufgenommen wurde, wird im
Zusammenhang mit der Behandlung der getrennten \(U:bersetzung n\(a:her erl\(a:utert.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r sp\(a:tere \(U:bersetzerphasen wird zus\(a:tzliche sematische Information
f\(u:r solche Grundsymbole ben\(o:tigt, die durch die zugeh\(o:rige Zeichenkette
nicht eindeutig festgelegt sind.
Die Tabelle \n(h1.2 beschreibt diese Grundsymbole und die Bedeutung der
.bA
.sp 0.4v
.TS
delim($$)tab(|) center box;
c| c
l| lw(6.5c).
Grundsymbol|Semantische Information
_
Bezeichner|T{
Eindeutige Abbildung der zugeh\(o:rigen Zeichenkette auf eine ganze Zahl
T}
Dezimalzahl|T{
Wert der Zahl
T}
Oktalzahl|T{
Wert der Zahl
T}
Hexadezimalzahl|T{
Wert der Zahl
T}
Zeichenkonstante|T{
Zugeh\(o:riges Zeichen
T}
Reelle Zahl|T{
Verweis in die Konstantentabelle
T}
Zeichenkette|T{
Verweis in die Konstantentabelle
T}
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.2\fP: Semantische Information der Grundsymbole
.ce 0
.sp 0.4v
.bB 1v
zugeh\(o:rigen semantischen Information.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Symbol- und Konstantentabelle\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Symbol- und Konstantentabelle
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Symboltabellenmodul \%\fIIdents\fP zur eindeutigen Abbildung von
Zeichenketten auf ganze Zahlen, der Konstantentabellenmodul
\%\fIStringMem\fP zur Speicherung von Zeichenketten variabler
L\(a:nge sowie der von beiden verwendete Modul \%\fIStrings\fP
zur Manipulation von Zeichenketten und zur Konvertierung von Zeichenketten in
interne Darstellungen, wie z.B. ganze Zahlen, wurden aus der Bibliothek
\%\fIReuse\fP [Grosch\|87a] entnommen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation des Symbolentschl\(u:sslers\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation des Symbolentschl\(u:sslers
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Sym\%bol\%ent\%schl\(u:ss\%ler wurde mit Hilfe des Generators \%\fIRex\fP
[Grosch\|87b]
aus einer
Beschreibung der Grundsymbole von \%Modula-2 erzeugt. Eine solche
Beschreibung besteht aus einer Reihe von regul\(a:ren Ausdr\(u:cken, welche die
Grundsymbole beschreiben und Aktionen, die ausgef\(u:hrt werden, wenn die
zugeh\(o:rigen regul\(a:ren Ausdr\(u:cke in der Eingabe erkannt werden. \%\fIRex\fP
\(u:bersetzt diese Beschreibung in einen tabellengesteuerten
Sym\%bol\%ent\%schl\(u:ss\%ler, der im
Modul \%\fIScanner\fP enthalten ist.
.sp 0.4v
.ne 2v
.ti +2n
Die Aktionen bestehen in den meisten F\(a:llen aus der Berechnung der Attribute
des zugeh\(o:rigen Grundsymbols und einer RETURN-An\%wei\%sung, mit der die
Kodierung des Grundsymbols an den Zerteiler zur\(u:ckgeliefert wird.
Zeile und Spalte der Grundsymbole im
Quelltext werden vom generierten Sym\%bol\%ent\%schl\(u:ss\%ler automatisch berechnet.
.sp 0.4v
.ne 2v
.ti +2n
Das folgende
Beispiel zeigt einige Ausschnitte aus der Spezifikation des
Sym\%bol\%ent\%schl\(u:ss\%lers:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
#STD#      "(*"         :- {NestingLevel := 1; yyStart (Comment);}
#Comment#  "(*"         :- {INC (NestingLevel);}
#Comment#  "*)"         :- {DEC (NestingLevel);
                            IF NestingLevel = 0 THEN yyStart (STD); END;}
#Comment#  "(" | "*" | - {*(\et\en} + :- {}
.sp 0.4v
#STD# ARRAY             : {Attribute.Pos.File   := SourceFileName;
                           Attribute.Pos.Line   := Line;
                           Attribute.Pos.Column := Column;
                           RETURN TokArray;}
.sp 0.4v
#STD# letter (letter | digit) * : {
                           GetWord (Word);
                           Attribute.Ident      := MakeIdent (Word);
                           Attribute.Pos.File   := SourceFileName;
                           Attribute.Pos.Line   := Line;
                           Attribute.Pos.Column := Column;
                           RETURN TokIdent;}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r komplexe Aufgaben und insbesondere f\(u:r die Behandlung von Linkskontext
stehen sogenannte Startzust\(a:nde zur Verf\(u:gung. In der Spezifikation kann
festgelegt werden, da\(ss bestimmte Muster nur in bestimmten Startzust\(a:nden
erkannt werden. Zu Beginn ist der Sym\%bol\%ent\%schl\(u:ss\%ler immer im Startzustand
\%STD. Startzust\(a:nde k\(o:nnen mit speziellen Anweisungen in den Aktionen
gewechselt werden. Diese M\(o:glichkeit wird im obigen Beispiel f\(u:r die
Bearbeitung von Kommentaren benutzt. Die Variable \%\fINestingLevel\fP ist
notwendig, da Kommentare in \%Modula-2 geschachtelt sein k\(o:nnen
und geschachtelte Kommentare nicht durch einen regul\(a:ren Ausdruck
beschrieben werden k\(o:nnen.
Die Funktion \%\fIMakeIdent\fP aus dem Modul \%\fIIdents\fP bildet die vom
Sym\%bol\%ent\%schl\(u:ss\%ler erkannte Zeichenfolge eines Bezeichners eindeutig
auf eine ganze Zahl ab.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Syntaktische Analyse und Baumaufbau\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Syntaktische Analyse und Baumaufbau
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Aufgabe des Zerteilers ist es, die syntaktische Struktur des Quellprogramms
zu analysieren, dessen syntaktische Korrektheit zu \(u:berpr\(u:fen und einen
abstrakten Strukturbaum aufzubauen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Zerteilerspezifikation\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Zerteilerspezifikation
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r die Erstellung eines Zerteilers standen die beiden Zerteilergeneratoren
\%\fIEll\fP und \%\fILalr\fP [Vielsack\|88]
zur Verf\(u:gung. Verglichen mit \%\fILalr\fP hat
\%\fIEll\fP die folgenden Vor- und Nachteile:
.sp 0.4v
Vorteile:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Die von \%\fIEll\fP unterst\(u:tzte
L-Attributierung\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Bei der
L-Attributierung sind sowohl vererbte als auch synthetisierte Attribute
m\(o:glich.
Dabei darf innerhalb einer Grammatikregel
\%\fIX\v'+0.3m'\s-4\&0\&\s+4\v'-0.3m'\|:\|X\v'+0.3m'\s-4\&1\&\s+4\v'-0.3m'\|...\|X\v'+0.3m'\s-4\&n\&\s+4\v'-0.3m'\|.\fP
ein Attribut des Symbols \%\fIX\v'+0.3m'\s-4\&i\&\s+4\v'-0.3m'\fP
(\|\%1\|\(<=i\|\(<=n\|)
nur von vererbten
Attributen des Symbols \%\fIX\v'+0.3m'\s-4\&0\&\s+4\v'-0.3m'\fP oder von Attributen der Symbole
\%\fIX\v'+0.3m'\s-4\&1\&\s+4\v'-0.3m'\fP bis \%\fIX\v'+0.3m'\s-4\&i-1\&\s+4\v'-0.3m'\fP abh\(a:ngen.
.nE
\&,
mit der parallel zur Zerteilung Attributwerte berechnet werden k\(o:nnen,
ist m\(a:chtiger als die von \%\fILalr\fP unterst\(u:tzte
S-Attributierung\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Bei der S-Attributierung sind nur synthetisierte Attribute zul\(a:ssig.
.nE
\&.
Au\(sserdem kann die Attributierung bei \%\fIEll\fP
im Gegensatz zu \%\fILalr\fP
\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ \%\fILalr\fP benutzt die Pseudovariablen
\*(dO\*(dO bzw. \*(dOn, um auf das Nichtterminal der linken Seite bzw. das n-te Symbol der rechten
Seite einer Produktion zuzugreifen.
.nE
\&
symbolisch durchgef\(u:hrt werden und ist damit weniger
fehleranf\(a:llig.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein von \%\fIEll\fP erzeugter Zerteiler ist etwa doppelt so schnell wie
ein von \%\fILalr\fP erzeugter.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
Nachteile:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der gravierendste Nachteil von \%\fIEll\fP ist, da\(ss die von \%\fIEll\fP
akzeptierte Sprachklasse \%ELL(1) weniger m\(a:chtig ist als die von
\%\fILalr\fP akzeptierte Sprachklasse \%LALR(1).
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Von \%\fILalr\fP erzeugte Zerteiler sind in der Regel kleiner als von
\%\fIEll\fP erzeugte.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da bereits eine ELL(1)-Grammatik f\(u:r \%Modula-2 vorlag, gaben die oben
genannten Vorteile von \%\fIEll\fP den Ausschlag f\(u:r die Entscheidung \%\fIEll\fP
zu verwenden.
.sp 0.4v
.ne 2v
.ti +2n
Die Eingabe f\(u:r \%\fIEll\fP besteht aus einer kontextfreien Grammatik in
erweiterter \%BNF, die die Struktur der Eingabesprache beschreibt. Jede
Produktion der Grammatik kann eine Reihe von semantischen Aktionen enthalten,
welche ausgef\(u:hrt werden,
sobald der Zerteiler die zugeh\(o:rigen Grammatikregeln analysiert.
.sp 0.4v
.ne 2v
.ti +2n
\%\fIEll\fP erzeugt aus der kontextfreien Grammatik
einen Zerteiler (enthalten im Modul \%\fIParser\fP), der nach dem Verfahren des
rekursiven Abstiegs arbeitet.
Die semantischen Aktionen werden an die
entsprechenden Stellen in den Quelltext des Zerteilers kopiert. Der erzeugte
Zerteiler besitzt eine automatische Fehlerbehandlung, die mit einem
r\(u:cksetzungsfreien Fehlerkorrekturalgorithmus arbeitet.
Ist die vom Sym\%bol\%ent\%schl\(u:ss\%ler gelieferte Folge von Grundsymbolen nicht
syntaktisch korrekt, setzt der Zerteiler nach Abgabe einer Fehlermeldung die
Zerteilung fort, indem er Symbole \(u:berliest und/oder einf\(u:gt, so da\(ss immer
ein syntaktisch korrekter Strukturbaum erzeugt wird.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation des Strukturbaums\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation des Strukturbaums
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Eine Spezifikation der abstrakten Syntax von \%Modula-2 wurde mit
der Spezifikationssprache des Generators \%\fIAst\fP [Grosch\|89a]
erstellt.
\%\fIAst\fP erzeugt aus der Spezifikation der abstrakten Syntax den Modul
\%\fITree\fP, der Typdeklarationen zur Implementierung des Strukturbaums und 
Prozeduren zum Aufbau von Baumknoten und zur Umkehr von Knotenlisten
enth\(a:lt.
.sp 0.4v
.ne 2v
.ti +2n
Die Struktur und die Eigenschaften der Knoten, aus denen ein abstrakter
Strukturbaum besteht, werden in einer \fIAst\fP\^-Spezifikation mit sogenannten
Knotentypen beschrieben. Jeder Knoten geh\(o:rt zu einem bestimmten Knotentyp.
Der Typ beschreibt die Kindknoten (Unterb\(a:ume) und die Attribute des Knotens.
Knotentypen k\(o:nnen als Erweiterung von anderen Knotentypen definiert werden;
letztere werden als Basistypen bezeichnet, erstere als abgeleitete Typen. Die
abgeleiteten Typen erben die Kindknoten und Attribute des Basistyps und k\(o:nnen
wiederum erweitert werden. \(U:berall dort, wo ein Knoten eines bestimmten
Basistyps erwartet wird, ist auch ein Knoten zul\(a:ssig, dessen Typ aus dem Basistyp
abgeleitet wurde.
.sp 0.4v
.ne 2v
.ti +2n
Folgender Ausschnitt der \fIAst\fP\^-Spezifikation
beschreibt die abstrakte Syntax eines Teils der Anweisungen von \%Modula-2:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 4
Stmts         = <
  Stmts0      = .
  Stmt        = Next: Stmts REVERSE <
    Assign    = Designator Expr .
    Call      = Designator Actuals .
    If        = Cond: Expr Then: Stmts Elsifs Else: Stmts .
.br
.ne 5
    Case      = Expr Cases Else: Stmts [Default: BOOLEAN] .
    While     = Cond: Expr Stmts .
    ...
  >.
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Knotentypen \%\fIAssign\fP, \%\fICall\fP, usf. sind Erweiterungen des
Knotentyps \%\fIStmt\fP,
welcher wiederum eine Erweiterung des Knotentyps \%\fIStmts\fP ist. Attribute sind
in eckigen Klammern eingeschlossen. Die Spezifikation von Kindknoten besteht
aus dem zugeh\(o:rigen Knotentyp und einem optionalen Selektornamen. Die
Knotentypen \%\fIAssign\fP, \%\fICall\fP, usf. erben den Kindknoten mit Namen \%\fINext\fP von
ihrem Basistyp \%\fIStmt\fP.
Die abstrakte Syntax enth\(a:lt im Gegensatz zur konkreten Syntax keine eigenen
Knotentypen f\(u:r Listen. Stattdessen enth\(a:lt jeder Knotentyp f\(u:r
Listenelemente einen Kindknoten \%\fINext\fP, der auf das n\(a:chste Element
der Liste verweist.
Die Angabe \%REVERSE wird von \%\fIAst\fP
zur Erzeugung der Prozedur f\(u:r die Umkehr von Knotenlisten
ben\(o:tigt.
.sp 0.4v
.ne 2v
.ti +2n
Beim Entwurf der abstrakten Syntax wurde darauf geachtet, da\(ss die
Strukturb\(a:ume m\(o:glichst einfach und kompakt aufgebaut sind.
Dadurch wird nicht nur der Speicherbedarf der
Strukturb\(a:ume reduziert, sondern auch deren Verarbeitung beschleunigt, da bei
der Traversierung weniger Knoten besucht werden m\(u:ssen.
Anhang A
enth\(a:lt die vollst\(a:ndige \fIAst\fP\^-Spezifikation der abstrakten Syntax von
\%Modula-2, wie sie f\(u:r den \(U:bersetzer verwendet wurde.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Baumaufbau\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Baumaufbau
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Zum Aufbau des Strukturbaums w\(a:hrend der Zerteilung wird der von \%\fIEll\fP
angebotene Mechanismus zur L-Attributierung, die von \%\fIAst\fP
generierten
Prozeduren f\(u:r den Baumaufbau und die Prozedur \%\fIReverseTree\fP
zur Umkehr von Knotenlisten benutzt.
.sp 0.4v
.ne 2v
.ti +2n
Das folgende Beispiel zeigt
einen Ausschnitt der kontextfreien Grammatik f\(u:r Fallmarken mit semantischen
Aktionen f\(u:r den Baumaufbau:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 7
Labels          /* Tree: synthesized                    */
.sp 0.4v
                :
  { Label1.Tree := mLabels0 (); }
                  Label || ','
  { Labels0.Tree := ReverseTree (Label1.Tree); }
                .
.sp 0.4v
.br
.ne 9
Label           /* Tree: inherited and synthesized      */
.sp 0.4v
                : Expr
                    ( '..' Expr
    { Label0.Tree := mLabelRange (Label0.Tree, Expr1.Tree, Expr2.Tree); }
                    |
    { Label0.Tree := mLabel (Label0.Tree, Expr1.Tree); }
                    )
                .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Baumknoten werden aufgebaut durch Aufrufe der von \%\fIAst\fP f\(u:r diesen
Zweck generierten Prozeduren. \%\fIAst\fP generiert
f\(u:r jeden Knotentyp eine solche Prozedur. Die Kindknoten und Attribute des
Knotens werden als Parameter \(u:bergeben und ein Zeiger auf den neu
angelegten Knoten wird zur\(u:ckgeliefert.
Die Nichtterminale der kontextfreien Grammatik besitzen ein Attribut
\%\fITree\fP, welches den Teilbaum beschreibt, dessen Wurzel das
Nichtterminal ist.
Die kontextfreie Grammatik enth\(a:lt noch verschiedene Nichtterminale
f\(u:r Listen und Listenelemente. Im Baum existieren aber
nur noch Knotentypen f\(u:r die Listenelemente mit einem
Verweis auf das jeweils n\(a:chste Element. Daher wird bei der Zerteilung
einer Liste der bisher aufgebaute Strukturbaum f\(u:r die Liste, der aus
verketteten Listenelementen besteht, als vererbtes Attribut an das
Nichtterminal f\(u:r die Listenelemente \(u:bergeben und dort beim Aufbau
eines neuen Listenelements als Verweis auf das n\(a:chste Listenelement verwendet.
Dabei wird die Liste zun\(a:chst in der verkehrten
Reihenfolge aufgebaut. Dies wird aber in der Grammtikregel f\(u:r die Liste
nach der Zerteilung der Liste durch einen Aufruf der von \%\fIAst\fP
generierten Prozedur \%\fIReverseTree\fP korrigiert.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Behandlung der getrennten \(U:bersetzung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Behandlung der getrennten \(U:bersetzung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die getrennte \(U:bersetzung erm\(o:glicht es, Programme in kleinere Teile zu
zerlegen, die vom \(U:bersetzer einzeln \(u:bersetzt werden k\(o:nnen. Die
wichtigsten Ziele einer solchen Zerlegung sind:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Aufteilung eines Programmsystems in \(u:berschaubare und m\(o:glichst
abgeschlossene Einheiten (Moduln), die eine definierte Schnittstelle nach
au\(ssen besitzen und deren interne Implementierung nach au\(ssen verborgen
bleibt.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Arbeitsteilige Erstellung von Programmsystemen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Reduktion des \(U:bersetzungsaufwands.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Entwicklung von Programmbibliotheken mit wiederverwendbarer Software.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Bei einer getrennten \(U:bersetzung sollte der \(U:bersetzer
zur Erzielung h\(o:herer Zuverl\(a:ssigkeit nach M\(o:glichkeit
Korrektheitspr\(u:fungen \(u:ber die
Grenzen von \(U:bersetzungseinheiten hinweg vornehmen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Eine h\(a:ufige
Fehlerquelle bei der Entwicklung von C-Programmen ist, da\(ss in C solche
Pr\(u:fungen vom \(U:bersetzer nicht automatisch vorgenommen werden.
.nE
\&.
.
.sp 0.4v
.ne 2v
.ti +2n
\%Modula-2 unterst\(u:tzt die oben genannten Forderungen durch sein
Modulkonzept, insbesondere durch die Trennung von globalen Moduln in
Schnittstelle (Definitionsmodul) und Implementierung (Implementierungsmodul).
Soll in \%Modula-2 eine \(U:bersetzungseinheit \(u:bersetzt werden, dann
m\(u:ssen dem \(U:bersetzer die Schnittstellen aller von der \(U:bersetzungseinheit
importierten Moduln bekannt sein. Auch bei der \(U:bersetzung von \%Modula-2
nach C m\(u:ssen die Schnittstellen der importierten Moduln bekannt sein, da f\(u:r
eine korrekte \(U:bersetzung semantische Informationen
\(u:ber die importierten Objekte notwendig sind.
.sp 0.4v
.ne 2v
.ti +2n
Eine L\(o:sung f\(u:r dieses Problem, die auch von \%MOCKA
implementiert wird, ist, bei der \(U:bersetzung eines
Definitionsmoduls eine sogenannte Symboldatei anzulegen, die einen Ausschnitt
der Definitionstabelle des \(U:bersetzers darstellt und eine Beschreibung aller
vom zugeh\(o:rigen Modul exportierten Objekte enth\(a:lt.
Diese Symboldatei wird dann bei der \(U:bersetzung von abh\(a:ngigen Moduln
benutzt, indem die dort enthaltene Information wieder
in die Definitionstabelle eingetragen wird.
.sp 0.4v
.ne 2v
.ti +2n
Eine alternative L\(o:sung ist, bei jedem \(U:bersetzungsvorgang den Quelltext
aller Schnittstellen von (transitiv) importierten Moduln von neuem einzulesen und
zu analysieren.
.sp 0.4v
.ne 2v
.ti +2n
Vergleicht man die beiden L\(o:sungen ergibt sich folgendes:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein \(U:bersetzer, welcher die L\(o:sung mit den Symboldateien verwendet, ist
schneller  und der gesamte \(U:bersetzungsaufwand reduziert sich, da eine
Schnittstelle nur einmal \(u:bersetzt und
nur einmal eine (bin\(a:re) Symboldatei angelegt werden mu\(ss; bei der
\(U:bersetzung aller abh\(a:ngigen \(U:bersetzungseinheiten mu\(ss dann nur jeweils die
einmal angelegte Symboldatei neu eingelesen werden, was sicher weniger Aufwand
verursacht als den Quelltext der Schnittstelle
jedesmal von neuem einzulesen und zu analysieren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Programmieraufwand f\(u:r die L\(o:sung mit den
Symboldateien ist deutlich h\(o:her, da Dateiformate f\(u:r die Symboldateien
definiert und Operationen programmiert werden m\(u:ssen, die
a) die Information aus der Definitionstabelle lesen und auf die
Symboldatei schreiben und b)
die Symboldatei lesen und die Information in die Definitionstabelle
eintragen. Dieser zus\(a:tzliche Programmieraufwand entf\(a:llt
f\(u:r die zweite L\(o:sung, da Einlesen und Analyse
der Schnittstellen sowieso ein Teil des \(U:bersetzers sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Zur Unterst\(u:tzung des Benutzers sollte ein \(U:bersetzer, der die erste
L\(o:sung realisiert, \(u:berpr\(u:fen, ob alle f\(u:r die \(U:bersetzung einer bestimmten
\(U:bersetzungseinheit ben\(o:tigten Symboldateien vorhanden und auf dem neuesten
Stand, d.h. konsistent mit dem Quelltext des zugeh\(o:rigen Definitionsmoduls,
sind und bei Bedarf zuerst die
(Neu-)\(U:bersetzung der zugeh\(o:rigen Definitionsmoduln in eine Symboldatei
ansto\(ssen\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Ist eine derartige
automatische Unterst\(u:tzungsfunktion nicht implementiert,
mu\(ss der Benutzer selbst die
Mo\%dul\%ab\%h\(a:n\%gig\%kei\%ten analysieren, mu\(ss sich selbst um die
\(U:bersetzungsreihenfolge
und die Konsistenz der erzeugten Symboldateien bzw. Objektprogramme
k\(u:mmern. Eine u.U. recht aufwendige und fehleranf\(a:llige Arbeit, die
unbedingt vom \(U:bersetzer \(u:bernommen werden sollte.
.nE
\&.
Dies entf\(a:llt bei der zweiten L\(o:sung automatisch, da sowieso alle
ben\(o:tigten Definitionsmoduln eingelesen werden\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Allerdings
wird dadurch nicht verhindert, da\(ss die erzeugten
Objekt- bzw C-Programme m\(o:glicherweise gegenseitig inkonsistent sind!
.nE
\&.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Da \%\fIMtc\fP nicht f\(u:r die Programmentwicklung gedacht ist und folglich ein
fertig entwickeltes Modula-Programm auch nur einmal nach C \(u:bersetzt werden
mu\(ss, ist es nicht kritisch, wenn der \(U:bersetzer aufgrund eines wiederholten
Einlesens und einer wiederholten Analyse von Schnittstellen
etwas langsamer ist. Daher gab der deutlich geringere Aufwand f\(u:r die
Implementierung der zweiten L\(o:sung den Ausschlag, diese im \(U:bersetzer
\%\fIMtc\fP zu realisieren.
.sp 0.4v
.ne 2v
.ti +2n
Zur Realisierung der oben skizzierten L\(o:sung im \(U:bersetzer \%\fIMtc\fP
wurde zun\(a:chst die Definition
des Strukturbaums erweitert. Ein Strukturbaum besteht nicht nur aus einer
\(U:bersetzungseinheit, sondern aus einer Liste von \(U:bersetzungseinheiten:
.zA
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
ROOT            = CompUnits .
.sp 0.4v
CompUnits       = <
  CompUnits0    = .
  CompUnit      = [Kind: SHORTCARD] [Ident: tIdent] [Pos: tPosition]
                  Next: CompUnits REVERSE <
    DefMod      = Import Decls .
    ProgMod     = Import Decls Stmts .
  >.
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.zE
.sp 0.4v
.ne 2v
.ti +2n
Da die \(U:bersetzungseinheiten aus verschiedenen Quelldateien stammen, wird
jetzt auch klar, warum, wie im Kapitel \(u:ber die lexikalische Analyse bereits
erw\(a:hnt, die Quelltextposition auch den Namen der Quelldatei enthalten mu\(ss.
.sp 0.4v
.ne 2v
.ti +2n
Der Aufbau dieser Liste von \(U:bersetzungseinheiten, d.h. der Aufbau des
Strukturbaums in seiner endg\(u:ltigen Form und somit die Behandlung der
getrennten \(U:bersetzung, \(u:bernimmt der Modul \%\fIDefMods\fP.
Der vom Zerteiler aufgebaute Strukturbaum f\(u:r die aktuelle
\(U:bersetzungseinheit bildet die Eingabe f\(u:r diesen Modul.
Innerhalb von \%\fIDefMods\fP werden die Importlisten aller bereits
eingelesenen \(U:bersetzungseinheiten traversiert und f\(u:r alle
importierten und bisher
noch nicht eingelesenen (De\%fi\%ni\%ti\%ons-)Mo\%duln der Zerteiler aufgerufen,
welcher das Einlesen der Definitionsmoduln steuert und Strukturb\(a:ume
f\(u:r sie aufbaut\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Entsprechend der von \%MOCKA implementierten
Konvention wird ein Definitionsmodul \fIM\fP in einer Datei mit Namen \%\fIM.md\fP
erwartet. Beim Aufruf von \%\fIMtc\fP k\(o:nnen auch Bibliotheken
angegeben werden, die dann nach den ben\(o:tigten
Definitionsmoduln durchsucht werden.
.nE
\&. Ist die aktuelle \(U:bersetzungseinheit ein
Implementierungsmodul, mu\(ss auch der zugeh\(o:rige Definitionsmodul eingelesen
werden.
Aus dem Teilbaum der aktuellen \(U:bersetzungseinheit und aus
den vom Zerteiler gelieferten Teilb\(a:umen der ben\(o:tigten Definitionsmoduln
wird schlie\(sslich der vollst\(a:ndige Strukturbaum aufgebaut
und an die semantische Analyse weitergereicht.
.sp 0.4v
.ne 2v
.ti +2n
Vergleicht man den Umfang der f\(u:r die Behandlung der getrennten \(U:bersetzung
notwendigen Programmteile von \%\fIMtc\fP und \%MOCKA, best\(a:tigen sich die
oben gemachten Aussagen des Vergleichs hinsichtlich des Programmieraufwands der
beiden L\(o:sungen eindrucksvoll. Allein der Modul \%\fIDfFiles\fP von \%MOCKA,
der die Symboldateien liest und beschreibt sowie deren Daten aus der
Definitionstabelle liest und dort wieder eintr\(a:gt, umfa\(sst ca. 1450 Zeilen
Modula-Code. Dazu kommt dann noch zus\(a:tzlich die von \%MOCKA implementierte
Steuerung der Nach\(u:bersetzung bzw. der \(U:bersetzungsreihenfolge. Im Gegensatz
dazu umfa\(sst der Modul \%\fIDefMods\fP von \%\fIMtc\fP, der die gesamte getrennte
\(U:bersetzung behandelt, nur ca. 250 Zeilen Modula-Code.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Semantische Analyse\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Semantische Analyse
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Normalerweise ist es die Aufgabe der semantischen Analyse,
die Bedeutung bzw. die Eigenschaften des Quellprogramms, welche zur statischen
Semantik\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ Zur statischen Semantik einer Sprache geh\(o:ren alle Eigenschaften
eines Programms, die ohne eine Ausf\(u:hrung des Programms abgeleitet werden
k\(o:nnen. Die dynamische Semantik eines Programms dagegen umfa\(sst alle
Eigenschaften, die nur durch seine Ausf\(u:hrung bestimmt werden k\(o:nnen.
.nE
\&
der Sprache geh\(o:ren, zu bestimmen und zu \(u:berpr\(u:fen, ob diese Eigenschaften
den Regeln der
statischen Semantik der Sprache, wie sie von der Sprachdefinition festgelegt
werden, gen\(u:gen. Wie in der Einleitung bereits n\(a:her erl\(a:utert und
begr\(u:ndet, soll \%\fIMtc\fP die semantische Korrektheit der Eingabeprogramme
nicht \(u:berpr\(u:fen. Daher kann die semantische Analyse im \(U:bersetzer
\%\fIMtc\fP darauf beschr\(a:nkt werden, die Eigenschaften des Modula-Programms zu
bestimmen, soweit sie f\(u:r eine korrekte \(U:bersetzung nach C bekannt sein
m\(u:ssen. Aus diesem Grund sind die zentralen Aufgaben der semantischen Analyse
im \(U:bersetzer \%\fIMtc\fP der Aufbau einer Definitionstabelle, die
Bezeichneridentifikation und die Typbestimmung in Ausdr\(u:cken.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation der semantischen Analyse mit einer Attributgrammatik und
abstrakten Datentypen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation der semantischen Analyse mit einer Attributgrammatik und
abstrakten Datentypen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die semantische Analyse wurde mit einer Attributgrammatik spezifiziert. Der
Generator \%\fIAg\fP [Grosch\|89b] erzeugt aus dieser Attributgrammatik
einen Attributauswerter (enthalten im Modul \%\fISemantics\fP),
der mit rekursiven Besuchsprozeduren, welche den Strukturbaum
traversieren und die Attribute berechnen, implementiert ist.
.sp 0.4v
.ne 2v
.ti +2n
\%\fIAg\fP arbeitet eng mit \%\fIAst\fP zusammen. Die in Kapitel \n(h1.2.2
beschriebene Spezifikation der abstrakten Syntax ist nur der erste Teil einer
Attributgrammatik, deren zweiter Teil aus der Deklaration von Attributen und
aus Attributierungsregeln besteht, die die Werte dieser Attribute festlegen.
.sp 0.4v
.ne 2v
.ti +2n
Attribute und Attributierungsregeln werden den Knotentypen der abstrakten
Syntax zugeordnet. Als Typen f\(u:r die Attribute sind alle Typen der Zielsprache
\%Modula-2, in welcher der Attributauswerter implementiert ist,
zul\(a:ssig. Die Berechnung der Attribute wird ebenfalls mit Anweisungen
der Zielsprache \%Modula-2, wie z.B. Zuweisung oder bedingter Anweisung,
ausgedr\(u:ckt, aus denen \%\fIAg\fP
die At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten
und eine geeignete Auswertungsreihenfolge ableitet.
Da die Anweisungen auch Aufrufe von externen Funktionen enthalten k\(o:nnen,
wird eine Verwendung von in der Zielsprache \%Modula-2 implementierten
abstrakten Datentypen in der Attributgrammatik
m\(o:glich, die in getrennt \(u:bersetzbaren Moduln definiert sind.
Die Attributberechnungen k\(o:nnen auch Seiteneffekte enthalten. Es
ist au\(sserdem m\(o:glich
k\(u:nstliche At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten
zu definieren, um eine bestimmte
Auswertungsreihenfolge zu erzwingen, oder um bei einer Attributgrammatik die
von \%\fIAg\fP geforderte
Eigenschaft \%OAG [Kastens\|80] herbeizuf\(u:hren, falls sie
diese noch nicht besitzt.
.sp 0.4v
.ne 2v
.ti +2n
Der in Kapitel \n(h1.2.2 beschriebene
Erweiterungsmechanismus f\(u:r die Attribute und Kindknoten von Knotentypen gilt
auch f\(u:r die Attributberechnungen. Abgeleitete Knotentypen erben die
Attributberechnungen ihrer Basistypen. Durch Angabe einer speziellen
Attributberechnung f\(u:r den abgeleiteten Knotentyp kann die vererbte
Attributberechnung aber \(u:berschrieben werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Abstrakte Datentypen\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Abstrakte Datentypen
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Dieses Kapitel enth\(a:lt eine kurze Beschreibung der wichtigsten abstrakten
Datentypen, die in der Attributgrammatik verwendet wurden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Spezifikation der Definitionstabelle und Bezeichneridentifikation\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Spezifikation der Definitionstabelle und Bezeichneridentifikation
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%\fIAst\fP wurde im \(U:bersetzer \%\fIMtc\fP nicht nur f\(u:r
die Implementierung des Strukturbaums verwendet, sondern
auch f\(u:r die Implementierung des Definitionstabellenmoduls \%\fIDefs\fP.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r jedes im Modula-Programm deklarierte Objekt sowie f\(u:r alle
vordefinierten Objekte wird eine Objektbeschreibung angelegt, die
alle vorhandenen Informationen \(u:ber das Objekt enth\(a:lt.
Der
Knotentyp \%\fIObject\fP\c
.nA
\v'-0.4m'\s-4\&\n(nZ\&\s+4\v'+0.4m'\c
.nB
\&\n(nZ\ In der abgebildeten Definition der
Objektbeschreibungen fehlen die Attribute f\(u:r die Codeerzeugung (s. Kap.
\n(h1.5)
.nE
\& definiert die Struktur der Objektbeschreibungen:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
Object          = [Ident: tIdent] <
  Const1        = -> [Value: tValue] .
  EnumLiteral1  = Type [Index: SHORTCARD] .
  Field1        = Type .
  Module1       = ExportList: Objects -> Objects Locals: Objects .
  Proc1         = Type -> [IsExported: BOOLEAN] Locals: Objects .
  ProcHead1     = Type .
  TypeDecl1     = -> Type .
.br
.ne 3
  Var1          = Type [IsVAR: BOOLEAN] .
  ...
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Kindknoten bzw. Attribute, die rechts des Symbols \f(TT->\fP stehen,
werden als
,,non-input'' Attribute bezeichnet. Die Werte dieser Attribute werden beim
Aufbau der Objektbeschreibungen noch nicht festgelegt; es wird jedoch Speicherplatz f\(u:r sie
reserviert, so da\(ss ihr Wert zu einem sp\(a:teren Zeitpunkt nachgetragen werden
kann.
Das Attribut \%\fIExportList\fP ist ein Ausschnitt der
vollst\(a:ndigen Exportliste \%\fIObjects\fP eines Moduls und enth\(a:lt nur die von
diesem Modul exportierten Typnamen. Die Behandlung einiger Attribute als ,,non-input''
Attribute und die ,,doppelte'' Exportliste sind notwendig, da beim Aufbau
der Objekt- und Typbeschreibungen
zyklische Abh\(a:ngigkeiten auftreten, die durch einen
schrittweisen Aufbau dieser Beschreibungen behandelt werden.
.sp 0.4v
.ne 2v
.ti +2n
Betrachtet man den folgenden Ausschnitt eines Modula-Programms, dann sieht man
sofort, da\(ss die Typb\(a:ume der abstrakten Syntax in Modula-2
f\(u:r eine Beschreibung der Typen innerhalb der Definitionstabelle
nur wenig geeignet sind:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
TYPE t1 = INTEGER; t2 = t1;
VAR  v1 : t1; v2 : t2;
.br
.ne 3
  ...
v1 := v2;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die Typen der Variablen \%\fIv1\fP und \%\fIv2\fP sind identisch; aus den
Typb\(a:umen f\(u:r \%\fIt1\fP und \%\fIt2\fP ist dies aber nicht direkt ablesbar.
Daher werden f\(u:r die Typen Typbeschreibungen aufgebaut,
deren Struktur \(em abgesehen von einigen
Vereinfachungen \(em mit der Struktur der Typb\(a:ume
\(u:bereinstimmt, in denen aber
die Typnamen durch die Typbeschreibung dieser Typen ersetzt sind.
Neben Knotentypen f\(u:r die Typkonstruktoren von \%Modula-2
existieren
auch Knotentypen f\(u:r die Repr\(a:sentation von Grund- und Standardtypen sowie f\(u:r eine Reihe
von speziellen Typen, die
nur intern im \(U:bersetzer verwendet werden und die keine direkte Entsprechung
in der Sprachdefinition von \%Modula-2 haben.
.sp 0.4v
.ne 2v
.ti +2n
Die Aufgabe der Bezeichneridentifikation ist es,
jedem angewandten Auftreten eines
Bezeichners das zugeh\(o:rige Objekt bzw. die zugeh\(o:rige Objektbeschreibung
zuzuordnen.
Die Sprachdefinition von \%Modula-2 legt durch ihre
G\(u:ltigkeitsbereichsregeln fest, wie die
Zuordnung zu treffen ist. \%Modula-2 ist eine blockstrukturierte Sprache
in der die G\(u:ltigkeitsbereiche der Bezeichner geschachtelt sind. Eine
Definition eines Bezeichners in einem inneren Block verdeckt die Definition
dieses Bezeichners in einem \(a:u\(sseren Block.
In \%Modula-2 kommt zur
Blockstruktur noch das Modulkonzept hinzu, welches eine explizite Kontrolle der
G\(u:ltigkeitsbereiche von Bezeichnern
mit Hilfe von Import- und Exportanweisungen erm\(o:glicht.
Innerhalb
der Attributgrammatik werden den Knotentypen der abstrakten
Syntax bei Bedarf
sogenannte Umgebungsattribute zugeordnet, welche die an der jeweiligen Stelle
g\(u:ltigen Definitionen repr\(a:sentieren.
Die Struktur der Umgebungsattribute wird in der \fIAst\fP\^-Spezifikation durch den
Knotentyp \%\fIEnv\fP beschrieben:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
Env = Objects HiddenEnv: Env .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
\%\fIObjects\fP sind die im aktuellen Block definierten Objekte,
\%\fIHiddenEnv\fP enth\(a:lt die in \(a:u\(sseren Bl\(o:cken definierten Objekte.
.sp 0.4v
.ne 2v
.ti +2n
Die Identifikation in der Attributgrammatik erfolgt durch den Aufruf der
ebenfalls im Modul \%\fIDefs\fP definierten Funktion
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
Identify : Ident \(mu Env \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Object .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
die jedem Bezeichner mit Hilfe des g\(u:ltigen Umgebungsattributs das
zugeh\(o:rige Objekt zuordnet.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Auswertung konstanter Ausdr\(u:cke und Repr\(a:sentation ihrer Werte\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Auswertung konstanter Ausdr\(u:cke und Repr\(a:sentation ihrer Werte
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Wie in Kapitel 4 erl\(a:utert, m\(u:ssen f\(u:r die \(U:bersetzung nach C die
Werte einer Reihe von konstanten Ausdr\(u:cken bekannt sein. Zu diesem Zweck
existiert der Modul \%\fIValues\fP, welcher Typdeklarationen zur Repr\(a:sentation
der Werte von konstanten Ausdr\(u:cken und eine Operation f\(u:r ihre Auswertung
enth\(a:lt. Den Objektbeschreibungen der Konstanten in der Definitionstabelle und
einigen Baumknoten wie z.B. den Fallmarken wird ein Attribut
zugeordnet, welches den Wert des zugeh\(o:rigen konstanten Ausdrucks
repr\(a:sentiert. Die Funktion
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
CompConst : Tree \(mu Env \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Value .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
die in der Attributgrammatik aufgerufen wird, berechnet aus dem Baum f\(u:r den
konstanten Ausdruck und der aktuell g\(u:ltigen Umgebung, die f\(u:r den Zugriff
auf die Werte von benannten Konstanten ben\(o:tigt wird, den Wert des konstanten
Ausdrucks.
.sp 0.4v
.ne 2v
.ti +2n
Um den Aufwand f\(u:r die Implementierung des Moduls \%\fIValues\fP zu reduzieren,
arbeitet \%\fIValues\fP nicht interpretativ, sondern mit einer direkten
Ausf\(u:hrung der Operationen. Die meisten m\(o:glichen Fehler, wie etwa Division
durch Null, werden aber durch entsprechende Abfragen abgefangen.
Arithmetische \(U:berl\(a:ufe werden allerdings nicht erkannt. Eine Auswertung von
Ausdr\(u:cken, die ganzzahlige Konstanten im Bereich
\%MAX\^(INTEGER)\|+\|1 .. \%MAX\^(CARDINAL)
enthalten, ist nicht m\(o:glich. \%\fICompConst\fP liefert in diesem Fall aber
einen definierten Wert zur\(u:ck, der dies anzeigt.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Operationen auf Typen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Operationen auf Typen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Definition der Typbeschreibungen und die Prozeduren f\(u:r
ihren Aufbau sowie Prozeduren f\(u:r den Zugriff auf in den Typbeschreibungen
enthaltene Informationen sind Teil des Moduls \%\fIDefs\fP.
.sp 0.4v
.ne 2v
.ti +2n
Der Modul \%\fITypes\fP enth\(a:lt alle
weiteren Informationen \(u:ber die Typen von \%Modula-2.
Dabei handelt es sich insbesondere um Operationen f\(u:r die Typbestimmung in
Ausdr\(u:cken.
.sp 0.4v
.ne 2v
.ti +2n
Au\(sserdem enth\(a:lt
\%\fITypes\fP auch die meisten Details \(u:ber die Abbildung der Typen von
\%Modula-2 nach C, wie sie f\(u:r die Codeerzeugung, insbesondere im
Zusammenhang mit der Erzeugung von expliziten Typumwandlungen, ben\(o:tigt
werden.
Die in Kapitel 4.4.1 erw\(a:hnte Tabelle, die f\(u:r eine Auswertung der
Standardfunktionen \%SIZE, \%TSIZE, \%MIN und \%MAX ben\(o:tigt
wird, ist ebenfalls Teil des Moduls \%\fITypes\fP.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Die Attributgrammatik\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Die Attributgrammatik
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die folgende Beschreibung der Attributgrammatik ist nur eine auszugsweise
Darstellung einiger interessanter Aspekte dieser Attributgrammatik.
Eine ausf\(u:hrliche Darstellung der Spezifikation der semantischen
Analyse mit Attributgrammatiken und die L\(o:sung von typischen Problemen in
diesem Zusammenhang kann in [Waite\|84] gefunden werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Aufbau der Definitionstabelle und Berechnung von Umgebungsattributen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Aufbau der Definitionstabelle und Berechnung von Umgebungsattributen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
In \%Modula-2 existieren eine Reihe von Regeln, die den Aufbau von Objekt-
und Typbeschreibungen und die Berechnung von Umgebungsattributen erschweren und
die dazu f\(u:hren, da\(ss die Objekt- und Typbeschreibungen nicht in einem
einzigen Schritt aufgebaut werden k\(o:nnen, da dies zu zyklischen
Abh\(a:ngigkeiten in der Attributgrammatik f\(u:hren w\(u:rde.
.sp 0.4v
.ne 2v
.ti +2n
Neben den ,,rekursiven'' Typdeklarationen (s. Kap. 4.3) ist hier
insbesondere die Tatsache zu nennen, da\(ss in den Deklarationen eines Blocks
Typnamen verwendet werden k\(o:nnen, die im gleichen Block
textuell sp\(a:ter deklariert sind. Der
Aufbau von Objektbeschreibungen f\(u:r die in einem Block deklarierten Objekte
erfordert daher ein Umgebungsattribut zur Identifikation
dieser Typnamen. F\(u:r die Berechnung dieses Umgebungsattributs
werden aber umgekehrt die Objektbeschreibungen der
in diesem Block deklarierten Objekte ben\(o:tigt.
.sp 0.4v
.ne 2v
.ti +2n
Die L\(o:sung dieses Problems besteht darin, die Objekt- bzw. Typbeschreibungen
schrittweise aufzubauen und f\(u:r die Deklarationen eine Reihe von
aufeinanderfolgenden Umgebungsattributen zu berechnen, die jeweils
etwas mehr Informationen \(u:ber die deklarierten Objekte enthalten.
.sp 0.4v
.ne 2v
.ti +2n
Da die meisten der oben genannten Probleme durch die Typdeklarationen entstehen,
werden
zuerst vorl\(a:ufige Objektbeschreibungen f\(u:r die benannten Typen und
vollst\(a:ndige Typbeschreibungen f\(u:r alle Typknoten der abstrakten Syntax
aufgebaut, die in den Objektbeschreibungen verwendet werden k\(o:nnen.
.sp 0.4v
.ne 2v
.ti +2n
Zun\(a:chst wird f\(u:r die Deklarationen aller Bl\(o:cke ein Attribut
\%\fIObjects1\fP berechnet,
welches eine Liste von Objektbeschreibungen f\(u:r Typen darstellt,
die
im Prinzip als einzige Information die im entsprechenden Block
deklarierten Typnamen
enth\(a:lt. In diese Objektliste werden f\(u:r die Behandlung des Modulkonzepts
noch zus\(a:tzlich Objektbeschreibungen der
Moduln mit einer vorl\(a:ufigen Exportliste aufgenommen, die alle vom Modul
exportierten Typnamen umfa\(sst.
Die Behandlung des Modulkonzepts
wird in einem der folgenden Abschnitte noch n\(a:her erl\(a:utert.
Diese Objektlisten werden zu einem ersten
Umgebungsattribut \%\fIEnv1\fP kombiniert, welches in Typdeklarationen die
Zuordnung von Objektbeschreibungen zu den Typnamen erm\(o:glicht.
Mit der Berechnung der beiden Attribute \%\fIObjects2\fP und \%\fIEnv2\fP
wird der Prozess des Aufbaus von Typbeschreibungen vervollst\(a:ndigt. Wie das im
Detail funktioniert, wird im n\(a:chsten Kapitel beschrieben.
.sp 0.4v
.ne 2v
.ti +2n
Jetzt erst kann
eine Objektliste \%\fIObjects3\fP aufgebaut werden, die die
vollst\(a:ndigen Objektbeschreibungen der Typen, Variablen, Prozeduren und Moduln
mit der kompletten Exportliste enth\(a:lt.
F\(u:r die Konstanten fehlt in \%\fIObjects3\fP noch der
Wert der Konstanten, da hier ein \(a:hnliches Problem wie f\(u:r die
Typen auftritt. Zur Auswertung der Konstanten \%\fIa\fP in der folgenden
Deklaration
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
CONST b = 1;
CONST a = b * 2;
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wird der Wert der Konstanten \%\fIb\fP ben\(o:tigt. Hier sind in \%Modula-2
die Probleme im Gegensatz zu den Typen nicht so gro\(ss, da f\(u:r die in
Konstantendeklarationen verwendeten Konstantennamen immer gelten
mu\(ss, da\(ss diese Namen textuell vor dieser Deklaration
definiert sein m\(u:ssen. Zyklische Abh\(a:ngigkeiten der Konstantendeklarationen
k\(o:nnen daher in \%Modula-2 nicht auftreten.
.sp 0.4v
.ne 2v
.ti +2n
Mit der Objekliste \%\fIObjects3\fP wird die Umgebung
\%\fIEnv3\fP aufgebaut, die bis auf die Werte der Konstanten vollst\(a:ndig
ist.
.sp 0.4v
.ne 2v
.ti +2n
Mit Hilfe der beiden
Attribute \%\fIObjects4In\fP und \%\fIObjects4Out\fP
wird schlie\(sslich f\(u:r die Deklarationen
aller Bl\(o:cke eine weitere Objektliste aufgebaut, wobei die
zu den Konstantendeklarationen dazugeh\(o:rigen
konstanten Ausdr\(u:cke in der textuellen Reihenfolge der Deklarationen
mit Hilfe der Umgebung \%\fIEnv3\fP und der Funktion \%\fICompConst\fP
ausgewertet werden. Die Werte der Konstanten
werden dabei in deren Objektbeschreibungen \(u:bernommen.
.sp 0.4v
.ne 2v
.ti +2n
Mit der Objektliste \%\fIObjects4Out\fP kann jetzt die vollst\(a:ndige Umgebung
\%\fIEnv4\fP berechnet werden, die in den Anweisungen f\(u:r die
Bezeichneridentifikation verwendet wird.
.sp 0.4v
.ne 2v
.ti +2n
Vorstehend war die Rede von schrittweisem Aufbau der Objekt- und
Typbeschreibungen.
In der Attributgrammatik werden selbstverst\(a:ndlich
jeweils neue Attribute berechnet, die den bei diesem schrittweisen Aufbau
entstehenden Teilergebnissen entsprechen.
Durch die M\(o:glichkeit von kontrollierten Seiteneffekten und dem Einsatz von
Zeigertypen (abstrakte Datentypen) f\(u:r die Attributwerte, k\(o:nnen aber
vorhandene Beschreibungen erweitert werden.
Damit entf\(a:llt die Notwendigkeit mehrere
Objekt- bzw. Typbeschreibungen f\(u:r das gleiche Objekt bzw. den gleichen Typ
aufbauen und eventuell noch eine gemeinsame
Repr\(a:sentation f\(u:r diese finden zu m\(u:ssen. Au\(sserdem wird
die Implementierung hinsichtlich Laufzeit
und Speicherbedarf effizienter. Der Nachteil dieser L\(o:sung ist allerdings,
da\(ss man sich wegen der Seiteneffekte \(u:ber die
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten und
die Auswertungsreihenfolge Gedanken machen mu\(ss und eventuell
geeignete Attribute und
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten einf\(u:hren mu\(ss,
die nur die Aufgabe haben, eine bestimmte
Auswertungsreihenfolge der Attribute und damit eine korrekte
Reihenfolge der Seiteneffekte zu erzwingen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Aufbau von Typbeschreibungen\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Aufbau von Typbeschreibungen
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Allen Typknoten der abstrakten Syntax wird in der Attributgrammatik eine
Typbeschreibung als abgeleitetes Attribut zugeordnet. Um die oben genannten
zyklischen Abh\(a:ngigkeiten der Typbeschreibungen behandeln zu k\(o:nnen,
erfolgt deren Aufbau in zwei Schritten.
Das Attribut \%\fIType2\fP ist die vollst\(a:ndige Typbeschreibung; ein weiteres
Attribut \%\fIType1\fP ist eine vorl\(a:ufige und unvollst\(a:ndige Typbeschreibung,
welche w\(a:hrend des Aufbaus der vollst\(a:ndigen Typbeschreibungen als
Zwischenergebnis auftritt.
.sp 0.4v
.ne 2v
.ti +2n
Folgender Ausschnitt der Attributgrammatik demonstriert den Proze\(ss des Aufbaus
von Typbeschreibungen (vgl. Anh. A):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
Type    = { Type2 AFTER Env2;                              } .
Pointer = { Type1  := mPointer1 ();
            Type2  := mPointer2 (Type1, TargetType:Type2); } .
.br
.ne 3
TypeId0 = { Object := Identify (Ident, Env1);
            Type1  := mQualident1 (Object);
            Type2  := GroundType (Type1);                  } .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die oben beschriebene Umgebung \%\fIEnv1\fP erm\(o:glicht es,
den Typnamen die zugeh\(o:rigen Objektbeschreibungen zuzuordnen, die
allerdings noch keine Typbeschreibung f\(u:r den Typ enthalten.
\%\fIQualident1\fP bildet eine vorl\(a:ufige
Typbeschreibung f\(u:r Typnamen, die einen Verweis auf die Objektbeschreibung des
Typnamens enth\(a:lt.
F\(u:r andere Typknoten wird eine vorl\(a:ufige
Typbeschreibung angelegt, die zwar der endg\(u:ltigen Typbeschreibung entspricht,
die aber nur die Information enth\(a:lt, um welche Art von Typ es sich
handelt.
Die \(u:brigen Informationen \(u:ber den Typ, wie z.B. bei Zeigertypen der
Bezugstyp, werden als ,,non-input'' Attribute behandelt.
.sp 0.4v
.ne 2v
.ti +2n
In einem vollst\(a:ndigen
Durchlauf durch alle Deklarationen
des Programms werden die vorl\(a:ufigen Typbeschreibungen
\%\fIType1\fP in die Objektbeschreibungen der benannten
Typen aufgenommen (Berechnung des
Attributs \%\fIObjects2\fP). \%\fIObjects2\fP wird f\(u:r die Berechnung eines
zweiten ,,Umgebungsattributs'' \%\fIEnv2\fP verwendet, dessen einzige Funktion es
ist,
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten
zu definieren, die garantieren,
da\(ss die vollst\(a:ndigen Typbeschreibungen
\%\fIType2\fP erst berechnet werden, wenn alle vorl\(a:ufigen Typbeschreibungen
in die Objektbeschreibungen der benannten Typen eingetragen wurden. Wegen der
k\(u:nstlichen
At\%tri\%but\%ab\%h\(a:n\%gig\%keit
\%\fIType2\fP\ AFTER\ \fIEnv2\fP
wird \%\fIType2\fP erst nach \%\fIEnv2\fP berechnet.
.sp 0.4v
.ne 2v
.ti +2n
Mit Hilfe der im Modul \%\fIDefs\fP definierten Funktion \%\fIGroundType\fP kann
man dann aus der vorl\(a:ufigen Typbeschreibung eines Typnamens die endg\(u:ltige
Typbeschreibung dieses Typs bestimmen. \%\fIGroundType\fP ist folgenderma\(ssen
definiert (vereinfacht ohne Fehlerbehandlung):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
PROCEDURE GroundType    (Type: tType): tType;
BEGIN
  IF Type^.Kind = Qualident1 THEN
    RETURN GroundType (Type^.Qualident1.Object^.TypeDecl1.Type);
  END;
.br
.ne 2
  RETURN Type;
END GroundType;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Durch rekursive Aufrufe werden die Typ- bzw. Objektbeschreibungen
solange traversiert bis eine Typbeschreibung f\(u:r einen Typnamen
gefunden wird, die keine vorl\(a:ufige Typbeschreibung der Form
\%\fIQualident1\fP ist
(Typgleichsetzungen k\(o:nnen \(u:ber eine beliebige Anzahl von Stufen geschrieben
werden). \%\fIGroundType\fP liefert die so gefundene Typbeschreibung
f\(u:r den Typnamen an den Aufrufer zur\(u:ck.
.sp 0.4v
.ne 2v
.ti +2n
Der Aufbau der vollst\(a:ndigen Typbeschreibung \%\fIType2\fP
erfolgt dann schlie\(sslich dadurch, da\(ss die noch fehlenden Informationen, wie
z.B. bei Zeigertypen die Typbeschreibung des Bezugstyps
\%\fITargetType\fP:\fIType2\fP, in die
vorl\(a:ufige Typbeschreibung \%\fIType1\fP eingetragen wird.
Diese vollst\(a:ndigen Typbeschreibungen k\(o:nnen dann bei der Berechnung des
Attributs \%\fIObjects3\fP in die Objektbeschreibungen der benannten Typen
aufgenommen und als Typbeschreibung in den Objektbeschreibungen der
Variablen, Prozeduren, usf. verwendet werden.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Behandlung des Modulkonzepts\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Behandlung des Modulkonzepts
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Zus\(a:tzlich zur Blockstruktur erm\(o:glicht \%Modula-2 mit dem
Modulkonzept eine explizite Kontrolle des G\(u:ltigkeitsbereichs von Bezeichnern
durch Import- bzw. Exportanweisungen. Eine wichtige Sonderregel in diesem
Zusammenhang ist, da\(ss mit dem Import- bzw. Export eines Aufz\(a:hlungstyps auch
automatisch die zugeh\(o:rigen Aufz\(a:hlungsliterale importiert bzw. exportiert
werden. Die vordefinierten Objekte von \%Modula-2 m\(u:ssen nicht explizit
importiert werden, sondern sind automatisch in jedem Modul sichtbar. Bei der
Behandlung von Implementierungsmoduln mu\(ss au\(sserdem beachtet werden, da\(ss alle
im zugeh\(o:rigen Definitionsmodul definierten Konstanten, Typen und Variablen
im Implementierungsmodul ebenfalls automatisch sichtbar sind.
.sp 0.4v
.ne 2v
.ti +2n
Der folgende Ausschnitt der Attributgrammatik zeigt, wie die oben genannten
Regeln in der
Attributgrammatik behandelt werden (vgl. Anh. A):
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 5
ProgMod = { Import:Env2 := Env3;
            DefObjects3 := Filter (GetExport2 (Identify (Ident, Env3)));
            Decls:Env3  :=
              mEnv (UNION (UNION (UNION (Predefs, Import:Objects2),
                    Decls:Objects3), DefObjects3), NoEnv);            } .
From    = { Object2     := Identify (Ident, Env2);
            ImpIds:Env2 := mEnv (GetExport2 (Object2), NoEnv);
            Objects2    := UNION (ImpIds:Objects2, Next:Objects2);    } .
ImpIds1 = { Object2     := Identify (Ident, Env2);
            Type        := GetType (Object2);
            Objects2    := {
          IF (Object2^.Kind = TypeDecl1   ) AND
             (Type^.Kind    = Enumeration1) THEN
            Objects2    :=
              mElmt (Ident, Object2, UNION (Type^.Enumeration1.Objects,
                     Next:Objects2));
          ELSE
.br
.ne 2
            Objects2    := mElmt (Ident, Object2, Next:Objects2);
          END;          };                                            } .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Das Attribut \%\fIDefObjects3\fP ist eine Objektliste, welche die im zum
Implementierungsmodul dazugeh\(o:rigen Definitionsmodul definierten Konstanten,
Typen und Variablen enth\(a:lt. Die Berechnung erfolgt dadurch, da\(ss in der
Umgebung des Implementierungsmoduls zun\(a:chst durch einen Aufruf von
\%\fIIdentify\fP die Objektbeschreibung des (De\%fi\%ni\%ti\%ons-)Mo\%duls bestimmt
und aus dieser dann die Liste der exportierten Objekte entnommen wird. Da diese
Exportliste zun\(a:chst noch die Definition von Prozedurk\(o:pfen und opaquen Typen
enth\(a:lt, die im Implementierungsmodul redeklariert werden m\(u:ssen, wird mit
Hilfe der im Modul \%\fIDefs\fP definierten Funktion \%\fIFilter\fP eine neue
Objektliste aufgebaut, die diese nicht mehr enth\(a:lt.
.sp 0.4v
.ne 2v
.ti +2n
In einer Importanweisung der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FROM Module IMPORT Object1, ... , Objectn;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
ist die f\(u:r den Bezeichner \%\fIModule\fP g\(u:ltige Umgebung, die Umgebung des
Moduls, der die Importanweisung enth\(a:lt. Die Umgebung der Bezeichner
\%\fIObject1\fP bis \%\fIObjectn\fP ergibt sich aus der Liste der
Objekte, die von \%\fIModule\fP exportiert werden.
Diese Tatsache wird im obigen Ausschnitt der
Attributgrammatik durch die Attributierungsregeln zur Berechnung der
Umgebungsattribute \%\fIImport\fP:\fIEnv2\fP und \%\fIImpIds\fP:\fIEnv2\fP
reflektiert.
.sp 0.4v
.ne 2v
.ti +2n
Die importierten Objekte werden in der Objektliste \%\fIObjects2\fP
gesammelt. Die Attributierungsregeln f\(u:r den Knotentyp \%\fIImpIds1\fP zeigen
dabei, wie der implizite Import von Aufz\(a:hlungsliteralen behandelt wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Umgebung \%\fIEnv3\fP der Deklarationen des
Implementierungsmoduls
ergibt sich schlie\(sslich aus einer Vereinigung der vordefinierten
Objekte \%\fIPredefs\fP, der explizit importierten Objekte
\%\fIImport\fP:\fIObjects2\fP, der Objekte aus dem Definitionsmodul
\%\fIDefObjects3\fP und aus den lokal deklarierten Objekten
\%\fIDecls\fP:\fIObjects3\fP. Die Tatsache, da\(ss die \(a:u\(ssere Umgebung eines
Moduls vollst\(a:ndig verdeckt wird, ist aus der Verwendung der leeren Umgebung
\%\fINoEnv\fP als \(a:u\(ssere Umgebung des Moduls im Aufruf von \%\fImEnv\fP zu
entnehmen.
.hA 4 2v 1v
\fB\n(h1.\n(h2.\n(h3.\n(h4
.hB \w'\n(h1.\n(h2.\n(h3.\n(h4'u
\&Typbestimmung in Ausdr\(u:cken\fP
.hC 1v 0n 0v (4n+5n+7n) 0v
\&\n(h1.\n(h2.\n(h3.\n(h4\ 
.hD 9n
\&Typbestimmung in Ausdr\(u:cken
.hE (4n+5n+7n) 9n 0v
.sp 0.4v
.ne 2v
.ti +2n
Den Ausdr\(u:cken wird ein abgeleitetes Attribut \%\fIType\fP zugeordnet, welches
den Typ des Ausdrucks beschreibt. Die Berechnung dieses Attributs erfolgt, wie
der folgende Beispielausschnitt der Attributgrammatik zeigt (vgl.  Anh. A),
mit Hilfe der in
\%\fITypes\fP definierten Operationen auf Typen und den in \%\fIDefs\fP enthaltenen
Operationen f\(u:r den Zugriff auf Objekt- und Typbeschreibungen.
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 3
Binary    = { Type := ResultType (Operator, Lop:Type, Rop:Type);  } .
RealConst = { Type := TypeREAL;                                   } .
Qualid0   = { Type := GetType (Object);                           } .
Subscript = { Type := GetElemType (Designator:Type);              } .
Deref     = { Type := GetTargetType (Designator:Type);            } .
FuncCall  = { Type := {
            IF Designator:Type^.Kind = StdProcType1 THEN
              Type := StdResultType (Designator:Type, Actuals:Types);
            ELSIF Designator:Type^.Kind = ProcType1 THEN
              Type := GetResultType (Designator:Type);
            ELSE /* may be a type transfer function  */
.br
.ne 2
              Type := Designator:Type;
            END;   };                                             } .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Die in \%\fITypes\fP definierte Funktion \%\fIStdResultType\fP ermittelt aus dem
Typ einer Standardprozedur und den Typen der aktuellen Parameter
den Resultattyp des Aufrufs dieser Standardprozedur. Die
Typen der aktuellen Parameter sind notwendig, da ein Teil der
Standardprozeduren wie z.B. \%ABS, \%MIN und \%MAX in
\%Modula-2 \(u:berladen sind.
.sp 0.4v
.ne 2v
.ti +2n
Die Typen der Ausdr\(u:cke werden
f\(u:r die Codeerzeugung ben\(o:tigt, um z.B. den korrekten
C-Operator f\(u:r \(u:berladene Modula-Operatoren einsetzen zu k\(o:nnen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Berechnung von Attributen f\(u:r die Codeerzeugung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Berechnung von Attributen f\(u:r die Codeerzeugung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r die Durchf\(u:hrung der Codeerzeugung m\(u:ssen weitere Informationen \(u:ber
das Quellprogramm abgeleitet werden, die \(u:ber die in der semantischen Analyse
berechneten Attribute hinausgehen und die f\(u:r eine korrekte \(U:bersetzung
nach C ben\(o:tigt werden. Diese
Attributberechnungen sind ebenfalls Teil der im vorigen Kapitel beschriebenen
Attributgrammatik.
.sp 0.4v
.ne 2v
.ti +2n
Zur besseren Gliederung der Attributgrammatik erm\(o:glicht \%\fIAg\fP deren
Unterteilung in sogenannte Moduln, die es erlauben, logisch zusammengeh\(o:rige
Attributdeklarationen und die
zugeh\(o:rigen Attributberechnungen auch textuell zusammenzufassen.
Daher sind die Attributberechnungen
f\(u:r die semantische Analyse und die Berechnung von Attributen f\(u:r die
Codeerzeugung textuell eindeutig getrennt. Diese Trennung erleichtert eine
eventuelle Wiederverwendung des Front-Ends von \%\fIMtc\fP.
.sp 0.4v
.ne 2v
.ti +2n
Die Trennung der
Attributberechnungen in semantische Analyse und Berechnung von Attributen f\(u:r
die Codeerzeugung ist auf den ersten Blick teilweise etwas willk\(u:rlich,
da z.B. die in der
semantischen Analyse bestimmten Typen der Ausdr\(u:cke auch f\(u:r die
Codeerzeugung ben\(o:tigt werden. Die Unterscheidung wurde aber auf folgender
Basis getroffen: Alle Attribute, die auch ben\(o:tigt w\(u:rden, falls man die
semantische Korrektheit der Modula-Programme \(u:berpr\(u:fen wollte, werden zur
semantischen Analyse gez\(a:hlt. Alle anderen Attribute, die ausschlie\(sslich f\(u:r
eine \(U:bersetzung nach C notwendig sind, z\(a:hlen zu den Attributen f\(u:r die
Codeerzeugung. Im Folgenden sollen die wichtigsten dieser
Attribute \(u:bersichtsartig vorgestellt werden.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r die Operatoren der Sprache \%Modula-2 ist eine Operatoridentifikation
notwendig, da eine Reihe von Operatoren in \%Modula-2 \(u:berladen sind und
daher auf unterschiedliche C-Operatoren abgebildet werden m\(u:ssen. Die
Knotentypen, welche die Operatoren als Attribute enthalten (vgl. Anh. A),
erhalten daher ein Attribut
\%\fICOperator\fP, welches den zugeh\(o:rigen C-Operator beschreibt. Die
Berechnung dieses Attributs erfolgt mit Hilfe des Modula-Operators und den
Typen der Operanden des zugeh\(o:rigen Ausdrucks.
.sp 0.4v
.ne 2v
.ti +2n
Wie in Kapitel 4 erl\(a:utert, mu\(ss f\(u:r eine Reihe
von Modula-Ausdr\(u:cken bekannt
sein, ob diese Ausdr\(u:cke in C konstant sind. Sie erhalten daher ein
boolesches Attribut \%\fIIsCConst\fP.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r die \(U:bersetzung des Zugriffs auf lokale Variablen von statisch umfassenden
Prozeduren nach C (s. Kap. 4.4.4) existieren die folgenden
Attribute:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Das boolesche Attribut \%\fIIsGlobalPtr\fP wird jedem Bezeichner
in Ausdr\(u:cken oder Anweisungen zugeordnet. Das Attribut ist wahr, falls der
Bezeichner eine lokale Variable einer statisch umfassenden Prozedur bezeichnet
und daher der Zugriff in C mit Hilfe einer globalen Zeigervariablen realisiert
werden mu\(ss.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Das Attribut \%\fILocalPtrs\fP, welches jeder Deklaration einer
Prozedur \%\fIp\fP
zugeordnet wird, ist eine Liste aller lokalen Variablen von \%\fIp\fP, die in
lokal zu \%\fIp\fP deklarierten Prozeduren benutzt werden.
Es wird ben\(o:tigt, um f\(u:r die nach C \(u:bersetzte Prozedur \%\fIp\fP den
entsprechenden \%Code f\(u:r eine Realisierung des Zugriffs auf diese lokalen
Variablen zu erzeugen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Programm- und Implementierungsmoduln wird ein Attribut \%\fIGlobalPtrs\fP
zugeordnet, welches eine Vereinigung der Attribute \%\fILocalPtrs\fP ist und
f\(u:r die Erzeugung der oben erw\(a:hnten
globalen Zeigervariablen benutzt wird.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die \(U:bersetzung der varianten Teile der Verbunde nach C erfordert die
Berechnung von zus\(a:tzlichen Komponentenselektoren (s. Kap. 4.4.2.7). Die
entsprechenden Selektoren werden den varianten Teilen der Verbunde im
Strukturbaum zugeordnet und auch in die Objektbeschreibungen der zugeh\(o:rigen
Verbundkomponenten \(u:bernommen, um Zugriffe auf diese
Komponenten korrekt \(u:bersetzen zu k\(o:nnen.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Umbenennung von Bezeichnern\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Umbenennung von Bezeichnern
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
In Kapitel 4 wurde ausf\(u:hrlich dargelegt, welche Bezeichner im
C-Programm f\(u:r die Modula-Objekte verwendet werden. Es wurden im wesentlichen
2 F\(a:lle unterschieden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner eines von einem globalen Modul
exportierten Objekts wird in C in der
qualifizierten Form \%\fIModulname_Bezeichner\fP geschrieben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle \(u:brigen Bezeichner werden direkt aus dem Modula-Programm
\(u:bernommen, werden aber bei Bedarf zur Vermeidung von Namenskonflikten mit
einem Pr\(a:fix \%\fIC_nnn_\fP versehen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
In der Attributgrammatik wird f\(u:r jedes im Modula-Programm deklarierte Objekt
ein Attribut \%\fICIdent\fP berechnet,
welches den C-Bezeichner dieses Objekts darstellt. Dieser Bezeichner mu\(ss auch
in die Objektbeschreibung \(u:bernommen werden, um bei jedem angewandten
Auftreten des Bezeichners den richtigen C-Bezeichner einsetzen zu
k\(o:nnen.
.sp 0.4v
.ne 2v
.ti +2n
Zur Entdeckung und Vermeidung von m\(o:glichen Namenskonflikten
existiert der Modul \%\fIUniqueIds\fP, welcher die Verwaltung der im
C-Programm verwendeten unqualifizierten Bezeichner
entsprechend den G\(u:ltigkeitsbereichsregeln der Sprache C \(u:bernimmt.
Qualifizierte Bezeichner der Form \%\fIModulname\fP_\fIBezeichner\fP
brauchen nicht von
\%\fIUniqueIds\fP verwaltet zu werden, da f\(u:r sie auf Grund der Eindeutigkeit
von globalen Modulnamen keine Namenskonflikte entstehen k\(o:nnen.
Die wichtigsten Operationen des Moduls \%\fIUniqueIds\fP sind:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
NameConflict : Ident \(mu IdentClass \(mu Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' BOOLEAN .
DeclareIdent : Ident \(mu IdentClass \(mu Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Idents .
.br
.ne 2
EnterProc    : Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Idents .
LeaveProc    : Idents \(->\v'+0.3m'\s-4\s+4\v'-0.7m'\s-4\s+4\v'+0.4m' Idents .
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
\%\fINameConflict\fP \(u:berpr\(u:ft, ob die
Verwendung eines bestimmten Bezeichners zu einem Namenskonflikt mit einem
bereits verwendeten Bezeichner f\(u:hren w\(u:rde. \%\fIDeclareIdent\fP deklariert
einen Bezeichner als im C-Programm verwendet. \%\fIEnterProc\fP und
\%\fILeaveProc\fP werden zu Beginn und am Ende der Behandlung der lokalen
Deklarationen einer Prozedur aufgerufen.
.sp 0.4v
.ne 2v
.ti +2n
Die Bezeichner werden entsprechend ihrer Art bzw.
der Art des zugeh\(o:rigen Objekts in folgende Klassen eingeteilt (vgl. Kap. 4):
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Schl\(u:sselw\(o:rter: \%\fIUniqueIds\fP behandelt eine Reihe von
Bezeichnern als Schl\(u:sselw\(o:rter (Bezeichner f\(u:r vom \(U:bersetzer
vordefinierte Objekte und Schl\(u:sselw\(o:rter der Sprache C).
\%\fINameConflict\fP liefert f\(u:r einen Schl\(u:sselwortbezeichner
immer wahr, was dazu f\(u:hrt, da\(ss der Bezeichner auf jeden Fall durch einen
Pr\(a:fix umbenannt wird.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Konstanten- und Typbezeichner, die im C-Programm
innerhalb einer Quelldatei nur genau einmal auftreten d\(u:rfen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Prozedurbezeichner: alle Prozedurbezeichner sind in C globale
Bezeichner.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bezeichner von Verbundkomponenten.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Variablenbezeichner, die nicht in lokalen Moduln deklariert sind.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Variablenbezeichner, die in lokalen Moduln deklariert sind.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Die Variablen, die in einem in \%Modula-2
lokal zu einer Prozedur deklarierten Modul enthalten sind,
werden in C zu lokalen Variablen
dieser Prozedur. Im folgenden Beispiel
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.br
.ne 2
PROCEDURE p;
  ...
PROCEDURE q;
  MODULE l;
    ...
    VAR p: INTEGER;
    ...
  END l;
.br
.ne 3
BEGIN
  p;
END q;
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
mu\(ss bei der \(U:bersetzung nach C die lokale Variable \%\fIp\fP (in
C lokal zu \%\fIq\fP deklariert) umbenannt werden,
da sonst der globale Prozedurbezeichner \%\fIp\fP im Rumpf von
\%\fIq\fP verdeckt w\(u:rde. Aus diesem
Grund werden in lokalen Moduln deklarierte Variablen von \%\fIUniqueIds\fP immer
behandelt, als w\(u:rde in C f\(u:r diese Variablen sowohl eine lokale Deklaration
in der entsprechenden Prozedur als auch eine globale Deklaration existieren.
Diese Behandlung f\(u:hrt dazu, da\(ss im obigen Beispiel die Variable \%\fIp\fP
umbenannt wird, da im gleichen G\(u:ltigkeitsbereich bereits der
Prozedurbezeichner \%\fIp\fP deklariert wurde.
Bei einer Behandlung von \%\fIp\fP ausschlie\(sslich als lokale
Variable von \%\fIq\fP w\(u:rde
kein Namenskonflikt entdeckt, da \%\fIUniqueIds\fP nur Informationen \(u:ber die
Deklaration der Bezeichner und nicht auch \(u:ber deren Anwendung enth\(a:lt.
F\(u:r in \%Modula-2 lokal in einer Prozedur deklarierte Variablen
kann das Problem nicht auftreten, da sowohl in \%Modula-2
als auch in C identische globale Bezeichner
durch diese Deklaration verdeckt werden.
.sp 0.4v
.ne 2v
.ti +2n
Die meisten Operationen des Moduls \%\fIUniqueIds\fP haben einen Seiteneffekt.
In der Attributgrammatik garantieren die beiden Attribute \%\fIIdsIn\fP und
\%\fIIdsOut\fP, welche die jeweils aktuelle Menge von
C-Bezeichnern repr\(a:sentieren, da\(ss diese Seiteneffekte in der richtigen
Reihenfolge ausgef\(u:hrt werden und insbesondere, da\(ss der C-Bezeichner
\%\fICIdent\fP zum richtigen Zeitpunkt berechnet wird.
Der gro\(sse Vorteil dieser L\(o:sung mit Seiteneffekten ist, da\(ss die Operationen
des Moduls
\%\fIUniqueIds\fP sehr zeit- und speichereffizient programmiert werden k\(o:nnen.
Insbesondere ist der Aufwand f\(u:r \%\fINameConflict\fP und \%\fIDeclareIdent\fP
in der Gr\(o:\(ssenordnung \%O(1).
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Codeerzeugung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Codeerzeugung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Eingabe f\(u:r die Codeerzeugung ist der attributierte Strukturbaum des
Modula-Programms, der alle f\(u:r die \(U:bersetzung nach C notwendigen
semantischen Informationen enth\(a:lt. Die Ausgabe
der Codeerzeugung ist ein C-Programm bzw. eine C-Definitionsdatei f\(u:r die
aktuelle \(U:bersetzungseinheit.
.sp 0.4v
.ne 2v
.ti +2n
Durch Angabe einer Option kann man
\%\fIMtc\fP dazu veranlassen, auch Definitionsdateien f\(u:r alle
transitiv importierten Definitionsmoduln zu erzeugen. Diese Option ist
insbesondere dann n\(u:tzlich, wenn man \(em
z.B. f\(u:r Testzwecke \(em zun\(a:chst nur einen
einzelnen Implementierungs- oder Programmodul nach C \(u:bersetzen und diesen
dann vom C-\(U:bersetzer in ein Objektprogramm \(u:bersetzen lassen m\(o:chte.
F\(u:r diese
\(U:bersetzung ben\(o:tigt der C-\(U:bersetzer die Definitionsdateien aller transitiv
importierten Definitionsmoduln, da diese mit \fI#include\fP\^-An\%wei\%sun\%gen in das
C-Programm eingef\(u:gt werden. Durch die oben genannte Option wird es
\(u:berfl\(u:ssig diese Definitionsmoduln einzeln nach C zu \(u:bersetzen;
insbesondere braucht man nicht m\(u:hsam abzuleiten, welche
(De\%fi\%ni\%ti\%ons-)Mo\%duln
denn tats\(a:chlich importiert werden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Spezifikation des Codegenerators\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Spezifikation des Codegenerators
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Der Codegenerator, der im Modul \%\fICode\fP enthalten ist, wurde mit Hilfe des
Generators \%\fIEstra\fP [Vielsack\|89]
aus einer formalen Spezifikation der Codeerzeugung
generiert. \%\fIEstra\fP ist ein Werkzeug f\(u:r die Spezifikation und
Implementierung der Transformation von attributierten B\(a:umen. Im Folgenden
wird kurz darauf eingegangen, wie eine solche Spezifikation und die
daraus abgeleitete Implementierung im Prinzip aussehen. Die Spezifikation
der Codeerzeugung wird nicht
im Detail er\(o:rtert, da es sich dabei lediglich um eine Umsetzung der
in Kapitel
4 verbal beschriebenen Abbildung von \%Modula-2 nach C in eine
formale Spezifikation f\(u:r \%\fIEstra\fP handelt.
.sp 0.4v
.ne 2v
.ti +2n
Die Beschreibung der Transformation besteht im wesentlichen aus zwei Teilen:
Einer Baumgrammatik, welche die Struktur der zu transformierenden B\(a:ume
beschreibt und einer oder mehreren Funktionen, die die Abbildung der B\(a:ume
beschreiben. Eine Funktion besteht aus der Festlegung des
Definitionsbereichs, aus einer Angabe von synthetisierten und
vererbten Attributen sowie aus Vorschriften wie die
Transformation durchgef\(u:hrt werden soll. Der Definitionsbereich legt fest, auf
welche Knotentypen die Funktion anwendbar ist. Die Vorschriften, die
die Abbildung im Einzelnen festlegen, bestehen aus
einem Muster, welches angibt auf welche
Teilb\(a:ume die betreffende Vorschrift angewandt werden kann
und aus Anweisungen, die
festlegen wie der Teilbaum behandelt werden soll. Diese Anweisungen
k\(o:nnen insbesondere Aufrufe von Funktionen f\(u:r die Transformation von
Unterb\(a:umen enthalten. Die Anwendbarkeit bestimmter Vorschriften kann durch
Bedingungen eingeschr\(a:nkt werden. Damit wird es m\(o:glich, die vom
Attributauswerter berechneten semantischen Informationen
f\(u:r die Festlegung der Transformation zu ber\(u:cksichtigen.
F\(u:r eine Aufl\(o:sung von Mehrdeutigkeiten dient die Angabe von Kosten f\(u:r die
Anwendung von Vorschriften. Werden diese Kosten durch eine Konstante
festgelegt, so ergeben sich die Kosten der Anwendung einer Vorschrift aus der
Summe dieser Konstanten und den Kosten der Funktionsaufrufe f\(u:r die
Transformation der Unterb\(a:ume, die in
den Anweisungen enthalten sind. Wird dies nicht gew\(u:nscht, so besteht auch die
M\(o:glichkeit die Kosten durch einen Ausdruck der Quellsprache (in
geschweiften Klammern) direkt
festzulegen. Bei der Transformation wird immer die kosteng\(u:nstigste
Vorschrift angewandt.
.sp 0.4v
.ne 2v
.ti +2n
Folgender Ausschnitt der Funktion f\(u:r die Spezifikation der Codeerzeugung
f\(u:r Ausdr\(u:cke
soll obenerw\(a:hntes noch einmal erl\(a:utern:
.br
.ne 2
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
FUNCTION CodeExpr  Prec: SHORTCARD  ->  /Expr, Elems/
  ...
.br
.ne 3
Subscript   (Qualid0 (), Index: Expr)
            CONDITION { IsOpenArray (Qualid0.Object) }
            COSTS { 1 }
.br
.ne 4
{
    CodeExpr (Qualid0, pSubscript); @[@ CodeExpr (Index, pMinPrec); @]@
}
  ...
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
.sp 0.4v
.ne 2v
.ti +2n
Das vererbte Attribut \%\fIPrec\fP ist der C-Vorrang des Operators im
Vaterausdruck und wird ben\(o:tigt, um die Ausdr\(u:cke in C korrekt zu klammern.
Da die Indexoperation in C den h\(o:chsten Vorrang hat, ist in obigem Beispiel
eine Klammerung nicht notwendig. Die Bedingung in der Vorschrift schr\(a:nkt
ihre Anwendbarkeit auf offene Felder ein (vgl. Kap.
4.5.1). Die Anweisungen legen die Abbildung des Zugriffs auf offene Felder
fest und enthalten Funktionsaufrufe f\(u:r die Transformation der Unterb\(a:ume.
\%@[@ ist eine Anweisung f\(u:r einen Pr\(a:prozessor, der
f\(u:r eine bessere Lesbarkeit der Spezifikation und zur Vereinfachung der
Schreibweise f\(u:r Anweisungen zur Ausgabe von C-Programmtext mit Hilfe des
Zeileneditors \%\fIsed\fP implementiert wurde,
die in \%WriteC\ (f,\ '['); umgesetzt wird.
.sp 0.4v
.ne 2v
.ti +2n
Da die meisten Attribute bereits vom Attributauswerter berechnet werden, wird
von der von \%\fIEstra\fP angebotenen M\(o:glichkeit f\(u:r die Attribut\ierung nur
wenig Gebrauch gemacht. Eine
unterschiedliche Transformation bestimmter Knotentypen, abh\(a:ngig vom Ort des
zugeh\(o:rigen Teilbaums, wie z.B. die unterschiedliche Abbildung von
Deklarationen in Definitionsmoduln bzw. Implementierungs- und Programmoduln
(s. Kap. 4.8) oder auch die mehrfache Transformation eines Teilbaums
auf unterschiedliche Art und Weise, wie sie z.B. f\(u:r die Umordnung der
Deklarationen (s. Kap. 4.3) ben\(o:tigt wird, wird dadurch erreicht,
da\(ss f\(u:r jede dieser
unterschiedlichen Transformationen eine eigene Funktion existiert, die dann an
den entsprechenden Stellen aufgerufen wird.
.sp 0.4v
.ne 2v
.ti +2n
Die Spezifikation des Codegenerators wird von \%\fIEstra\fP in eine
Implementierung umgesetzt. Diese Implementierung f\(u:hrt die Transformation in
zwei Schritten durch. Zun\(a:chst wird in einem vorbereitenden
Schritt festgelegt, welche
Vorschriften f\(u:r die Transformation des vorhandenen Baums anzuwenden sind.
Dazu wird bei einem Bottom-Up-Baumdurchlauf gepr\(u:ft, welche Muster auf
welche Knoten (Teilb\(a:ume) passen und ob die
zugeh\(o:rigen Bedingungen erf\(u:llt sind. F\(u:r jede existierende Funktion wird
aus den anwendbaren Vorschriften diejenige mit den geringsten Kosten
ausgew\(a:hlt und im Knoten zusammen mit ihren Kosten festgehalten. Die
eigentliche Durchf\(u:hrung der Transformation erfolgt im zweiten Schritt durch
Anwendung der ersten Funktion auf die Wurzel des Baums. Die Transformation
erfolgt dann unter Ber\(u:cksichtigung der im ersten Schritt festgelegten
Vorschriften durch Ausf\(u:hrung der in den Anweisungen dieser
Vorschriften enthaltenen Funktionsaufrufe f\(u:r die Teilb\(a:ume.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\& Nachoptimierung des Codegenerators\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\& Nachoptimierung des Codegenerators
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
\%\fIEstra\fP ist ein im Rahmen einer Diplomarbeit entwickelter
Prototyp. Die Spezifikation des Codegenerators von \%\fIMtc\fP war die erste
gr\(o:\(ssere Anwendung von \%\fIEstra\fP und es lagen aus diesem Grund
bisher noch keine
praktischen Erfahrungen mit gro\(ssen Anwendungen vor. Nachdem eine erste
(Teil-)Spezifikation der Codeerzeugung vorlag, ergaben Tests,
da\(ss der von \%\fIEstra\fP aus dieser Spezifikation erzeugte
Codegenerator einen
extrem hohen Speicherbedarf besa\(ss, der trotz der
heutigen relativ gro\(ssen Hauptspeichergr\(o:\(ssen f\(u:r gro\(sse Eingabeprogramme
einen Trashing-Effekt zur Folge hatte. Der hohe Hauptspeicherbedarf ergibt sich
daraus, da\(ss der Codegenerator bei der Vorbereitung der
Transformation (s. Kap. \n(h1.\n(h2.1)
in jedem Knoten f\(u:r jede existierende
Funktion die anwendbare Vorschrift (4 Byte) und die Kosten f\(u:r
diese Anwendung (4 Byte) ablegt. Die erste Version der Spezifikation der
Codeerzeugung bestand aus ca. 40 Funktionen, d.h. f\(u:r jeden Baumknoten
wurden etwa 320 Byte dynamischer Speicher angefordert.
.sp 0.4v
.ne 2v
.ti +2n
Um die Codeerzeugung nicht doch noch aus praktischen Gr\(u:nden ,,von Hand''
programmieren zu m\(u:ssen, war es notwendig, diesen Speicherbedarf durch eine
Ver\(a:nderung der Spezifikation und durch eine automatische Nachoptimierung des
von \%\fIEstra\fP erzeugten Codegenerators zu reduzieren.
.sp 0.4v
.ne 2v
.ti +2n
Ein erster Schritt zur Reduktion des Speicherbedarfs war, die Anzahl der
Funktionen in der Spezifikation und damit die in jedem Knoten
abgelegte Menge von Informationen zu reduzieren. Dies ist aber aus den folgenden
Gr\(u:nden nicht unbegrenzt m\(o:glich bzw. sinnvoll:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&F\(u:r bestimmte Knotentypen m\(u:ssen verschiedene Funktionen existieren,
da sie wie oben beschrieben mehrfach auf unterschiedliche Art und Weise
transformiert werden m\(u:ssen.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Eine gew\(u:nschte Modularisierung der Spezifikation f\(u:r Zwecke der
Verst\(a:ndlichkeit und Wartbarkeit l\(a:\(sst es nicht sinnvoll erscheinen, eine
Spezifikation von mehreren tausend Zeilen mit einer einzigen Funktion
festzulegen, selbst wenn dies theoretisch m\(o:glich w\(a:re.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Beim Einsatz von Attributen sind in der Regel
f\(u:r verschiedene Knotentypen
auch unterschiedliche Attribute und somit verschiedene
Funktionen notwendig.
.in -4n
.sp 0.1vv
.sp 0.3vv
Soweit dies logisch vertretbar erschien, wurden
einzelne Funktionen zusammengefa\(sst, so da\(ss die endg\(u:ltige Spezifikation der
Codeerzeugung nur noch aus 22 Funktionen besteht.
Allerdings hat sich die Lesbarkeit der Spezifikation
durch diese Zusammenfassung verschlechtert.
.sp 0.4v
.ne 2v
.ti +2n
Ein Ansatz f\(u:r eine automatische Nachoptimierung ergab sich aus folgender
\(U:berlegung: Die Kosten werden von \%\fIEstra\fP dazu benutzt, die
kosteng\(u:nstigste Vorschrift auszuw\(a:hlen. Die Kosten f\(u:r die
Transformation eines Baumknotens h\(a:ngen dabei im
allgemeinen \(em wie es z.B. in Codegeneratoren
f\(u:r Maschinensprache sinnvoll ist \(em von den Kosten f\(u:r die Transformation
beliebiger Unterb\(a:ume ab. Daher m\(u:ssen die
Kosten f\(u:r die Anwendung der einzelnen Vorschriften im Baum abgelegt werden.
F\(u:r eine Abbildung des attributierten Strukturbaums nach C kann man aber immer
bereits lokal an einem bestimmten Knoten entscheiden, wie dieser nach C
abzubilden ist, ohne dabei die Abbildung der Unterb\(a:ume bzw. deren Kosten
ber\(u:cksichtigen zu m\(u:ssen.
Die Kosten werden f\(u:r eine Abbildung nach C nur
ben\(o:tigt, um bei der Vorbereitung der Transformation
f\(u:r jeden Knoten lokal die kosteng\(u:nstigste Vorschrift ausw\(a:hlen zu k\(o:nnen.
Aus diesem Grund w\(u:rde es
v\(o:llig ausreichen, die Kosten, anstatt sie im Baum
abzuspeichern, in einer lokalen Variablen der Besuchsprozedur abzulegen, die
die Transformation vorbereitet. Nur die
Vorschrift selbst m\(u:\(sste dann noch im Baum gespeichert werden, um im zweiten
Schritt die Transformation durchf\(u:hren zu k\(o:nnen.
.sp 0.4v
.ne 2v
.ti +2n
In der Spezifikation wurden alle Kosten so
festgelegt, da\(ss die Kosten der Transformation eines bestimmten Knotens
nicht mehr von den Kosten der Transformation der Kindknoten (Unterb\(a:ume)
abh\(a:ngen. Mit Hilfe des Zeileneditors \%\fIsed\fP wurde der von \%\fIEstra\fP
erzeugte Codegenerator \(em wie oben angedeutet \(em
automatisch nachoptimiert. Das daf\(u:r verwendete \fISed\fP\^-Skript ist relativ
einfach und umfa\(sst nur ca. 40 Zeilen. Besonders wichtig ist, da\(ss diese
Nachoptimierung ohne Eingreifen des Benutzers automatisch durchgef\(u:hrt werden
kann, da es keinesfalls sinnvoll w\(a:re, ein von einem \(U:bersetzerbauwerkzeug
generiertes Programm noch nachtr\(a:glich ,,von Hand'' nachzuoptimieren, was dann
selbstverst\(a:ndlich bei jeder noch so kleinen \(A:nderung der Spezifikation
durchgef\(u:hrt werden m\(u:\(sste.
.sp 0.4v
.ne 2v
.ti +2n
Durch die oben beschriebenen Ma\(ssnahmen konnte der Speicherbedarf
der endg\(u:ltigen Version des Codegenerators auf etwa
1/4 des Speicherbedarfs der ersten Version reduziert werden.
Der Trashing-Effekt tritt daher f\(u:r Modula-Programme in praktisch
vorkommenden Gr\(o:\(ssen nicht mehr (so stark) in Erscheinung.
Im n\(a:chsten Kapitel wird bei der
Bewertung der Werkzeuge ein Vorschlag gemacht, wie \%\fIEstra\fP
unter Ausnutzung von in
der Spezifikation enthaltenen Informationen den
Speicherbedarf auf allgemeine Weise drastisch reduzieren k\(o:nnte.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Fehlerbehandlung\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Fehlerbehandlung
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Lexikalische Fehler wurden in der Spezifikation des
Sym\%bol\%ent\%schl\(u:ss\%lers
ber\(u:cksichtigt und werden daher vom \(U:bersetzer behandelt und gemeldet.
.sp 0.4v
.ne 2v
.ti +2n
Wie in Kapitel \n(h1.2.1 besprochen, besitzt der generierte Zerteiler eine
automatische Fehlerbehandlung. Dem Benutzer werden daher syntaktische Fehler
und die vom Zerteiler durchgef\(u:hrte Fehlerreparatur gemeldet.
.sp 0.4v
.ne 2v
.ti +2n
Bei der Behandlung der getrennten \(U:bersetzung k\(o:nnen zwei Fehler auftreten,
die vom \(U:bersetzer gemeldet werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Ein f\(u:r die \(U:bersetzung der aktuellen \(U:bersetzungseinheit ben\(o:tigter
Definitionsmodul kann nicht gefunden werden.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Es existieren \(em in \%Modula-2 verbotene \(em
zyklische Abh\(a:ngigkeiten zwischen den Definitionsmoduln.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Tritt w\(a:hrend der lexikalischen und syntaktischen Analyse oder bei der
Behandlung der getrennten \(U:bersetzung ein Fehler auf, dann wird die
\(U:bersetzung nach der entsprechenden \(U:bersetzerphase abgebrochen.
Da die aktuelle \(U:bersetzungseinheit und die
Definitionsmoduln aus verschiedenen Quelldateien stammen, enthalten die
Fehlermeldungen neben der Angabe von Zeile und Spalte im Quelltext auch immer
den Namen der zugeh\(o:rigen Quelldatei.
.sp 0.4v
.ne 2v
.ti +2n
Wie bereits besprochen, soll die semantische Korrektheit der
Eingabeprogramme vom \(U:bersetzer nicht \(u:berpr\(u:ft werden.
Nat\(u:rlich ist es trotzdem m\(o:glich, da\(ss ein semantisch falsches Programm als
Eingabe auftritt. Daher m\(u:ssen m\(o:gliche semantische Fehler, wie
z.B. eine bei der Bezeichneridentifikation entdeckte fehlende Deklaration f\(u:r
einen Bezeichner, zumindest intern behandelt werden, auch wenn solche Fehler
dem Benutzer nicht gemeldet werden.
F\(u:r die Behandlung dieser Fehler wird eine f\(u:r Attributgrammatiken
\(u:bliche Technik angewandt: F\(u:r die Attributtypen werden spezielle
Fehlerwerte eingef\(u:hrt, welche im Fehlerfall von den
entsprechenden Operationen zur\(u:ckgeliefert werden. Au\(sserdem erfolgt der
Zugriff auf semantische Informationen wie z.B. die Typ- und Objektbeschreibungen
nicht direkt, sondern durch spezielle Zugriffsoperationen, die \(u:berpr\(u:fen, ob
die Beschreibungen bestimmte semantische
Bedingungen erf\(u:llen und die bei Nichterf\(u:llung
der Bedingungen entsprechende Fehlerwerte zur\(u:ckliefern.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r semantisch falsche Programme wird aber in jedem Fall C-Code erzeugt.
Allerdings sind diese C-Programme in 95\^% der F\(a:lle entweder semantisch oder
meist sogar syntaktisch fehlerhaft und daher wird in der Regel der
C-\(U:bersetzer entdecken, da\(ss die urspr\(u:nglichen Modula-Programme fehlerhaft
waren.
.sp 0.4v
.ne 2v
.ti +2n
Falls eines der vom \(U:bersetzer nicht unterst\(u:tzten Modula-Konstrukte
im Quellprogramm auftritt, wird dies von der Codeerzeugung gemeldet.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Umfang der Implementierung des \(U:bersetzers\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Umfang der Implementierung des \(U:bersetzers
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.3 zeigt den Umfang der f\(u:r die Implementierung des
\(U:bersetzers \%\fIMtc\fP verwendeten Spezifikationen und den Umfang der
Quellmoduln, die aus diesen Spezifikationen erzeugt wurden.
.sp 1.5
.zA
\s-2
.TS
delim($$)tab(|) center box;
c| c s s| c s s
c| c c c| c c c
l| n n n| n n n .
\(U:bersetzerteil|Spezifikation|Erzeugter Quellmodul
_
|Formaler Teil|Quellcode|Summe|Def.-Modul|Impl.-Modul|Summe
_
Symbolentschl\(u:ssler|392|133|525|56|1320|1376
Zerteiler|934|87|1021|80|2918|2998
Strukturbaum|189|51|240|579|3234|3813
Definitionstabelle|118|985|1103|417|1549|1966
Attributauswerter|2071|159|2230|9|3591|3600
Codegenerator|2775|1030|3805|50|7448|7498
_
Summe|6479|2445|8924|1191|20060|21251
.TE
\s+2
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.3\fP: Umfang der Spezifikationen und der
daraus erzeugten Quellmoduln in Zeilen
.ce 0
.zE
.sp 1.5
Die Zahlen f\(u:r den Codegenerator beziehen sich auf die nachoptimierte Version.
Vor der Nachoptimierung betr\(a:gt seine Gr\(o:\(sse 7571 Zeilen.
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.4 zeigt Umfang (in Zeilen) und Anzahl der Moduln, aus denen
\%\fIMtc\fP besteht, wobei unterschieden wird zwischen aus
Spezifikationen erzeugten Moduln, Bibliotheksmoduln und ,,von Hand''
programmierten Moduln.
.sp 1.5
.zA
\s-2
.TS
delim($$)tab(|) center box;
c| c| c
l| n| n.
\(U:bersetzermoduln|Anzahl|Umfang
_
Aus Spezifikationen erzeugte Moduln|6|21251
Bibliotheksmoduln|18|3541
,,Von Hand'' programmierte Moduln|11|3871
_
Summe|35|28663
.TE
\s+2
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.4\fP: Umfang und Anzahl der Moduln von \%\fIMtc\fP
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Wie die beiden obigen Tabellen zeigen, besteht der \(u:berwiegende Teil des
\(U:bersetzers \%\fIMtc\fP aus
Moduln, die mit Hilfe von Werkzeugen aus Spezifikationen erzeugt wurden und
aus wiederverwendbaren Bibliotheksmoduln. Nur
ein relativ kleiner Teil des \(U:bersetzers besteht aus Moduln, die
ausschlie\(sslich ,,von Hand'' programmiert sind. Betrachtet man den gesamten
Umfang von \%\fIMtc\fP, dann wird klar, da\(ss die
Implementierung eines Programms dieses Umfangs und dieser Komplexit\(a:t ohne den
Einsatz von Werkzeugen und wiederverwendbarer Software kaum im Rahmen einer
Diplomarbeit m\(o:glich gewesen w\(a:re. 
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Praktische Ergebnisse\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Praktische Ergebnisse
.hE 0 4n 0.1v
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Test und erste Eins\(a:tze des \(U:bersetzers\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Test und erste Eins\(a:tze des \(U:bersetzers
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Da schon seit mehreren Jahren an der GMD Forschungsstelle Karlsruhe die Sprache
\%Modula-2 und der \(U:bersetzer \%MOCKA eingesetzt werden, bestand an
Testprogrammen f\(u:r den \(U:bersetzer \%\fIMtc\fP kein Mangel.
Anf\(a:nglich noch vorhandene Schw\(a:chen in der Abbildung von
\%Modula-2 nach C, insbesondere solche urspr\(u:nglich nicht
ber\(u:cksichtigten
Spezialf\(a:lle, wie die in Kapitel
4.2.2 beschriebenen Probleme bei der Abbildung von gro\(ssen ganzzahligen
Konstanten oder von Zeichenkonstanten, konnten daher relativ schnell entdeckt
und beseitigt werden.
.sp 0.4v
.ne 2v
.ti +2n
Der erste gro\(sse Test des \(U:bersetzers \%\fIMtc\fP, der auch mit dem Betreuer
zu Beginn der Diplomarbeit als Abnahmetest vereinbart worden war, war die
\(U:bersetzung von \%\fIMtc\fP selbst nach C. Dieser Test wurde von \%\fIMtc\fP
erfolgreich absolviert, so da\(ss \%\fIMtc\fP jetzt sowohl in der
urspr\(u:nglichen Modula-Version als auch in einer daraus erzeugten C-Version
vorliegt.
.sp 0.4v
.ne 2v
.ti +2n
Wichtigster und anspruchsvollster Test von \%\fIMtc\fP war die \(U:bersetzung des
Modula-\(U:bersetzers \%MOCKA nach C.
.sp 0.4v
.ne 2v
.ti +2n
Das erste dabei auftretende Problem war, da\(ss \%MOCKA eine
M\(o:glichkeit f\(u:r eine bedingte \(U:bersetzung mit Hilfe von
\(U:bersetzerschaltern besitzt, die in den Quellen von \%MOCKA
verwendet wird, um die
verschiedenen \%MOCKA-Versionen f\(u:r unterschiedliche
Zielmaschinen zu verwalten. Diese bedingte \(U:bersetzung wird von \%\fIMtc\fP
nicht unterst\(u:tzt. Die \%MOCKA-Versionen f\(u:r die SUN- und
PCS-Workstations mu\(ssten daher erst aus den Quellen mit den
\(U:bersetzerschaltern erzeugt werden. Dies konnte allerdings automatisch mit
Hilfe des Zeileneditors \%\fIsed\fP durchgef\(u:hrt werden.
.sp 0.4v
.ne 2v
.ti +2n
Das zweite auftretende Problem war, da\(ss von \%MOCKA eine im
Benutzerhandbuch nicht dokumentierte, aber in den Quellen benutzte
Spracherweiterung vorgenommen wird: \%MOCKA erlaubt es das Zeichen _ in
Bezeichnern wie einen Buchstaben zu verwenden. Daraufhin wurde die Spezifikation
des Sym\%bol\%ent\%schl\(u:ss\%lers von \%\fIMtc\fP so erweitert, da\(ss \%\fIMtc\fP diese
Spracherweiterung auch akzeptiert. Allerdings kann es jetzt, da die Umbenennung von
Bezeichnern davon ausgeht, da\(ss dieses Zeichen in Modula-Bezeichnern nicht
vorkommt, in ung\(u:nstigen F\(a:llen zu Namenskonflikten in den erzeugten
C-Programmen
kommen. Bei Verwendung des Zeichens _ in Bezeichnern gibt \%\fIMtc\fP daher
eine entsprechende Warnung aus.
.sp 0.4v
.ne 2v
.ti +2n
Ein weiteres Problem trat an den PCS-Workstations auf. Der Modul
\%\fISuValues\fP enth\(a:lt Konstantendeklarationen der Form
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
.zA
CONST UPBdiv8 = MaxLongCard DIV 8;
CONST UPBmod8 = MaxLongCard MOD 8;
...
.zE
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
wobei \%\fIMaxLongCard\fP den Wert \%MAX(LONGCARD) hat. Trotz der in Kapitel
4.2.2 besprochenen Typumwandlungen ist der C-\(U:bersetzer nicht in der
Lage,
diese Konstanten korrekt auszuwerten, da offensichtlich intern nur mit
\fIlong\fP\^-Werten gerechnet und \(U:ber- bzw. Unterlauf nicht erkannt wird.
Diese Konstanten mu\(ssten daher an den PCS-Workstations in den
C-Programmen ,,von Hand'' ausgewertet und eingesetzt werden. Der
C-\(U:bersetzer der Firma \%SUN ist dagegen in der Lage, diese konstanten
Ausdr\(u:cke korrekt auszuwerten. \%\fIMtc\fP gibt jetzt bei der Verwendung einer
Konstanten im Bereich von
\%MAX\^(INTEGER)\|+\|1\|..\|\%MAX\^(CARDINAL)
eine entsprechende Warnung ab.
.sp 0.4v
.ne 2v
.ti +2n
Das letzte auftretende Problem war folgender Typtransfer im Modul
\%\fICgMobil\fP:
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
GenLongIntMode (SHORTINT (0FFFFH), LowWordMaskOp);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
Der erste formale Parameter von \%\fIGenLongIntMode\fP hat den Typ
\%LONGINT. Der Wert des aktuellen Parameters nach der \(U:bergabe
ist in \%Modula-2 65535. Die \(U:bersetzung nach C liefert
.in +4n
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
GenLongIntMode((SHORTINT)0XFFFF, &LowWordMaskOp);
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.in -4n
In C ist der Wert des aktuellen Parameters nach der \(U:bergabe -1. In den
erzeugten C-Programmen mu\(sste daher die Typumwandlung entfernt werden, damit
\%MOCKA auch in C korrekt funktioniert. Da der Wert 0FFFFH
(=\%MAX(SHORTCARD)) eigentlich als SHORTINT-Wert \(u:berhaupt nicht
darstellbar ist
und au\(sserdem der Typtransfer keine erkennbare Funktion hat,
scheint die obige
Konstruktion aber prinzipiell fragw\(u:rdig zu sein und sollte aus den
Modula-Quellen von \%MOCKA entfernt werden.
.sp 0.4v
.ne 2v
.ti +2n
Nach der Beseitigung der obengenannten Probleme lag auch der
Modula-\(U:bersetzer \%MOCKA sowohl auf den PCS- als auch auf den
SUN-Workstations in einer C-Version vor und wurde auch bereits
f\(u:r die \(U:bersetzung von zahlreichen Modula-Programmen wie z.B.
\%\fIMtc\fP und \%MOCKA eingesetzt.
.sp 0.4v
.ne 2v
.ti +2n
Neben den beiden obengenannten gro\(ssen Testf\(a:llen wurden
noch folgende Modula-Programme mit \%\fIMtc\fP nach C
\(u:bersetzt: Der
Minilax-\(U:bersetzer aus dem \(U:bersetzerbaupraktikum, die komplette Bibliothek
\%\fIReuse\fP, die Standardbibliothek des \(U:bersetzers \%MOCKA sowie ein
mit dem Zerteilergenerator \%PGS [Klein\|86] erzeugter Zerteiler,
der starken Gebrauch
vom Zugriff auf lokale Variablen von statisch umfassenden Prozeduren macht und
daher als Testfall ausgew\(a:hlt wurde.
Insgesamt wurden vom Verfasser dieser Diplomarbeit Modula-Programme mit einem
Gesamtumfang von etwa 80000 Zeilen erfolgreich nach C \(u:bertragen.
.sp 0.4v
.ne 2v
.ti +2n
Vom Betreuer dieser Diplomarbeit Dr. J. Grosch wurden au\(sserdem
w\(a:hrend der Anfertigung dieser schriftlichen Ausarbeitung
die \(U:bersetzerbauwerkzeuge \%\fIRex\fP, \%\fILalr\fP und \%\fIEll\fP
erfolgreich nach C \(u:bertragen.
Diese Programme haben einen Umfang von etwa 35000 Zeilen \%Mo\%du\%la-Code.
.sp 0.4v
.ne 2v
.ti +2n
Die erzeugten C-Programme wurden bisher an den folgenden Maschinen getestet:
PCS- und SUN-Workstations (MC68020-Prozessor), DEC VAX 8530 und
DEC 3100 (MIPS-Prozessor) und sind daher als gut portabel anzusehen.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Gr\(o:\(sse, Laufzeit und Speicherbedarf des \(U:bersetzers\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Gr\(o:\(sse, Laufzeit und Speicherbedarf des \(U:bersetzers
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
S\(a:mtliche Messungen in diesem und den folgenden Abschnitten wurden an einer
SUN-Workstation (MC68020-Prozessor, 20 MHZ Taktfrequenz) durchgef\(u:hrt. Alle
Angaben f\(u:r den \(U:bersetzer \%\fIMtc\fP beziehen sich auf die
Modula-Version des \(U:bersetzers.
.sp 0.4v
.ne 2v
.ti +2n
Die Gr\(o:\(sse des ausf\(u:hrbaren Objektprogramms von \%\fIMtc\fP, gemessen
mit dem \fIsize\fP\^-Kommando [UNIX\|79], kann Tabelle \n(h1.1 entnommen
werden.
.sp 1.5
.zA
.TS
delim($$)tab(|) center allbox;
c c c c
n n n n.
Text|Data|Bss|Summe
294912|8192|6344|309448
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.1\fP: Gr\(o:\(sse des Objektprogramms von \%\fIMtc\fP in Byte
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.2 enth\(a:lt Laufzeit und Leistung von \%\fIMtc\fP f\(u:r die
\(U:bersetzung des Modula-\(U:bersetzers \%MOCKA, der aus 35 Moduln besteht, die
insgesamt 37792 Zeilen Modula-Code umfassen. Die Laufzeit wurde gemessen mit dem
\fItime\fP\^-Kommando [UNIX\|79] und ist die Summe aus
User- und System-Zeit.
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
c| c| c s
c| c| c| c
c| n| n| n.
Messung|Laufzeit|Leistung
|[s]|[Zeilen/s]|[Grundsymbole/s]
_
A|303|125|496
_
B|255|148|589
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.2\fP: Laufzeit und Leistung von \%\fIMtc\fP f\(u:r die
\(U:bersetzung von \%MOCKA
.ce 0
.zE
.sp 1.5
Bei der Messung A wurde jeder Definitions-, Implementierungs- und Programmodul
einzeln nach C \(u:bersetzt. Bei der Messung B wurde \%\fIMtc\fP nur f\(u:r
Implementierungs- und Programmoduln aufgerufen und bei jedem
\(U:bersetzungsvorgang mit Hilfe der in Kapitel 5.6 erw\(a:hnten Option die
Definitionsdateien aller transitiv importierten Definitionsmoduln
ausgegeben. Die Laufzeit (Messung A) verteilt sich folgenderma\(ssen auf die
einzelnen \(U:bersetzerphasen:
.sp 0.4v
.TS
delim($$)tab(|) center;
l r.
\fIParse\fP|19\^%
\fIGetDefinitionModules\fP|29\^%
\fIEval\fP|31\^%
\fIDoCode\fP|21\^%
.TE
.sp 0.4v
Dabei ist noch erw\(a:hnenswert, da\(ss \(em neben dem Aufruf des
Sym\%bol\%ent\%schl\(u:ss\%lers \(em
die mit Abstand aufwendigste
Einzeloperation,
die Operation \%\fIIdentify\fP f\(u:r
die Bezeichneridentifikation ist, die ca. 10\-20\|% der gesamten
\(U:bersetzungszeit beansprucht.
.sp 0.4v
.ne 2v
.ti +2n
Im Vergleich zu \%\fIMtc\fP ist die Laufzeit bzw. Leistung von
\%MOCKA bei der
\(U:bersetzung von \%MOCKA 178 Sekunden bzw. 212 Zeilen pro Sekunde
und die Laufzeit bzw. Leistung
des C-\(U:bersetzers
f\(u:r die \(U:bersetzung der C-Version von
\%MOCKA (36665 Zeilen C-Code) 408 Sekunden bzw. 90 Zeilen pro Sekunde.
.sp 0.4v
.ne 2v
.ti +2n
Alle Leistungsangaben wurden berechnet aus: Gesamtumfang von
\%MOCKA geteilt durch die
\(U:bersetzungszeit. Dabei wird nicht ber\(u:cksichtigt, da\(ss
\%\fIMtc\fP bei jedem \(U:bersetzungsvorgang auch noch alle transitiv importierten
Definitionsmoduln einliest bzw., da\(ss der C-\(U:bersetzer
die Definitionsdateien dieser Definitionsmoduln in das
C-Quellprogramm einf\(u:gt.
.sp 0.4v
.ne 2v
.ti +2n
Ber\(u:cksichtigt man, da\(ss \%\fIMtc\fP im Gegensatz zu \%MOCKA bei jedem
\(U:bersetzungsvorgang alle transitiv importierten Definitionsmoduln von neuem
einliest und analysiert und da\(ss die Bezeichneridentifikation wegen der
Verwendung einer Attributgrammatik \(u:ber Listen erfolgt, dann ist die Leistung
von \%\fIMtc\fP auch im Vergleich mit \%MOCKA sehr gut.
Insbesondere scheint der Preis f\(u:r
eine Vereinfachung der Behandlung der getrennten \(U:bersetzung durchaus
vertretbar zu sein.
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.3 enth\(a:lt den Speicherbedarf von \%\fIMtc\fP (dynamisch
angeforderter Speicher) f\(u:r die \(U:bersetzung der gr\(o:\(ssten
vorhandenen \(U:bersetzungseinheit,
dem Implementierungsmodul des Codegenerators von
\%\fIMtc\fP, der 7448 Zeilen Modula-Code umfa\(sst. Bei der \(U:bersetzung dieses
Moduls werden zus\(a:tzlich noch 18
Definitionsmoduln mit einem Gesamtumfang von 1992 Zeilen eingelesen.
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
c| c
l| n.
Zweck|Dynamischer Speicherbedarf
_
Baum und Attribute|2243
Definitionstabelle|328
Vorbereitung der Codeerzeugung|4751
Gesamter Speicherbedarf|7484
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.3\fP: Dynamischer Speicherbedarf von \%\fIMtc\fP
f\(u:r die \(U:bersetzung des Codegenerators von \%\fIMtc\fP in Kilobyte
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Der Speicherbedarf ist mit 793 Kilobyte pro 1000 Zeilen Quellcode
relativ hoch. Der
gr\(o:\(sste Anteil entf\(a:llt allerdings auf den Codegenerator. Ohne die in Kapitel
5.6.2
besprochene automatische Nachoptimierung w\(u:rde dieser 9155 Kilobyte Speicher
ben\(o:tigen. Bei der Angabe des Speicherbedarfs f\(u:r Baum und Attribute ist zu
ber\(u:cksichtigen, da\(ss der von \%\fIAg\fP erzeugte Attributauswerter
zur Zeit keine
Optimierung der Attributspeicherung enth\(a:lt und
daher s\(a:mtliche Attribute im Baum
gespeichert werden. Da\(ss der Speicherbedarf sich trotzdem in vertretbaren
Grenzen h\(a:lt, liegt im wesentlichen daran, da\(ss die meisten Attribute als
abstrakte Datentypen
in der Zielsprache realisiert werden und im Baum nur jeweils Zeiger auf die
eigentlichen Attributwerte gespeichert werden.
Eine entsprechende Optimierung der Attributspeicherung durch \%\fIAg\fP und eine
bessere Darstellung der in den Knoten des Strukturbaums
bei der Vorbereitung der Codeerzeugung abgelegten
Informationen durch \%\fIEstra\fP w\(u:rde den Speicherbedarf des
\(U:bersetzers deutlich reduzieren.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Qualit\(a:t des erzeugten C-Codes\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Qualit\(a:t des erzeugten C-Codes
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r eine Bewertung der Qualit\(a:t des von \%\fIMtc\fP erzeugten C-Codes wurden
die Modula- und die C-Version von \%MOCKA miteinander verglichen.
Um eine Verf\(a:lschung der Me\(ssergebnisse zu vermeiden, wurde die Modula-Version
von \%MOCKA ohne Laufzeitpr\(u:fungen \(u:bersetzt, d.h. auch die Modula-Version
enth\(a:lt \(em wie die C-Version \(em keine \(U:berpr\(u:fung von Bereichs- und
Feldgrenzen.
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.4 enth\(a:lt die Gr\(o:\(sse der ausf\(u:hrbaren Objektprogramme der
beiden MOCKA-Versionen.
.sp 1.5
.zA
.TS
delim($$)tab(|) center allbox;
c c c c c
l n n n n.
MOCKA-Version|Text|Data|Bss|Summe
Modula-2|385024|8192|62680|455896
C|327680|32768|66288|426736
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.4\fP: Gr\(o:\(sse der beiden \%MOCKA-Versionen in Byte
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Tabelle \n(h1.5 enth\(a:lt Laufzeit und Leistung der beiden Versionen f\(u:r die
\(U:bersetzung von \%MOCKA (37792 Zeilen Modula-Code).
.sp 1.5
.zA
.TS
delim($$)tab(|) center box;
c| c| c s
c| c| c| c
l| n| n| n.
MOCKA-Version|Laufzeit|Leistung
|[s]|[Zeilen/s]|[Grundsymbole/s]
_
Modula-2|178|212|844
_
C|165|229|910
.TE
.sp 0.4v
.ce 9999
\&\fBTabelle \n(h1.5\fP: Laufzeit und Leistung der MOCKA-Versionen f\(u:r die
\(U:bersetzung von \%MOCKA
.ce 0
.zE
.sp 1.5
.sp 0.4v
.ne 2v
.ti +2n
Wie den beiden Tabellen entnommen werden kann, ist die C-Version von
\%MOCKA sowohl kleiner als auch schneller wie die Modula-Version.
.sp 0.4v
.ne 2v
.ti +2n
Eine leicht durchf\(u:hrbare M\(o:glichkeit f\(u:r eine Nachoptimierung der erzeugten
C-Programme auf Quellsprachebene, die in \%Modula-2 nicht vorhanden ist,
ist die M\(o:glichkeit in C bestimmte Variablen in der Speicherklasse
\%\fIregister\fP (s. Kap. 3.2) zu
deklarieren. Mit einigen wenigen solcher Deklarationen f\(u:r h\(a:ufig
benutzte Variablen kann u.U. noch eine deutliche Leistungssteigerung
der C-Programme erreicht werden.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Implementierung eines Makefile-Generators\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Implementierung eines Makefile-Generators
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Mit Hilfe der Werkzeuge \%\fIRex\fP und \%\fIEll\fP und des Interpreters f\(u:r
eine Sprache zur Textmusterverarbeitung \%\fIawk\fP [UNIX\|79] wurde der
Makefile-Generator \%\fImakemake\fP implementiert, der aus den Quellen eines
Modulaprogramms durch Analyse der Importanweisungen eine Beschreibung der
Abh\(a:ngigkeiten zwischen den nach C \(u:bersetzten Quellen erzeugt,
wie sie vom UNIX-Kommando \%\fImake\fP [UNIX\|79] verarbeitet werden kann.
Diese Beschreibung enth\(a:lt au\(sserdem Kommandos, die folgende Schritte
veranlassen:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\(U:bersetzung der Modula-Quellen durch \%\fIMtc\fP nach C.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&\(U:bersetzung der erzeugten C-Quellen durch den C-\(U:bersetzer in
Objektprogramme.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Binden der Objektprogramme zu einem ausf\(u:hrbaren Programm.
.in -4n
.sp 0.1vv
.sp 0.3vv
Durch einen Aufruf von \%\fImake\fP, welches die obige Beschreibungsdatei
(Makefile) als
Eingabe erh\(a:lt, werden die Kommandos in der richtigen
Reihenfolge ausgef\(u:hrt und eine ausf\(u:hrbare C-Version des jeweiligen
Modula-Programms erzeugt.
.sp 0.4v
.ne 2v
.ti +2n
Das Programm f\(u:r den Interpreter \%\fIawk\fP konnte aus einem \(a:hnlichen
Makefile-Generator, der f\(u:r eine alte Version des Modula-\(U:bersetzers
\%MOCKA ohne automatische Nach\(u:bersetzung implementiert worden war,
\(u:bernommen und entsprechend angepa\(sst werden.
.sp 0.4v
.ne 2v
.ti +2n
Der Makefile-Generator war f\(u:r die Testphase und die ersten praktischen
Eins\(a:tze von \%\fIMtc\fP eine wichtige Hilfe, da z.B. f\(u:r die Erzeugung der
C-Version von \%MOCKA ca. 150 Aufrufe von \%\fIMtc\fP und des C-\(U:bersetzers
mit einer Vielzahl von Optionen und Parametern notwendig sind, die au\(sserdem
noch in
der richtigen Reihenfolge erfolgen m\(u:ssen. Durch die automatisch erzeugte
Beschreibungsdatei reduziert sich dieser Aufwand auf einen Aufruf des Kommandos
\%\fImake\fP.
.sp 0.4v
.ne 2v
.ti +2n
Die Beschreibungdatei enth\(a:lt \(u:brigens auch gen\(u:gend
Abh\(a:ngigkeitsinformationen f\(u:r eine Verwaltung der C-Quellen: Bei einer
Modifikation einer oder mehrerer C-Quellen werden durch einen Aufruf von
\%\fImake\fP alle abh\(a:ngigen C-Programme nach\(u:bersetzt.
Die Beschreibung reicht allerdings nicht aus, um bei einer Modifikation der
Modula-Quellen eine vollst\(a:ndige Nach\(u:bersetzung nach C zu veranlassen, da
f\(u:r eine Vereinfachung der Beschreibung in dieser nur vermerkt ist, da\(ss
\%\fIM.c\fP von \%\fIM.mi\fP und \%\fIM.h\fP von \%\fIM.md\fP abh\(a:ngt.
Es w\(a:re allerdings \(em wenn dies ben\(o:tigt werden sollte \(em nicht besonders
aufwendig, \%\fImakemake\fP so zu erweitern, da\(ss auch die Abh\(a:ngigkeit einer
\(U:bersetzungseinheit von allen transitiv importierten
(De\%fi\%ni\%ti\%ons-)Mo\%duln beschrieben wird.
.hA 2 2v 1v
\fB\n(h1.\n(h2
.hB \w'\n(h1.\n(h2'u
\&Bewertung der \(U:bersetzerbauwerkzeuge\fP
.hC 1v 0n 0v 4n 0v
\&\n(h1.\n(h2\ 
.hD 5n
\&Bewertung der \(U:bersetzerbauwerkzeuge
.hE 4n 5n 0v
.sp 0.4v
.ne 2v
.ti +2n
Dieser Abschnitt enth\(a:lt einige spezielle Anmerkungen zu den
\(U:bersetzerbauwerkzeugen sowie eine Reihe von Verbesserungsw\(u:nschen und
-vorschl\(a:gen.
.sp 0.4v
.ne 2v
.ti +2n
\%\fIRex\fP und \%\fIEll\fP erm\(o:glichen es, in k\(u:rzester Zeit einen
Sym\%bol\%ent\%schl\(u:ss\%ler bzw. einen Zerteiler mit automatischer Fehlerbehandlung
aus einer knappen und leicht verst\(a:ndlichen formalen Spezifikation zu
erstellen. Ein wichtiges Merkmal der erzeugten \(U:bersetzerteile f\(u:r den
praktischen Einsatz ist ihre hohe Laufzeiteffizienz.
.sp 0.4v
.ne 2v
.ti +2n
Auch der Einsatz von \%\fIAst\fP ist eine enorme Arbeitserleichterung f\(u:r den
\(U:bersetzerbauer: Aus einer sehr kurzen formalen Spezifikation der abstrakten
Syntax (vgl. Anh. A) kann ein zwar relativ leicht ,,von Hand''
programmierbarer aber
umfangreicher Modul f\(u:r die Implementierung des Strukturbaums erzeugt werden.
.sp 0.4v
.ne 2v
.ti +2n
Ein interessanter Aspekt in diesem Zusammenhang w\(a:re, ob
aus einer eventuell gemeinsamen Spezifikation des Zerteilers und der
abstrakten Syntax nicht auch die semantischen Aktionen f\(u:r den Baumaufbau
automatisch erzeugt werden
k\(o:nnten, die bei der erstellten Zerteilerspezifikation den meisten
Aufwand erforderten.
.sp 0.4v
.ne 2v
.ti +2n
Insgesamt nahm die Implementierung der ersten beiden Phasen von \%\fIMtc\fP
(lexikalische und syntaktische Analyse, Baumaufbau und Behandlung der
getrennten \(U:bersetzung) weniger als 1/7 der gesamten Implementierungszeit in
Anspruch.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Ag\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Ag
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die zur Zeit vorliegende Version von \%\fIAg\fP ist ein noch in der Entwicklung
befindlicher Prototyp.
.sp 0.4v
.ne 2v
.ti +2n
Die aus der Sicht des Verfassers wichtigste Verbesserung der
Spezifikationssprache w\(a:re, eine M\(o:glichkeit
innerhalb der Attributierungsregeln
auf Attribute von Vorg\(a:ngerknoten im Strukturbaum zugreifen
zu k\(o:nnen (analog \%INCLUDING des GAG-Systems [Kastens\|82]).
Durch eine solche M\(o:glichkeit k\(o:nnte die Attributgrammatik deutlich
verkleinert werden und eine nicht unerhebliche Anzahl von Attributen und
Attributberechnungen, die nur
f\(u:r Attributtransfers ben\(o:tigt werden, k\(o:nnte entfallen.
.sp 0.4v
.ne 2v
.ti +2n
W\(a:hrend der Entwicklung der Attributgrammatik trat h\(a:ufig das Problem auf,
da\(ss diese nicht mehr der Klasse \%OAG angeh\(o:rte. In diesem Fall war es
notwendig, geeignete k\(u:nstliche
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten einzuf\(u:hren, die
wieder die Eigenschaft \%OAG erzwangen. Da auf der einen Seite die von
\%\fIAg\fP ausgedruckten Informationen \(u:ber die
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten sehr
umfangreich sind und au\(sserdem die Eigenschaft \%OAG nicht besonders leicht
nachvollziehbar ist, war es jedesmal nicht ganz einfach, geeignete k\(u:nstliche
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten
zu finden. Es w\(a:re daher w\(u:nschenswert, wenn
\%\fIAg\fP \(em \(a:hnlich wie das GAG-System \(em in der Lage w\(a:re, diese
k\(u:nstlichen
Abh\(a:ngigkeiten zur Erzielung der OAG-Eigenschaft ohne Einwirkung des Benutzers
automatisch einzuf\(u:hren.
.sp 0.4v
.ne 2v
.ti +2n
F\(u:r eine formale Spezifikation der statischen Semantik einer Sprache im Rahmen
der Sprachdefinition ist eine volle Funktionalit\(a:t der Attributgrammatik
sicher unerl\(a:\(sslich. F\(u:r eine praktische Implementierung der semantischen
Analyse, die hinsichtlich Laufzeit und Speicherbedarf des Attributauswerters
m\(o:glichst effizient sein soll, ist der kontrollierte Einsatz von
Seiteneffekten manchmal nahezu unerl\(a:\(sslich. Au\(sserdem lassen sich zyklische
Abh\(a:ngigkeiten innerhalb von Objekt- und Typbeschreibungen, wie sie in den
meisten in der Praxis verwendeten Sprachen einfach auftreten, durch einen
schrittweisen Aufbau dieser Beschreibungen noch am einfachsten aufl\(o:sen. Ein
Problem, welches durch den Einsatz von kontrollierten Seiteneffekten nat\(u:rlich
hinzukommt ist, da\(ss man sich in diesem Zusammenhang Gedanken \(u:ber die
Reihenfolge der Seiteneffekte machen und diese Reihenfolge eventuell durch
die Einf\(u:hrung von geeigneten Attributen bzw.
At\%tri\%but\%ab\%h\(a:n\%gig\%kei\%ten
erzwingen mu\(ss.
.sp 0.4v
.ne 2v
.ti +2n
Durch den Einsatz von in \%Modula-2 implementierten abstrakten Datentypen,
durch kontrollierte Seiteneffekte und durch die von \%\fIAg\fP verwendete
direkte Implementierung der Besuchssequenzen mit rekursiven Prozeduren ist es
gelungen, einen Attributauswerter aus einer Attributgrammatik zu erzeugen, der
insbesondere im Hinblick auf Laufzeiteffizienz mit ,,von Hand'' implementierten
\(U:bersetzern wie \%MOCKA durchaus mithalten kann.
.sp 0.4v
.ne 2v
.ti +2n
Die Entwicklung einer Attributgrammatik f\(u:r die semantische Analyse ist eine
relativ komplexe und aufwendige Aufgabe und der Teil der Arbeit, der
dabei von einem Generator wie \%\fIAg\fP \(u:bernommen werden kann, ist im
Vergleich
z.B. zur Arbeitserleichterung bei der automatischen Erzeugung eines Zerteilers
aus einer kontextfreien Grammatik relativ klein. Die f\(u:r die semantische
Analyse von \%\fIMtc\fP entwickelte Attributgrammatik ist sicher nur ein erster
Ansatz im Hinblick auf Kombination von abstrakten Datentypen und
Attributgrammatiken einschlie\(sslich dem Einsatz von kontrollierten
Seiteneffekten und k\(o:nnte in mancherlei Hinsicht verbessert werden. Die
Entwicklung einer kompletten Attributgrammatik f\(u:r die semantische Analyse von
Modula-2, die sowohl Forderungen hinsichtlich Lesbarkeit,
Verst\(a:ndlichkeit und Vollst\(a:ndigkeit als auch hinsichtlich Effizienz des
daraus erzeugten Attributauswerters erf\(u:llt, ist sicher ein interessantes
Forschungs- und/oder Diplomarbeitsthema.
.sp 0.4v
.ne 2v
.ti +2n
Eine letzte Bemerkung zu \%\fIAg\fP gilt der Speicherung der Attributwerte. In
der bisherigen Version von \%\fIAg\fP werden s\(a:mtliche Attribute im Baum
gespeichert. Wie die Messungen in Kapitel \n(h1.2
zeigen ist dies \(em im Gegensatz zu anderslautenden
Feststellungen in der Literatur \(em heute aufgrund der gewachsenen
Hauptspeichergr\(o:\(ssen durchaus m\(o:glich. Allerdings sollten dabei die folgenden
Punkte ber\(u:cksichtigt werden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der \(U:bersetzer \%\fIMtc\fP
enth\(a:lt keine vollst\(a:ndige semantische Analyse. Eine
solche vollst\(a:ndige semantische Analyse w\(u:rde zu einer h\(o:heren
Anzahl von Attributen und damit zu einem h\(o:heren Attributspeicherbedarf
f\(u:hren.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Bei der Implementierung wurde wegen der fehlenden Speicheroptimierung
stark auf den Speicherbedarf der Attributwerte geachtet und f\(u:r die
Attributtypen wann immer m\(o:glich Typen der Zielsprache mit m\(o:glichst geringem
Speicherbedarf verwendet.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Durch den Einsatz von
in der Zielsprache implementierten abstrakten Datentypen, die mit Hilfe von
Zeigertypen realisiert wurden, wird erreicht, da\(ss die meisten
im Baum gespeicherten Attribute nur Zeiger auf die eigentlichen Attributwerte
(Objekt- und Typbeschreibungen, Umgebungsattribute, usf.)
sind.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Somit wurde ein wesentlicher
Teil der Optimierung des Attributspeicherbedarfs bereits ,,von Hand''
vorweggenommen.
Es ist daher fraglich, ob es nicht doch sinnvoll w\(a:re
trotz der heutigen Hauptspeichergr\(o:\(ssen,
eine Optimierung der Attributspeicherung in \%\fIAg\fP einzubauen.
Eine solche eventuelle Optimierung wurde in der Attributgrammatik
bereits vorbereitet, indem alle Attribute, die noch in der Codeerzeugung
ben\(o:tigt werden, als ,,output'' Attribute [Grosch\|89a]
gekennzeichnet wurden.
.hA 3 2v 1v
\fB\n(h1.\n(h2.\n(h3
.hB \w'\n(h1.\n(h2.\n(h3'u
\&Estra\fP
.hC 1v 0n 0v (4n+5n) 0v
\&\n(h1.\n(h2.\n(h3\ 
.hD 7n
\&Estra
.hE (4n+5n) 7n 0v
.sp 0.4v
.ne 2v
.ti +2n
Die Erfahrungen des Verfassers bei diesem Einsatz von \%\fIEstra\fP sind sehr
positiv. Der \(U:bergang von einer direkten Implementierung zu
einer Spezifikation des Codegenerators mit \%\fIEstra\fP hat eine Reihe von
Vorteilen.
Der Benutzer wird durch die Spezifikation von
implementierungstechnischen Details wie der Traversierung des Baums entlastet.
Die Auswahl bestimmter Transformationsvorschriften durch den Codegenerator kann
auf einem h\(o:heren Abstraktionsniveau mit Mustern, Bedingungen und Kosten
beschrieben werden. Au\(sserdem werden die Zugriffe auf in den Mustern
vorkommende Teilb\(a:ume und deren Attribute von \%\fIEstra\fP unterst\(u:tzt und
vereinfacht. Insgesamt ergibt sich eine bessere Lesbarkeit und
Verst\(a:ndlichkeit der Codeerzeugung aufgrund des h\(o:heren Abstraktionsniveaus
der Spezifikation. Au\(sserdem wird eine leichtere \(A:nderbarkeit und Wartbarkeit
des Codegenerators erreicht.
.sp 0.4v
.ne 2v
.ti +2n
Die Laufzeiteffizienz des erzeugten Codegenerators ist, wie die Messungen aus
Kapitel \n(h1.2 zeigen, ebenfalls gut. Allerdings f\(a:llt der Codegenerator
mit insgesamt 7571 Zeilen recht gro\(ss aus. Hier w\(a:re vielleicht eine M\(o:glichkeit
zur Modularisierung sowohl der Spezifikation als auch der daraus erzeugten
Implementierung angebracht.
.sp 0.4v
.ne 2v
.ti +2n
Hauptkritikpunkt an \%\fIEstra\fP ist der bereits in Kapitel 5.6.2
erw\(a:hnte und in den Messungen in Kapitel \n(h1.2 noch einmal deutlich
dokumentierte extrem hohe Speicherbedarf des von \%\fIEstra\fP erzeugten
Codegenerators. Dieser Speicherbedarf resultiert daraus, da\(ss \%\fIEstra\fP bei
der Vorbereitung der Transformation f\(u:r jeden Knoten des Strukturbaums einen
Informationsblock anlegt, der f\(u:r jede Funktion der Spezifikation die auf
diesen Knoten anwendbare Vorschrift und die Kosten dieser Anwendung enth\(a:lt
(vgl. Kap. 5.6.2). Es mu\(ss aber bereits in der Spezifikation f\(u:r jede
Funktion angegeben werden, auf welche Knotentypen diese Funktion anwendbar ist.
Betrachtet man die Spezifikation des Codegenerators von \%\fIMtc\fP, die 22
Funktionen umfa\(sst, dann stellt man fest, da\(ss im Mittel nur ca. 2 der 22
Funktionen auf jeden Knotentyp anwendbar sind. Das bedeutet aber, da\(ss
\(u:ber 90\|% des
dynamisch angeforderten Speichers v\(o:llig umsonst
angefordert werden, da dort nur die bereits aus der Spezifikation bekannte
Tatsache festgehalten wird, da\(ss die meisten Funktionen auf den jeweiligen
Knoten des Strukturbaums \(u:berhaupt nicht anwendbar sind. W\(u:rde \%\fIEstra\fP
f\(u:r jeden Knoten nur einen Informationsblock anlegen, der Informationen \(u:ber
die auf diesen Knoten anwendbaren
Funktionen enth\(a:lt, k\(o:nnte der
Speicherbedarf des Codegenerators auf unter 1/10 reduziert werden.
.hA 1 3v 1v
\fB\n(h1.
.hB \w'\n(h1.'u
\&Zusammenfassung und Ausblick\fP
.hC 1v 0n 0.3v 0 0.1v
\&\n(h1.\ 
.hD 4n
\&Zusammenfassung und Ausblick
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Zentraler Teil dieser Diplomarbeit bildet die Definition einer
vollst\(a:ndigen Abbildung von \%Modula-2 nach C. Insbesondere wurde auch
gezeigt wie statisch geschachtelte Prozedurdeklarationen und das Modulkonzept
von \%Modula-2 nach C abgebildet werden k\(o:nnen. \%Modula-2
besitzt zwar ein deutlich h\(o:heres Abstraktionsniveau, aber durch eine
Kombination von primitiveren C-Konstrukten k\(o:nnen auch in C nicht direkt
vorhandene Modula-Konstrukte realisiert werden. Einzige Ausnahme hierbei bilden die
Koroutinen f\(u:r deren Abbildung kein geeignetes C-Konstrukt existiert.
.sp 0.4v
.ne 2v
.ti +2n
Im Rahmen dieser Diplomarbeit wurde ebenfalls der \(U:bersetzer \%\fIMtc\fP
entwickelt, der die oben beschriebene Abbildung implementiert und
die Modula-Programme in lesbaren C-Code umsetzt. Etwa 3/4 des Quellcodes von
\%\fIMtc\fP besteht aus Moduln, die mit den an der GMD Forschungsstelle
Karlsruhe entwickelten \(U:bersetzerbauwerkzeugen \%\fIRex\fP, \%\fIEll\fP,
\%\fIAst\fP, \%\fIAg\fP und \%\fIEstra\fP aus Spezifikationen erzeugt wurden.
Da \%\fIMtc\fP nicht f\(u:r die Programmentwicklung, sondern f\(u:r die \(U:bertragung
von fertig entwickelten Modula-Programmen nach C gedacht ist, wird die
semantische Korrektheit der Eingabeprogramme nicht \(u:berpr\(u:ft.
Die \(U:bersetzungsleistung von \%\fIMtc\fP ist mit ca. 150 Zeilen in der Sekunde
an einer SUN-Workstation (MC68020-Prozessor) sehr gut;
allerdings ist der Speicherbedarf
mit bis zu 800 Kilobyte je 1000 Zeilen Quellprogramm relativ hoch.
.sp 0.4v
.ne 2v
.ti +2n
Da an der GMD Forschungsstelle Karlsruhe \%Modula-2 seit mehreren Jahren
f\(u:r die Pro\%gramm\%ent\%wick\%lung eingesetzt wird, bestand an geeigneten
Testprogrammen f\(u:r \%\fIMtc\fP kein Mangel und anf\(a:nglich noch
vorhandene Schw\(a:chen der Abbildung konnten schnell aufgedeckt und beseitigt
werden.
Bisher wurden u.a. folgende Programme mit \%\fIMtc\fP erfolgreich nach C
\(u:bertragen: der \(U:bersetzer \%\fIMtc\fP selbst, der Modula-\(U:bersetzer
\%MOCKA sowie die \(U:bersetzerbauwerkzeuge \%\fIRex\fP, \%\fIEll\fP und
\%\fILalr\fP.
Wie erste Messungen zeigen ist die Qualit\(a:t des erzeugten C-Codes
ebenfalls gut: Die erzeugten C-Programme sind kleiner und schneller als
die urspr\(u:nglichen Modula-Programme.
.sp 0.4v
.ne 2v
.ti +2n
Erste Benutzerw\(u:nsche legen den Schlu\(ss nahe, da\(ss die in Kapitel 4.2.4
begr\(u:ndete Entscheidung, Kommentare nicht von \%Modula-2 nach C zu
\(u:bersetzen, doch noch einmal \(u:berdacht werden sollte. Durch eine
Ber\(u:cksichtigung von ,,typischen'' Konventionen, die f\(u:r die Kommentierung in
der Regel unbewu\(sst eingehalten werden, w\(a:re es vielleicht m\(o:glich, eine
L\(o:sung zu implementieren, die die Kommentare wenigstens in den meisten F\(a:llen
im C-Programm richtig plaziert und nur in wenigen F\(a:llen eine manuelle
Verschiebung durch den Benutzer erfordert. Allerdings sollte aus diesem Grund
die \(U:bersetzung der Kommentare optional sein und nur auf ausdr\(u:cklichen
Wunsch des Benutzers stattfinden.
.sp 0.4v
.ne 2v
.ti +2n
Die Implementierung von \%\fIMtc\fP lie\(sse sich sicher noch in mancher Hinsicht
verbessern. Wichtigster Punkt w\(a:re eine Reduktion des in Kapitel 6.2
dokumentierten hohen Speicherbedarfs von \%\fIMtc\fP.
Eine bessere Darstellung der in den Knoten des Strukturbaums
bei der Vorbereitung der Codeerzeugung abgelegten
Informationen durch \%\fIEstra\fP
und eine Optimierung der Attributspeicherung durch \%\fIAg\fP
w\(u:rde den Speicherbedarf des \(U:bersetzers deutlich reduzieren.
.sp 0.4v
.ne 2v
.ti +2n
Ein weiterer Punkt w\(a:re eine interpretative Auswertung
von konstanten Ausdr\(u:cken, die es
auch erm\(o:glicht, \(U:berl\(a:ufe zu erkennen und konstante Ausdr\(u:cke mit
Operanden im Bereich
\%MAX\^(INTEGER)\|+\|1\|..\|\%MAX\^(CARDINAL)
auswerten zu k\(o:nnen.
.sp 0.4v
.ne 2v
.ti +2n
Der hohe Aufwand f\(u:r die Bezeichneridentifikation, der auf eine Implementierung
der Umgebungsattribute mit Listen zur\(u:ckzuf\(u:hren ist (f\(u:r gro\(sse Programme
ca. 20\|% der gesamten \(U:bersetzungszeit), k\(o:nnte m\(o:glicherweise durch eine
Implementierung der Umgebungsattribute mit Hilfe von Suchb\(a:umen reduziert
werden.
.sp 0.4v
.ne 2v
.ti +2n
Die \(U:bersetzerbauwerkzeuge \%\fIRex\fP, \%\fIEll\fP und \%\fIAst\fP sind
weitgehend ausgereift und eignen sich wegen der enormen Arbeitserleichterung
f\(u:r den \(U:bersetzerbauer, aber auch wegen der hohen Laufzeiteffizienz der
erzeugten \(U:bersetzerteile, f\(u:r einen Einsatz auch in der Konstruktion von
\(U:bersetzern mit Produktionsqualit\(a:t.
.sp 0.4v
.ne 2v
.ti +2n
Die Prototypen \%\fIAg\fP und \%\fIEstra\fP bieten erste interessante Ans\(a:tze
f\(u:r eine Spezifikation der semantischen Analyse und der
(Zwischen-)Codeerzeugung, insbesondere sind die erzeugten \(U:bersetzerteile sehr
laufzeiteffizient. Allerdings besteht nach Ansicht des Verfassers dieser Diplomarbeit noch
ein Entwicklungsbedarf sowohl hinsichtlich Ausdruckskraft der Spezifikationen
als auch hinsichtlich des Speicherbedarfs der erzeugten \(U:bersetzerteile bevor
ein Einsatz dieser Werkzeuge auch au\(sserhalb von Forschungsprojekten m\(o:glich
ist.
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ A: Abstrakte Syntax von Modula-2\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ A: Abstrakte Syntax von Modula-2
.hE 0 4n 0.1v
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
TREE
.sp 0.4v
IMPORT  {
FROM StringMem  IMPORT tStringRef;
FROM Idents     IMPORT tIdent;
FROM Errors     IMPORT tPosition;
}
.sp 0.4v
EXPORT  {
CONST
  Definition            =  1;           (* compilation unit kind        *) 
  Foreign               =  2;
  Implementation        =  3;
  Program               =  4;
.sp 0.4v
  NotEqual              =  1;           (* operators                    *)
  Times                 =  2;
  Plus                  =  3;
  Minus                 =  4;
  Divide                =  5;
  Less                  =  6;
  LessEqual             =  7;
  Equal                 =  8;
  Greater               =  9;
  GreaterEqual          = 10;
  And                   = 11;
  Div                   = 12;
  In                    = 13;
  Mod                   = 14;
  Not                   = 15;
  Or                    = 16;
.sp 0.4v
  Decimal               =  1;           (* integer constant kind        *)
  Octal                 =  2;
  Hexadecimal           =  3;
}
.sp 0.4v
GLOBAL  {
FROM StringMem  IMPORT tStringRef;
FROM Idents     IMPORT tIdent;
FROM Errors     IMPORT tPosition;
}
.sp 0.4v
RULE
.sp 0.4v
ROOT            = CompUnits .
.sp 0.4v
CompUnits       = <
  CompUnits0    = .
  CompUnit      = [Kind: SHORTCARD] [Ident: tIdent] [Pos: tPosition]
                  Next: CompUnits REVERSE <
    DefMod      = Import Decls .
    ProgMod     = Import Decls Stmts .
  >.
>.
.sp 0.4v
Import          = <
  Import0       = .
  Import1       = Next: Import REVERSE <
    From        = [Ident: tIdent] [Pos: tPosition] ImpIds .
    Objects     = ImpIds .
  >.
>.
.sp 0.4v
ImpIds          = <
  ImpIds0       = .
  ImpIds1       = [Ident: tIdent] [Pos: tPosition] Next: ImpIds REVERSE .
>.
.sp 0.4v
Export          = <
  Export0       = .
  Export1       = [Qualified: BOOLEAN] ExpIds .
>.
.sp 0.4v
ExpIds          = <
  ExpIds0       = .
  ExpIds1       = [Ident: tIdent] Next: ExpIds REVERSE .
>.
.sp 0.4v
Decls           = <
  Decls0        = .
  Decl          = Next: Decls REVERSE <
    Var         = VarIds Type .
    Object      = [Ident: tIdent] <
      Const     = Expr .
      TypeDecl  = Type [Pos: tPosition] .
      Proc      = Formals ResultType: PrimaryType Decls Stmts .
      ProcHead  = Formals ResultType: PrimaryType [Pos: tPosition] .
      Module    = Import Export Decls Stmts .
      Opaque    = .
    >.
  >.
>.
.sp 0.4v
VarIds          = <
  VarIds0       = .
  VarIds1       = [Ident: tIdent] Next: VarIds REVERSE .
>.
.sp 0.4v
Formals         = <
  Formals0      = .
  Formals1      = [IsVAR: BOOLEAN] ParIds Type Next: Formals REVERSE .
>.
.sp 0.4v
ParIds          = <
  ParIds0       = .
  ParIds1       = [Ident: tIdent] Next: ParIds REVERSE .
>.
.sp 0.4v
Type            = <
  Array         = [IsOpen: BOOLEAN] IndexType: SimpleType ElemType: Type .
  Record        = Fields .
  SetType       = BaseType: SimpleType .
  Pointer       = TargetType: Type .
  ProcType      = FormalTypes ResultType: PrimaryType .
  SimpleType    = <
    Enumeration = EnumIds .
    Subrange    = BaseType: PrimaryType Lwb: Expr Upb: Expr .
    PrimaryType = <
      Void      = .
      TypeId    = [Ident: tIdent] [Pos: tPosition] <
        TypeId0 = .
        TypeId1 = TypeId .
      >.
    >.
  >.
>.
.sp 0.4v
Fields          = <
  Fields0       = .
  Fields1       = Next: Fields REVERSE <
    RecordSect  = FieldIds Type .
    VariantSect = TagField Variants Else: Fields.
  >.
>.
.sp 0.4v
FieldIds        = <
  FieldIds0     = .
  FieldIds1     = [Ident: tIdent] Next: FieldIds REVERSE .
>.
.sp 0.4v
TagField        = Type: TypeId <
  TagField0     = .
  TagField1     = [Ident: tIdent] .
>.
.sp 0.4v
Variants        = <
  Variants0     = .
  Variant       = Labels Variant: Fields Next: Variants REVERSE .
>.
.sp 0.4v
FormalTypes     = <
  FormalTypes0  = .
  FormalType    = [IsVAR: BOOLEAN] Type Next: FormalTypes REVERSE .
>.
.sp 0.4v
EnumIds         = <
  EnumIds0      = .
  EnumIds1      = [Ident: tIdent] Next: EnumIds REVERSE .
>.
.sp 0.4v
Expr            = <
  Binary        = [Operator: SHORTCARD] Lop: Expr Rop: Expr .
  Unary         = [Operator: SHORTCARD] Mop: Expr .
  IntConst      = [Kind: SHORTCARD] [IntVal: CARDINAL] [Pos: tPosition] .
  RealConst     = [RealVal: tStringRef] .
  StringConst   = [StringVal: tStringRef] .
  CharConst     = [CharVal: CHAR] .
  FuncCall      = Designator Actuals .
  Set           = BaseType: Qualid Elems .
  BitSet        = Elems .
  Designator    = [Pos: tPosition] <
    Qualid      = [Ident: tIdent] <
      Qualid0   = .
      Qualid1   = Qualid .
    >.
    Subscript   = Designator Index: Expr .
    Deref       = Designator .
    Select      = Designator [Field: tIdent] .
  >.
>.
.sp 0.4v
Elems           = <
  Elems0        = .
  Elems1        = Next: Elems REVERSE <
    Elem        = Elem: Expr .
    ElemRange   = Lwb: Expr Upb: Expr .
  >.
>.
.sp 0.4v
Actuals         = <
  Actuals0      = .
  Actual        = Expr Next: Actuals REVERSE .
>.
.sp 0.4v
Stmts           = <
  Stmts0        = .
  Stmt          = Next: Stmts REVERSE <
    Assign      = Designator Expr .
    Call        = Designator Actuals .
    If          = Cond: Expr Then: Stmts Elsifs Else: Stmts .
    Case        = Expr Cases Else: Stmts [Default: BOOLEAN] .
    While       = Cond: Expr Stmts .
    Repeat      = Stmts Cond: Expr .
    Loop        = Stmts .
    For         = Qualid From: Expr To: Expr By: Expr Stmts .
    With        = Designator Stmts .
    Exit        = .
    Return1     = .
    Return2     = Result: Expr .
  >.
>.
.sp 0.4v
Elsifs          = <
  Elsifs0       = .
  Elsifs1       = Cond: Expr Stmts Next: Elsifs REVERSE .
>.
.sp 0.4v
Cases           = <
  Cases0        = .
  Cases1        = Labels Stmts Next: Cases REVERSE .
>.
.sp 0.4v
Labels          = <
  Labels0       = .
  Labels1       = Next: Labels REVERSE <
    Label       = Label: Expr .
    LabelRange  = Lwb: Expr Upb: Expr .
  >.
>.
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ B: Beispiel f\(u:r den erzeugten C-Code\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ B: Beispiel f\(u:r den erzeugten C-Code
.hE 0 4n 0.1v
.nf
\&\f(TT
.nr gV \n(.vu
.vs \n(.vu*10u/12u
.nr gP \n(.s
.ps \n(.s*10u/12u
(*====== Modula-Programm ===============================================*)
.sp 0.4v
(*------ Tree.md -------------------------------------------------------*)
.sp 0.4v
DEFINITION MODULE Tree;
.sp 0.4v
CONST NoTree    = NIL;
.sp 0.4v
TYPE
  tTree         = POINTER TO tNode;
  tNode         = RECORD
                    Key         : INTEGER;
                    Count       : CARDINAL;
                    Left, Right : tTree;
                  END;
.sp 0.4v
  tProcOfNode   = PROCEDURE (INTEGER, CARDINAL);
.sp 0.4v
VAR Root        : tTree;
.sp 0.4v
PROCEDURE Insert        (x: INTEGER; VAR t: tTree);
PROCEDURE Delete        (x: INTEGER; VAR t: tTree);
PROCEDURE InOrder       (t: tTree; p: tProcOfNode);
.sp 0.4v
END Tree.
.sp 0.4v
(*------ Tree.mi -------------------------------------------------------*)
.sp 0.4v
IMPLEMENTATION MODULE Tree;
.sp 0.4v
FROM Storage    IMPORT ALLOCATE, DEALLOCATE;
.sp 0.4v
PROCEDURE Insert (x: INTEGER; VAR t: tTree);
BEGIN
  IF t = NoTree THEN
    NEW (t);
    WITH t^ DO
      Key := x; Count := 1;
      Left := NoTree; Right := NoTree;
    END;
  ELSIF x < t^.Key THEN Insert (x, t^.Left);
  ELSIF x > t^.Key THEN Insert (x, t^.Right);
  ELSE
    INC (t^.Count);
  END;
END Insert;
.sp 0.4v
PROCEDURE Delete (x: INTEGER; VAR t: tTree);
  VAR s : tTree;
.sp 0.4v
  PROCEDURE del (VAR t: tTree);
  BEGIN
    IF t^.Right # NoTree THEN
      del (t^.Right);
    ELSE
      s^.Key := t^.Key; s^.Count := t^.Count;
      s := t; t := t^.Left;
    END;
  END del;
.sp 0.4v
BEGIN
  IF t # NoTree THEN
    IF x < t^.Key THEN Delete (x, t^.Left);
    ELSIF x > t^.Key THEN Delete (x, t^.Right);
    ELSE
      s := t;
      IF s^.Right = NoTree THEN t := s^.Left;
      ELSIF s^.Left = NoTree THEN t := s^.Right;
      ELSE del (s^.Left);
      END;
      DISPOSE (s);
    END;
  END;
END Delete;
.sp 0.4v
PROCEDURE InOrder (t: tTree; p: tProcOfNode);
BEGIN
  IF t # NoTree THEN
    InOrder (t^.Left, p);
    p (t^.Key, t^.Count);
    InOrder (t^.Right, p);
  END;
END InOrder;
.sp 0.4v
BEGIN
  Root := NoTree;
END Tree.
.sp 0.4v
(*------ Main.mi -------------------------------------------------------*)
.sp 0.4v
MODULE Main;
.sp 0.4v
FROM StdIO      IMPORT ReadI, ReadNl, WriteI, WriteNl, CloseIO;
FROM Tree       IMPORT tTree, NoTree, Root, Insert, Delete, InOrder;
.sp 0.4v
CONST cMax = 4;
.sp 0.4v
VAR
  i : SHORTCARD;
  x : INTEGER;
  a : ARRAY [1..cMax] OF INTEGER;
.sp 0.4v
MODULE TestOutput;
.sp 0.4v
IMPORT WriteI; EXPORT WriteArray, WriteNode;
.sp 0.4v
  VAR i : CARDINAL;
.sp 0.4v
  PROCEDURE WriteArray (VAR a: ARRAY OF INTEGER);
  BEGIN
    FOR i := 0 TO HIGH (a) DO WriteI (a[i], 5); END;
  END WriteArray;
.sp 0.4v
  PROCEDURE WriteNode (Key: INTEGER; Count: CARDINAL);
  BEGIN
    FOR i := Count TO 1 BY -1 DO WriteI (Key, 5); END;
  END WriteNode;
.sp 0.4v
END TestOutput;
.sp 0.4v
BEGIN
  FOR i := 1 TO cMax DO a[i] := ReadI (); Insert (a[i], Root); END; ReadNl;
  WriteArray (a); WriteNl;
  REPEAT
    InOrder (Root, WriteNode); WriteNl;
    x := ReadI (); ReadNl;
    Delete (x, Root);
  UNTIL Root = NoTree;
  CloseIO;
END Main.
.sp 0.4v
.br
.ne 8
(*====== Von Mtc erzeugtes C-Programm ==================================*)
.sp 0.4v
/*------ Tree.h --------------------------------------------------------*/
.sp 0.4v
#define DEFINITION_Tree
.sp 0.4v
#define Tree_NoTree	NIL
typedef struct Tree_1 *Tree_tTree;
typedef struct Tree_1 {
    INTEGER Key;
    CARDINAL Count;
    Tree_tTree Left, Right;
} Tree_tNode;
typedef void (*Tree_tProcOfNode)();
extern Tree_tTree Tree_Root;
extern void Tree_Insert();
extern void Tree_Delete();
extern void Tree_InOrder();
extern void BEGIN_Tree();
.sp 0.4v
/*------ Tree.c --------------------------------------------------------*/
.sp 0.4v
#include "SYSTEM.h"
.sp 0.4v
#ifndef DEFINITION_Storage
#include "Storage.h"
#endif
.sp 0.4v
#ifndef DEFINITION_Tree
#include "Tree.h"
#endif
.sp 0.4v
Tree_tTree Tree_Root;
.sp 0.4v
static void del();
.sp 0.4v
static Tree_tTree *G_1_s;
.sp 0.4v
void
Tree_Insert(x, t)
INTEGER x;
Tree_tTree *t;
{
  if (*t == Tree_NoTree) {
    Storage_ALLOCATE(t, sizeof(Tree_tNode));
    {
      register Tree_tNode *W_1 = *t;
.sp 0.4v
      W_1->Key = x;
      W_1->Count = 1;
      W_1->Left = Tree_NoTree;
      W_1->Right = Tree_NoTree;
    }
  } else if (x < (*t)->Key) {
    Tree_Insert(x, &(*t)->Left);
  } else if (x > (*t)->Key) {
    Tree_Insert(x, &(*t)->Right);
  } else {
    INC((*t)->Count);
  }
}
.sp 0.4v
static void
del(t)
Tree_tTree *t;
{
  if ((*t)->Right != Tree_NoTree) {
    del(&(*t)->Right);
  } else {
    (*G_1_s)->Key = (*t)->Key;
    (*G_1_s)->Count = (*t)->Count;
    *G_1_s = *t;
    *t = (*t)->Left;
  }
}
.sp 0.4v
void
Tree_Delete(x, t)
INTEGER x;
Tree_tTree *t;
{
  Tree_tTree s;
  Tree_tTree *L_1;
.sp 0.4v
  L_1 = G_1_s;
  G_1_s = &s;
  if (*t != Tree_NoTree) {
    if (x < (*t)->Key) {
      Tree_Delete(x, &(*t)->Left);
    } else if (x > (*t)->Key) {
      Tree_Delete(x, &(*t)->Right);
    } else {
      s = *t;
      if (s->Right == Tree_NoTree) {
        *t = s->Left;
      } else if (s->Left == Tree_NoTree) {
        *t = s->Right;
      } else {
        del(&s->Left);
      }
      Storage_DEALLOCATE(&s, sizeof(Tree_tNode));
    }
  }
  G_1_s = L_1;
}
.sp 0.4v
void
Tree_InOrder(t, p)
Tree_tTree t;
Tree_tProcOfNode p;
{
  if (t != Tree_NoTree) {
    Tree_InOrder(t->Left, p);
    (*p)(t->Key, t->Count);
    Tree_InOrder(t->Right, p);
  }
}
.sp 0.4v
void BEGIN_Tree()
{
  static BOOLEAN has_been_called = FALSE;
.sp 0.4v
  if (!has_been_called) {
    has_been_called = TRUE;
.sp 0.4v
    BEGIN_Storage();
.sp 0.4v
    Tree_Root = Tree_NoTree;
  }
}
.sp 0.4v
/*------ Main.c --------------------------------------------------------*/
.sp 0.4v
#include "SYSTEM.h"
.sp 0.4v
#ifndef DEFINITION_StdIO
#include "StdIO.h"
#endif
.sp 0.4v
#ifndef DEFINITION_Tree
#include "Tree.h"
#endif
.sp 0.4v
#define cMax	4
static SHORTCARD i;
static INTEGER x;
static struct S_1 {
    INTEGER A[cMax - 1 + 1];
} a;
static CARDINAL C_1_i;
static void WriteArray();
static void WriteNode();
.sp 0.4v
static void
WriteArray(a, O_1)
INTEGER a[];
LONGCARD O_1;
{
  {
    LONGCARD B_1 = 0, B_2 = (O_1 - 1);
.sp 0.4v
    if (B_1 <= B_2)
      for (C_1_i = B_1;; C_1_i += 1) {
        StdIO_WriteI(a[C_1_i], 5);
        if (C_1_i >= B_2) break;
      }
  }
}
.sp 0.4v
static void
WriteNode(Key, Count)
INTEGER Key;
CARDINAL Count;
{
  for (C_1_i = Count; C_1_i >= 1; C_1_i += -1) {
    StdIO_WriteI(Key, 5);
  }
}
.sp 0.4v
static void TestOutput()
{}
.sp 0.4v
void BEGIN_MODULE()
{
  BEGIN_StdIO();
  BEGIN_Tree();
  TestOutput();
.sp 0.4v
  for (i = 1; i <= cMax; i += 1) {
    a.A[i - 1] = StdIO_ReadI();
    Tree_Insert(a.A[i - 1], &Tree_Root);
  }
  StdIO_ReadNl();
  WriteArray(a.A, 4L);
  StdIO_WriteNl();
  do {
    Tree_InOrder(Tree_Root, WriteNode);
    StdIO_WriteNl();
    x = StdIO_ReadI();
    StdIO_ReadNl();
    Tree_Delete(x, &Tree_Root);
  } while (!(Tree_Root == Tree_NoTree));
  StdIO_CloseIO();
}
.ps \n(gP
.vs \n(gVu
\&\fP
.fi
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ C: UNIX-Manualseite f\(u:r Mtc\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ C: UNIX-Manualseite f\(u:r Mtc
.hE 0 4n 0.1v
NAME
.br
.in +4n
\&mtc - Modula-2 to C Translator
.in -4n
.sp 0.4v
SYNOPSIS
.br
.in +4n
\&\fBmtc\fP [ options ] [ file ]
.in -4n
.sp 0.4v
DESCRIPTION
.br
.in +4n
\&\%\fIMtc\fP translates \%Modula-2 programs into readable C code.
\%\fIMtc\fP implements the language \%Modula-2 as defined in N. Wirth's
report (3rd edition)
with a few minor restrictions (see below) and most language extensions
implemented by \%\fIMOCKA\fP,
the \%Modula-2 Compiler Karlsruhe. It produces K&R (not ANSI)
C code with a few very common extensions like passing structures as value
parameters.
.sp 0.4v
A definition or foreign module \fImodule\fP.md is translated into a C header file
\fImodule\fP.h. An implementation or program module \fImodule\fP.mi is translated
into the corresponding C source file \fImod\%ule\fP.c.
Separate compilation is
handled by reprocessing all transitively imported def\%i\%ni\%tion modules when
translating a compilation unit. If \fIfile\fP is omitted \fImtc\fP reads from
standard input.
.sp 0.4v
\%\fIMtc\fP is intended as a tool for translating finished programs from
\%Modula-2 to C and not as a tool for program development.
Therefore, the translator
does not check the semantic correctness of the \%Modula-2 programs.
.sp 0.4v
For each foreign module an empty implementation module corresponding to it
has to be translated to C, because the initialization routine
produced for the dummy implementation module is used
within the modules resp. C programs which import
the foreign module.
.sp 0.4v
If the library function \fIalloca\fP is available and the C programs
are compiled with the flag -D\fIStackAlloc\fP\^, then the memory
space for open array value parameters will be allocated in the
stack frame of the corresponding procedure. This temporary
space will be freed automatically when the procedure returns.
Otherwise, \fImalloc\fP and \fIfree\fP will be used to allocate and deallocate
memory space for open array value parameters.
.in -4n
.sp 0.4v
OPTIONS
.br
.in +4n
.br
.ne 2v
\&-w
.in +12n
.if \w'-w\ 'u<12n .sp -1v
\&Suppress warning diagnostics.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-i
.in +12n
.if \w'-i\ 'u<12n .sp -1v
\&Generate header files for imported modules.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-c
.in +12n
.if \w'-c\ 'u<12n .sp -1v
\&Generate type casts to make the C programs \%\fIlint\fP free.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-r
.in +12n
.if \w'-r\ 'u<12n .sp -1v
\&Generate runtime checks.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-h
.in +12n
.if \w'-h\ 'u<12n .sp -1v
\&Print help information.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-t
.in +12n
.if \w'-t\ 'u<12n .sp -1v
\&Print test output (time).
.in -12n
.sp 0.2v
.br
.ne 2v
\&-m
.in +12n
.if \w'-m\ 'u<12n .sp -1v
\&Print test output (memory).
.in -12n
.sp 0.2v
.br
.ne 2v
\&-d\fIdir\fP
.in +12n
.if \w'-d\fIdir\fP\ 'u<12n .sp -1v
\&Allow import from modules in library \fIdir\fP.
.in -12n
.sp 0.2v
.br
.ne 2v
\&-l\fIdir\fP
.in +12n
.if \w'-l\fIdir\fP\ 'u<12n .sp -1v
\&Specify directory where \fImtc\fP finds its tables.
.in -12n
.in -4n
.sp 0.4v
FILES
.br
.in +4n
.br
.ne 2v
\&\fImodule\fP.md
.in +16n
.if \w'\fImodule\fP.md\ 'u<16n .sp -1v
\&Source file of definition or foreign module \fImodule\fP.
.in -16n
.sp 0.2v
.br
.ne 2v
\&\fImodule\fP.mi
.in +16n
.if \w'\fImodule\fP.mi\ 'u<16n .sp -1v
\&Source file of implementation or program module \fImodule\fP.
.in -16n
.sp 0.2v
.br
.ne 2v
\&\fImodule\fP.h
.in +16n
.if \w'\fImodule\fP.h\ 'u<16n .sp -1v
\&C header file produced for \fImodule\fP.md.
.in -16n
.sp 0.2v
.br
.ne 2v
\&\fImodule\fP.c
.in +16n
.if \w'\fImodule\fP.c\ 'u<16n .sp -1v
\&C source file produced for \fImodule\fP.mi.
.in -16n
.sp 0.2v
.br
.ne 2v
\&SYSTEM.h
.in +16n
.if \w'SYSTEM.h\ 'u<16n .sp -1v
\&Definition of standard constants, types, functions, and
macros, which are used in the generated C programs.
.in -16n
.sp 0.2v
.br
.ne 2v
\&SYSTEM.c
.in +16n
.if \w'SYSTEM.c\ 'u<16n .sp -1v
\&Main program and implementation of standard functions.
.in -16n
.in -4n
.sp 0.4v
SEE ALSO
.br
.in +4n
\&\fIEntwurf und Implementierung eines \(U:bersetzers von \%Modula-2 nach C\fP
by M. Martin.
.in -4n
.sp 0.2v
.in +4n
\&\fIProgramming in Modula-2\fP (3rd edition) by N. Wirth.
.in -4n
.sp 0.2v
.in +4n
\&\fIMOCKA User Manual\fP by F. Engelmann.
.in -4n
.sp 0.2v
.in +4n
\&\fIThe C Programming Language\fP by B. W. Kernighan and D. M. Ritchie.
.in -4n
.sp 0.4v
DIAGNOSTICS
.br
.in +4n
\&The translator reports lexical and syntactic errors, errors detected during
the handling of separate compilation, and restrictions of the code generation.
The translator does not check the semantic correctness of the \%Modula-2
programs. The diagnostics produced by \fImtc\fP are intended to be
self-explanatory.
.in -4n
.sp 0.4v
BUGS
.br
.in +4n
\&Coroutines are not supported.
.sp 0.2v
Forward references within pointer declarations are limited to structured types.
.sp 0.2v
Comments are not translated from \%Modula-2 to C.
.sp 0.2v
In some very rare cases the translator has to evaluate constant expressions,
because a literal translation is not possible. The translator will fail to do
this, if the expression or one of
its operands is not in the range \%MIN(INTEGER)\|..\|\%MAX(INTEGER).
.in -4n
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Anhang\ D: Verzeichnis der vom \(U:bersetzer erzeugten Bezeichner\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Anhang\ D: Verzeichnis der vom \(U:bersetzer erzeugten Bezeichner
.hE 0 4n 0.1v
.sp 0.4v
.ne 2v
.ti +2n
Die folgende Tabelle gibt einen \(U:berblick \(u:ber Bezeichner und
Bedeutung der vom \(U:bersetzer \%\fIMtc\fP erzeugten C-Objekte. Die Abk\(u:rzung
\%\fInnn\fP steht dabei f\(u:r eine eindeutige, vom \(U:bersetzer vergebene Nummer.
.sp 0.4v
\s-2
.TS
delim($$)tab(|) center expand box;
c| c
l| lw(12c).
Bezeichner|Bedeutung
_
A|T{
Abbildung von Feldern auf Strukturen mit einem Vektor A als einziger
Komponente (s. Kap. 4.4.2.5)
T}|
BEGIN_MODULE|T{
Rumpf von Programmoduln (s. Kap. 4.8.7)
T}
BEGIN_\fIModulname\fP|T{
Initialisierungsroutine (Rumpf) des (Implementierungs-)Moduls
\%\fIModulname\fP (s. Kap. 4.8.6)
T}
B_\fInnn\fP|T{
Anfangs- bzw. Endwert von FOR-Schleifen (s. Kap. 4.6.5)
T}
DEFINITION_\fIM\fP|T{
Makroname f\(u:r die Steuerung des Einf\(u:gens der Definitionsdatei
des Moduls \%\fIM\fP mit #include-An\%wei\%sun\%gen in alle Moduln,
die \%\fIM\fP importieren (s. Kap. 4.8.1 u. 4.8.4)
T}
EXIT_\fInnn\fP|T{
Sprungziel f\(u:r EXIT-Anweisungen (s. Kap. 4.6.5)
T}
G_\fInnn\fP\^_\fIName\fP|T{
Abbildung von statisch geschachtelten Prozedurdeklarationen:
Globaler Zeiger auf lokale Variable \%\fIName\fP (s. Kap. 4.4.4)
T}
L_\fInnn\fP|T{
Lokale Zeigervariable f\(u:r die Kellerung der Werte von G_\fInnn_Name\fP
bei Rekursion
(s. Kap. 4.4.4)
T}
\fIModulname\fP\^_\fInnn\fP|T{
Strukturnamen f\(u:r vom globalen Modul \%\fIModulname\fP exportierte
Verbunde oder Felder (s. Kap. 4.4.2.6)
T}|
O_\fInnn\fP|T{
Abbildung offener Felder: Zus\(a:tzlicher Parameter mit aktueller Anzahl
von Feldelementen (s. Kap. 4.4.4.1.2)
T}
R_\fInnn\fP|T{
Wert von RETURN-Ausdr\(u:cken (s. Kap. 4.6.7)
T}
S_\fInnn\fP|T{
Strukturnamen f\(u:r nicht exportierte Verbunde oder Felder
(s. Kap. 4.4.2.6)
T}
U_\fInnn\fP\^, V_\fInnn\fP|T{
Abbildung varianter Verbunde durch Einf\(u:hrung zus\(a:tzlicher
Strukturkomponenten (s. Kap. 4.4.2.7)
T}
W_\fInnn\fP|T{
Zeiger auf Verbunde f\(u:r Abbildung von WITH-Anweisungen
(s. Kap. 4.6.6)
T}
X_\fInnn\fP|T{
Feldvariable f\(u:r die Parameter\(u:bergabe von Zeichenketten
(s. Kap. 4.6.2)
T}
dummy|T{
Strukturkomponente f\(u:r in Modula-2 leere Verbunde
T}
.TE
\&\s+2
.sp 0.4v
.sp 0.4v
.ne 2v
.ti +2n
Als C-Bezeichner f\(u:r die Modula-Objekte werden die Bezeichner aus dem
Modula-Programm verwendet. Dabei werden 2 F\(a:lle unterschieden:
.sp 0.3vv
.nr a1 0
.af a1 1
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Der Bezeichner eines von einem globalen Modul
exportierten Objekts wird in C in der
qualifizierten Form \%\fIModulname_Bezeichner\fP geschrieben.
.in -4n
.sp 0.1vv
.sp 0.1vv
.ne 2v
\&\-
.in +4n
.if \w'\-\ 'u<4n .sp -1v
\&Alle \(u:brigen Bezeichner werden direkt aus dem Modula-Programm
\(u:bernommen, werden aber bei Bedarf zur Vermeidung von Namenskonflikten mit
einem Pr\(a:fix C_\fInnn\fP\^_ versehen.
.in -4n
.sp 0.1vv
.sp 0.3vv
.sp 0.4v
.ne 2v
.ti +2n
Alle anderen Bezeichner, die in den C-Programmen verwendet werden, sind Bezeichner
f\(u:r vom \(U:bersetzer \%\fIMtc\fP vordefinierte Objekte, wie z.B. die
C-Definitionen der Standardtypen und -prozeduren der Sprache Modula-2.
Alle diese Objekte sind in SYSTEM.h bzw. SYSTEM.c definiert und ihre
Bedeutung ist aus ihrem Bezeichner ablesbar.
.br
.ne 29.7c
.hA 1 3v 1v
\fB
.hB \w''u
\&Literaturverzeichnis\fP
.hC 1v 0n 0.3v 0 0.1v
\&\ 
.hD 4n
\&Literaturverzeichnis
.hE 0 4n 0.1v
.sp 0.2v
.ne 2v
\&[Aho\|86]
.in +6n
.if \w'[Aho\|86]\ 'u<6n .sp -1v
A. V. Aho, R. Sethi, J. D. Ullman:
Compilers: Principles, Techniques, and Tools.
Addison Wesley, Reading. Ma,
1986.
.in -6n
.sp 0.2v
.ne 2v
\&[Donzeau\|79]
.in +6n
.if \w'[Donzeau\|79]\ 'u<6n .sp -1v
V. Donzeau-Gouge, G. Kahn, B. Krieg-Br\(u:ckner, B. Lang:
Formal Definition of Ada (preliminary draft).
CII Honeywell Bull,
Okt. 1979.
.in -6n
.sp 0.2v
.ne 2v
\&[Engelmann\|87]
.in +6n
.if \w'[Engelmann\|87]\ 'u<6n .sp -1v
F. Engelmann:
GMD MODULA SYSTEM MOCKA \- User Manual.
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
Dez. 1987.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|87a]
.in +6n
.if \w'[Grosch\|87a]\ 'u<6n .sp -1v
J. Grosch:
Reusable Software \- A Collection of MODULA-Modules.
Compiler Generation Report No. 4,
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
Sept. 1987.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|87b]
.in +6n
.if \w'[Grosch\|87b]\ 'u<6n .sp -1v
J. Grosch:
Rex \- A Scanner Generator.
Compiler Generation Report No. 5,
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
Dez. 1987.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|89a]
.in +6n
.if \w'[Grosch\|89a]\ 'u<6n .sp -1v
J. Grosch:
Ast \- A Generator for Abstract Syntax Trees (Revised Version).
Compiler Generation Report No. 15,
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
Aug. 1989.
.in -6n
.sp 0.2v
.ne 2v
\&[Grosch\|89b]
.in +6n
.if \w'[Grosch\|89b]\ 'u<6n .sp -1v
J. Grosch:
Ag \- An Attribute Evaluator Generator.
Compiler Generation Report No. 16,
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
Aug. 1989.
.in -6n
.sp 0.2v
.ne 2v
\&[Kastens\|80]
.in +6n
.if \w'[Kastens\|80]\ 'u<6n .sp -1v
U. Kastens:
Ordered Attributed Grammars.
Acta Informatica 13, 229\-256,
1980.
.in -6n
.sp 0.2v
.ne 2v
\&[Kastens\|82]
.in +6n
.if \w'[Kastens\|82]\ 'u<6n .sp -1v
U. Kastens, B. Hutt, E. Zimmermann:
GAG: A Practical Compiler Generator.
Springer Verlag, Heidelberg,
1982.
.in -6n
.sp 0.2v
.ne 2v
\&[Kernighan\|78]
.in +6n
.if \w'[Kernighan\|78]\ 'u<6n .sp -1v
B. W. Kernighan, D. M. Ritchie:
The C Programming Language.
Prentice-Hall,
Englewood Cliffs,
N.J.,
1978.
.in -6n
.sp 0.2v
.ne 2v
\&[Kernighan\|83]
.in +6n
.if \w'[Kernighan\|83]\ 'u<6n .sp -1v
B. W. Kernighan, D. M. Ritchie:
Programmieren in C.
Carl Hanser Verlag,
M\(u:nchen, Wien,
1983.
.in -6n
.sp 0.2v
.ne 2v
\&[Klein\|86]
.in +6n
.if \w'[Klein\|86]\ 'u<6n .sp -1v
E. Klein, J. Grosch:
User Manual for the PGS-System.
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
Aug. 1986.
.in -6n
.sp 0.2v
.ne 2v
\&[PascAda\|80]
.in +6n
.if \w'[PascAda\|80]\ 'u<6n .sp -1v
P. F. Albrecht, P. E. Garrison, S. L. Graham,
R. H. Hyerle, P. Ip, B. Krieg-Br\(u:ckner:
Source-to-Source Translation: Ada to Pascal and Pascal to Ada.
Symposium on the Ada Programming Language,
ACM-SIGPLAN,
1980.
.in -6n
.sp 0.2v
.ne 2v
\&[PTC\|87]
.in +6n
.if \w'[PTC\|87]\ 'u<6n .sp -1v
P. Bergsten:
PTC implementation note.
Holistic Technology AB,
Grona Gatan 59,
41454 Gothenburg,
Sweden,
1987.
.in -6n
.sp 0.2v
.ne 2v
\&[UNIX\|79]
.in +6n
.if \w'[UNIX\|79]\ 'u<6n .sp -1v
The UNIX Programmers Manual.
Volume 1, 2a, 2b,
Bell Laboratories,
1979.
.in -6n
.sp 0.2v
.ne 2v
\&[Vielsack\|88]
.in +6n
.if \w'[Vielsack\|88]\ 'u<6n .sp -1v
B. Vielsack:
The Parser Generators Lalr and Ell.
Compiler Generation Report No. 8,
GMD Forschungsstelle an der Universit\(a:t Karlsruhe,
April 1988.
.in -6n
.sp 0.2v
.ne 2v
\&[Vielsack\|89]
.in +6n
.if \w'[Vielsack\|89]\ 'u<6n .sp -1v
B. Vielsack:
Spezifikation und Implementierung der Transformation attributierter B\(a:ume.
Diplomarbeit,
Universit\(a:t Karlsruhe, Fakult\(a:t f\(u:r Informatik,
Juni 1989.
.in -6n
.sp 0.2v
.ne 2v
\&[Waite\|84]
.in +6n
.if \w'[Waite\|84]\ 'u<6n .sp -1v
W. M. Waite, G. Goos: Compiler Construction.
Springer Verlag, New York,
1984.
.in -6n
.sp 0.2v
.ne 2v
\&[Wirth\|85]
.in +6n
.if \w'[Wirth\|85]\ 'u<6n .sp -1v
N. Wirth:
Programming in Modula-2 (3rd edition).
Springer Verlag, Berlin, Heidelberg, New York, Tokyo,
1985.
.in -6n
.br
.ne 29.7c
.eo
.ds f1 
.ds f2 
.ds f3 
.ec
.eo
.ds f4 
.ds f5 
.ds f6 
.ec
.eo
.ds f7 
.ds f8 
.ds f9 
.ec
.de fX
.fi
.nf
..
\fBInhaltsverzeichnis\fP
.sp 1v
.hH
